<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ybyb</title>
    <link>https://zcy2875634712.github.io/</link>
    <description>Recent content on ybyb</description>
    <image>
      <title>ybyb</title>
      <url>https://zcy2875634712.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://zcy2875634712.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator><atom:link href="https://zcy2875634712.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/c/%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/c/%E6%96%87%E4%BB%B6/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/go/%E9%80%9F%E6%9F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/go/%E9%80%9F%E6%9F%A5/</guid>
      <description>Variables:
goCopy codevar name string = &amp;#34;John&amp;#34; age := 30 // type inferred as int var ( city string = &amp;#34;New York&amp;#34; zipCode int = 10001 ) Data Types:
goCopy codebool string int, int8, int16, int32, int64 uint, uint8, uint16, uint32, uint64, uintptr byte (alias for uint8) rune (alias for int32) float32, float64 complex64, complex128 Constants:
goCopy codeconst pi = 3.14 const ( monday = &amp;#34;Monday&amp;#34; tuesday = &amp;#34;Tuesday&amp;#34; ) Control Structures:</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/linux/linux%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/linux/linux%E5%91%BD%E4%BB%A4/</guid>
      <description>tar 解压tar -xvf filename
压缩tar -zcvf filename.tar.gz filename</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/linux/ncurses/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/linux/ncurses/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/linux/shell/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/linux/shell/</guid>
      <description>Bash 参数拓展 删除前缀后缀
echo $str	# a.b.c.d echo ${str%.*}	# a.b.c echo ${str%%.*}	# a echo ${str#*.}	#b.c.d echo ${str##*.}	#d sed #删除 sed &amp;#39;/^$/d&amp;#39; &amp;lt;file&amp;gt; </description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/linux/vim/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/linux/vim/</guid>
      <description>动词
d # 表示删除delete r # 表示替换replace c # 表示修改change y # 表示复制yank v # 表示选取visual select 名词
w # 表示一个单词word s # 表示一个句子sentence p # 表示一个段落paragraph t # 表示一个 HTML 标签tag 介词
i # 表示在...之内 inside a # 表示环绕... around t # 表示到...位置前 to f # 表示到...位置上 forward 动词+介词+名词
diw di{ </description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/python/flask/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/python/flask/</guid>
      <description>开始 from flask import Flask app = Flask(__name__)	#实例化Flask类，__name__为程序名 # 注册路由,路由负责管理URL和函数之间的映射, 而这个函数则被称为视图函数 @app.route(&amp;#39;/&amp;#39;) def index(): return &amp;#39;hello&amp;#39; 运行服务器：flash run
数据库 ORM ORM 把数据库映射成对象。 数据库的表（table） --&amp;gt; 类（class） 记录（record，行数据）	--&amp;gt; 对象（object） 字段（field）	--&amp;gt; 对象的属性（attribute） 初始化 from flask_sqlalchemy import SQLAlchemy app = Flask(__name__) db = SQLAlchemy(app) 模型类 class User(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(20)) age = db.Column(db.Integer) CRUD ############创建############ record = User(name=&amp;#39;Jack&amp;#39;, age=33) db.session.add(record) db.session.commit() ############查找############ record = User.query.filter_by(name=&amp;#39;Jack&amp;#39;) ############读取############ age = record.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/python/%E9%80%9F%E6%9F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/python/%E9%80%9F%E6%9F%A5/</guid>
      <description>基本语法 # 输出到控制台 print(&amp;#34;Hello, world!&amp;#34;) # 定义变量 x = 42 y = &amp;#34;Python&amp;#34; # 条件语句 if x &amp;gt; 0: print(&amp;#34;x is positive&amp;#34;) elif x == 0: print(&amp;#34;x is zero&amp;#34;) else: print(&amp;#34;x is negative&amp;#34;) # 循环 for i in range(10): print(i) # 列表 fruits = [&amp;#34;apple&amp;#34;, &amp;#34;banana&amp;#34;, &amp;#34;cherry&amp;#34;] print(fruits[0]) # 输出 &amp;#34;apple&amp;#34; print(len(fruits)) # 输出 3 # 字典 person = {&amp;#34;name&amp;#34;: &amp;#34;John&amp;#34;, &amp;#34;age&amp;#34;: 30} print(person[&amp;#34;name&amp;#34;]) # 输出 &amp;#34;John&amp;#34; print(person.get(&amp;#34;gender&amp;#34;, &amp;#34;unknown&amp;#34;)) # 输出 &amp;#34;unknown&amp;#34; # 函数 def greet(name): print(&amp;#34;Hello, &amp;#34; + name + &amp;#34;!</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/tmp/10/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/tmp/10/</guid>
      <description>复习笔记
一、面向对象设计的准则 1 模块化 2 抽象 3 信息隐藏 在面向对象的软件中，信息隐藏通过对象的封装来实现，即类结构分离 了接口与实现，从而支持了信息隐藏。 4 弱耦合 一般而言，对象之间的耦合可分为两大类： （1）交互耦合 对象间的耦合通过消息连接来实现，则这种耦合是交互耦合。要使交互 耦合尽可能松散。 （2）继承耦合继承耦合的模块彼此之间应该结合得越紧密越好。 5 强内聚 在面向对象设计中存在下述3种内聚： （1）服务内聚； （2）类内聚； （3）一般-特殊内聚。 6 可重用 重用有两方面的含义： ① 尽量使用已有的类。 ② 如果需要创建新类，则在设计这些新类的协议时应该考虑将来的可重 复使用性。
二、启发规则 1 设计结果应该清晰易懂 2 一般-特殊结构的深度应适当3 设计简单的类 4 使用简单的协议 5 使用简单的服务 6 把设计变动减至最小 图11-1 理想的设计变动情况 理想的设计变动曲线如图11-1所示。即在设计的早期阶段，变动较大， 随着时间推移，设计方案日趋成熟，改动也越来越小了。
三、软件重用 1 概述（1）重用 重用也叫再用或复用，是指同一事物不作修改或稍加改动就多次重复使 用。软件重用可分为以下3个层次： ① 知识重用； ② 方法和标准的重用； ③ 软件成分的重用。 （2）软件成分的重用级别 ① 代码重用； ② 设计结果重用； ③ 分析结果重用。 （3）典型的可重用软件成分 ① 项目计划； ② 成本估计； ③ 体系结构； ④ 需求模型和规格说明； ⑤ 设计； ⑥ 源代码；⑦ 用户文档和技术文档； ⑧ 用户界面； ⑨ 数据； ⑩ 测试用例。 2 类构件 （1）可重用软构件的特点 ① 模块独立性强； ② 具有高度可塑性； ③ 接口清晰、简明、可靠。 （2）类构件的重用方式 ① 实例重用； ② 继承重用； ③ 多态重用。 3 软件重用的效益 （1）重用给软件产品的质量和可靠性带来实质性的提高。 （2）使生产率得到了提高。（3）节省了成本。 软件重用带来的净成本节省可以用下式估算：C＝Cs－Cr－Cd。其中， Cs是项目从头开发时所需要的成本；Cr是与重用相关联的成本；Cd是交 付给客户的软件的实际成本。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/tmp/11/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/tmp/11/</guid>
      <description>复习笔记
一、程序设计语言 面向对象实现需要把面向对象设计结果翻译成用某种程序语言书写的面 向对象程序，并对其测试和调试。 1 面向对象语言的优点 （1）一致的表示方法； （2）可重用性好； （3）可维护性好。 2 面向对象语言的技术特点 （1）支持类与对象概念的机制。 【注意】自动管理内存必须采用先进的垃圾收集算法才能减少开销。 （2）实现聚集结构的机制。 （3）实现泛化结构的机制。（4）实现属性和服务的机制。 （5）类型检查。 （6）提供类库。 （7）效率高。 （8）持久保存对象。 （9）参数化类。 （10）有良好的软件工具和软件工程环境。 3 选择面向对象语言的标准 （1）将来能否占主导地位。 （2）可重用性。 （3）类库和开发环境。 【注意】语言、开发环境和类库这3个因素综合起来，共同决定了可重用 性。 （4）其他因素。 ① 对用户学习面向对象分析、设计和编码技术所能提供的培训服务； ② 在使用这个面向对象语言期间能提供的技术支持； ③ 能提供给开发人员使用的开发工具、开发平台、发行平台；④ 对机器性能和内存的需求； ⑤ 集成已有软件的容易程度等。
二、程序设计风格 1 概念 （1）良好的程序设计风格的重要性 ① 能明显减少维护或扩充的开销。 ② 有助于在新项目中重用已有的程序代码。 （2）良好的面向对象程序设计风格的内容 ① 传统的程序设计风格准则。 ② 为适应面向对象方法所特有的概念而必须遵循的一些新准则。 2 提高可重用性 （1）代码重用 ① 内部重用，即本项目内的代码重用。 ② 外部重用，即新项目重用旧项目的代码。 （2）实现代码重用的主要准则 ① 提高方法的内聚。② 减小方法的规模。 ③ 保持方法的一致性。 ④ 把策略与实现分开。 ⑤ 全面覆盖。 ⑥ 尽量不使用全局信息。 ⑦ 利用继承机制。 a．调用子过程： 图12-1 通过调用公用方法实现代码重用 b．分解因子： 图12-2 c．使用委托； d．把代码封装在类中。 通过因子分解实现代码重用3 提高可扩充性 提高可扩充行的主要准则为： （1）封装实现策略； （2）不要用一个方法遍历多条关联链； （3）避免使用多分支语句； （4）精心确定公有方法。 4 提高健壮性 （1）健壮性定义 健壮性是在硬件故障、输入的数据无效或操作错误等意外环境下，系统 能做出适当响应的程度。 （2）提高健壮性的主要准则 ① 预防用户的操作错误； ② 检查参数的合法性； ③ 不要预先确定限制条件； ④ 先测试后优化。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/tmp/12/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/tmp/12/</guid>
      <description>复习笔记 一、估算软件规模 软件项目管理先于任何技术活动之前开始，并且贯穿于软件的整个生命 周期之中，而制定计划的基础是工作量估算和完成期限估算。 1 代码行技术 （1）定义 代码行技术依据以往开发类似产品的经验和历史数据，估计实现一个功 能所需要的源程序行数。 （2）方法 ① 每名工程师估计程序的最小规模（a）、最大规模（b）和最可能的规 模（m），分别算出这3种规模的平均值后，再用下式计算程序规模的 估计值： （13.1） ② 程序较小时用的单位是代码行数（LOC）；程序较大时用的单位是千 行代码数（KLOC）。（3）优点 ① 代码是所有软件开发项目都有的“产品”，而且很容易计算代码行数。 ② 有以往开发类似产品的历史数据可参考时，估计出的数值比较准确。 （4）缺点 ① 源程序仅是软件配置的一个成分，用它的规模代表整个软件的规模不 太合理。 ② 用不同语言实现同一个软件所需要的代码行数并不相同。 ③ 不适用于非过程语言。 2 功能点技术 （1）特点 ① 功能点技术依据对软件信息域特性和软件复杂性的评估结果，估算软 件规模。 ② 以功能点（FP）为单位度量软件规模。 （2）信息域特性 ① 输入项数（Inp） ② 输出项数（Out） ③ 查询数（Inq）④ 主文件数（Maf） ⑤ 外部接口数（Inf） （3）估算功能点的步骤 ① 计算未调整的功能点数UFP 需记住公式： UFP＝a1×Inp＋a2×Out＋a3×Inq＋a4×Maf＋a5×Inf 其中，ai（1≤i≤5）是信息域特性系数，由相应特性的复杂级别决定，如 表13-1所示。 表13-1 信息域特性系数值 ② 计算技术复杂性因子TCF 在表13-2中列出了全部技术因素，并用Fi（1≤i≤14）代表这些因素。 表13-2 技术因素a．根据软件的特点，为每个因素分配一个从0到5的值。 b．用下式计算技术因素对软件规模的综合影响程度DI（0～70）： c．技术复杂性因子TCF（0.65～1.35）由下式计算：TCF＝0.65＋ 0.01×DI ③ 计算功能点数FP 用下式计算功能点数FP：FP＝UFP×TCF （4）功能点技术的优缺点 ① 优点：功能点数与所用的编程语言无关，比代码行技术更合理；② 缺点：在判断信息域特性复杂级别和技术因素的影响程度时，功能点 技术存在相当大的主观因素。 二、工作量估算 1 工作量概念 工作量是软件规模的函数，工作量的单位通常是人月（pm）。 2 静态单变量模型 （1）形式 静态单变量模型的总体结构形式如下： E=A+B×(eν)c 其中，A、B和C是由经验数据导出的常数，E是以人月为单位的工作 量，eν是估算变量（KLOC或FP）。 （2）分类 ① 面向KLOC的估算模型 a．Walston_Felix模型：E=5.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/tmp/3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/tmp/3/</guid>
      <description>复习笔记 一、概述 1 非形式化方法的缺点 （1）矛盾； （2）二义性； （3）含糊性； （4）不完整性； （5）抽象层次混乱。 【注意】用自然语言描述需求规格说明，是典型的非形式化方法。 2 形式化方法的优点 （1）能保证规格说明中尽可能没有矛盾、二义性、含糊性和不完整性。 （2）可以在不同的软件工程活动之间平滑地过渡。 （3）提供了高层确认的手段。3 形式化方法的缺点 （1）难于表示问题的时序、控制和行为等方面的需求。 （2）相比欠形式化方法，它更难学习，培训的投资过大。 【注意】如果一种方法有坚实的数学基础，那么它就是形式化的。 4 应用形式化方法的准则 （1）应该选用适当的表示方法。 （2）应该形式化，但不要过分形式化。 （3）应该估算成本。 （4）应该有形式化方法顾问随时提供咨询。 （5）不应该放弃传统的开发方法。 （6）应该建立详尽的文档。 （7）不应该放弃质量标准。 （8）不应该盲目依赖形式化方法。 （9）应该测试、测试再测试。 （10）应该重用。 二、有穷状态机1 概念 （1）定义 有穷状态机是表达规格说明的一种形式化方法。 （2）构成 一个有穷状态机包括下述5个部分：状态集J、输入集K、由当前状态和 当前输入确定下一个状态（次态）的转换函数T、初始态S和终态集F。 一个有穷状态机可以表示为一个5元组（J，K，T，S，F）。其中：J是 一个有穷的非空状态集；K是一个有穷的非空输入集；T是一个从(J- F)×K到J的转换函数；S∈J，是一个初始状态；F⊆J，是终态集。 （3）状态转换形式 当前状态[菜单]＋事件[所选择的项]⇒下个状态 （4）谓词集P ① 谓词集P把有穷状态机扩展为一个6元组，其中每个谓词都是系统全 局状态Y的函数。 ② 加入谓词集后转换规则形式为：当前状态[菜单]＋事件[所选择的项] ＋谓词⇒下个状态。 2 评价 （1）优点 ① 采用易于书写、易于验证的格式来描述规格说明，能容易地把规格说明转变成设计或程序代码。 ② 比数据流图技术更精确且易于理解。 （2）缺点 ① 在开发一个大系统时，三元组（即状态、事件、谓词）的数量会迅速 增长。 ② 形式化的有穷状态机方法没有处理定时需求。 三、Petri网 1 概念 （1）构成 ① 一般构成 Petri网包含4种元素：一组位置P、一组转换T、输入函数I，以及输出函 数O。如图4-1为Petri网的实例。 图4-1 Petri网的组成a．一组位置P为{P1，P2，P3，P4}，在图中用圆圈代表位置。 b．一组转换T为{T1，T2}，在图中用短直线表示转换。 c．两个用于转换的输入函数，用由位置指向转换的箭头表示，它们 是： I(t1)={P2，P4} I(t2)={P2} d．两个用于转换的输出函数，用由转换指向位置的箭头表示，它们 是： O(t1)={P1} O(t2)={P3，P3} 【注意】输出函数O(t1)中有两个P3，是因为有两个箭头由t2指向P3。 ② 形式化的Petri网 更形式化的Petri网结构是一个四元组： C=(P，T，I，O) 其中： a．P={P1，…，Pn}是一个有穷位置集，n≥0。 b．T={t1，…，tm}是一个有穷转换集，m≥0，且T和P不相交。 c．I：T→P∞为输入函数，是由转换到位置无序单位组（bags）的映射。 d．O：T→P∞为输出函数，是由转换到位置无序单位组的映射。 （2）作用 用于确定系统中隐含的定时问题，可以有效地描述并发活动。 四、Z语言 1 组成部分 （1）给定的集合； （2）状态定义； （3）初始状态； （4）操作。 2 优点 （1）可以比较容易地发现用Z写的规格说明的错误； （2）使用Z写规格说明时对精确性要求高，减少了模糊性、不一致性和 遗漏； （3）可以降低软件开发费用； （4）用Z写规格说明，更加清楚和正确。4.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/tmp/8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/tmp/8/</guid>
      <description>复习笔记
一、面向对象方法学概述 1 要点 （1）定义 面向对象方法是一种以数据或信息为主线，把数据和处理相结合的方 法。 （2）要点 ① 对象； ② 类； ③ 继承性； ④ 封装性。 【注意】考生需理解四个要点各自的含义。 2 面向对象方法学的优点 （1）与人类习惯的思维方法一致；（2）稳定性好； （3）可重用性好； （4）较易开发大型软件产品； （5）可维护性好。
二、面向对象的概念 1 对象 （1）对象的定义 ① 面向对象程序设计的角度：对象是具有相同状态的一组操作的集合。 ② 结构化的角度：对象是封装了数据结构及可以施加在这些数据结构上 的操作的封装体。 （2）对象的特点 ① 以数据为中心； ② 对象是主动的； ③ 实现了数据封装； ④ 具有并行性； ⑤ 模块独立性好。2 其他概念 （1）类 类是对具有相同数据和相同操作的一组相似对象的定义。 （2）实例 实例就是由某个特定的类所描述的一个具体的对象。 【注意】类是对象的抽象，对象是类的实例。 （3）消息 ① 定义：消息就是要求某个对象执行在定义它的那个类中所定义的某个 操作的规格说明。 ② 组成：一个消息由接收消息的对象、消息选择符、零个或多个变元组 成。 （4）方法 方法就是对象所能执行的操作，也就是类中所定义的服务。 （5）属性 属性就是类中所定义的数据，它是对客观世界实体所具有的性质的抽 象。 （6）封装 封装是把数据和实现操作的代码集中起来放在对象内部。（7）继承 ① 定义 继承是子类自动地共享基类中定义的数据和方法的机制。 ② 特点 a．继承具有传递性； b．低层的性质将屏蔽高层的同名性质。 ③ 分类 a．单继承：一个类只允许有一个父类，即类等级为树形结构。 b．多重继承：允许一个类有多个父类。 （8）多态性 ① 定义 多态性指在类等级的不同层次中可以共享一个方法的名字，不同层次中 的每个类各自按自己的需要来实现这个行为。 【注意】在C++中，多态性是通过虚函数来实现的。 ② 动态联编 在运行时刻根据接收消息的对象所属于的类，决定执行哪个特定版本的 函数，这称为动态联编（滞后联编）。 ③ 优点a．增加了面向对象软件系统的灵活性，进一步减少了信息冗余。 b．显著提高了软件的可重用性和可扩充性。 （9）重载 ① 分类 a．函数重载 在同一作用域内的若干个参数特征不同的函数可以使用相同的函数名 字。 【注意】常考点：重载函数的形式参数（指参数的个数或者类型或者顺 序）必须不同，而与函数返回值类型无关。 b．运算符重载 同一个运算符可以施加于不同类型的操作数上面。 ② 实现 a．函数重载是通过静态联编（先前联编）实现的。 b．运算符重载是在编译时根据被操作数的类型，决定使用该算符的哪 种语义。 ③ 优点 进一步提高了面向对象系统的灵活性和可读性。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/tmp/9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/tmp/9/</guid>
      <description>复习笔记
一、面向对象分析的基本过程 1 概述 （1）定义 面向对象分析，就是抽取和整理用户需求并建立问题域精确模型的过 程。 （2）过程 ① 分析陈述用户需求的文件； ② 深入理解用户需求，抽象出目标系统的本质属性； ③ 用模型准确地表示。 （3）目的 全面深入地理解问题域和用户的真实需求，建立问题域的精确模型。 2 3个子模型与5个层次 （1）3个模型面向对象建模得到的模型包含系统的三个要素，即 ① 静态结构（对象模型）； ② 交互次序（动态模型）； ③ 数据变换（功能模型）。 【注意】3种模型中，对象模型是最基本、最重要、最核心的。 （2）5个层次 复杂问题的对象模型由5个层次组成，如图10-1所示。 图10-1 复杂问题的对象模型的5个层次
二、需求陈述 1 内容 （1）阐明“做什么”而不是“怎样做”。 （2）描述用户的需求而不是提出解决问题的方法。 （3）指出哪些是系统必要的性质，哪些是任选的性质。 （4）避免对设计策略施加过多的约束，不描述系统的内部结构。2 书写要点 （1）做到语法正确，慎重选用名词、动词、形容词和同义词。 （2）必须把需求与实现策略区分开。 （3）需求陈述可简可繁。 （4）避免出现具有二义性的、不完整的、不一致的内容。
三、建立对象模型 1 先建立对象模型的原因 （1）静态数据结构对应用细节依赖较少，比较容易确定。 （2）当用户的需求变化时，静态数据结构相对来说比较稳定。 2 信息来源 需求陈述、应用领域的专业知识、客观世界的常识是建立对象模型时的 主要信息来源。 3 建立对象模型的步骤 （1）确定类与对象。 ① 找出候选的类与对象；② 筛选出正确的类与对象。 （2）确定关联。 【注意】在分析确定关联的过程中，不必花过多的精力去区分关联和聚 集，聚集是一种特殊的关联。 （3）划分主题。 （4）确定属性。 （5）识别继承关系。 （6）反复修改。
四、建立动态模型 1 概念 （1）适用性 ① 对于仅存储静态数据的系统来说，动态模型并没有什么意义。 ② 在开发交互式系统时，动态模型起着很重要的作用。 ③ 应用系统的主要工作是收集输入信息时，建立正确的动态模型是至关 重要的。 （2）步骤 ① 编写典型交互行为的脚本。② 从脚本中提取出事件，确定触发每个事件的动作对象以及接受事件的 目标对象。 ③ 排列事件发生的次序，确定每个对象的状态及状态间的转换关系，用 状态图描绘。 ④ 比较各个对象的状态图，确保事件之间的匹配。 2 编写脚本 （1）定义 脚本是指系统在某一执行期间内出现的一系列事件。 （2）目的 编写脚本的目的是保证不遗漏重要的交互步骤，有助于确保交互过程的 正确性、清晰性。 3 设想用户界面 （1）重要性 用户界面的好坏往往对用户是否喜欢、是否接受一个系统起很重要的作 用。 （2）目的 确保能够完成全部必要的信息交换，而不会丢失重要的信息。【注意】当前阶段重要的是在界面下的信息交换方式，而不是用户界面 的细节。 4 画事件跟踪图 （1）一条竖线代表一个对象； （2）每个事件用一条水平的箭头线表示； （3）箭头方向从事件的发送对象指向接受对象； （4）时间从上向下递增； （5）用箭头线在垂直方向上的相对位置表示事件发生的先后，不表示事 件间的时间差。 5 画状态图 （1）定义 状态图描绘事件与对象状态的关系，它确定了由事件序列引出的状态序 列。 （2）方法 ① 仅考虑事件跟踪图中指向某条竖线的那些箭头线。把这些事件作为状 态图中的有向边，边上标以事件名。 ② 给每个状态取个有意义的名字。③ 根据一张事件跟踪图画出状态图后，再把其他脚本的事件跟踪图合并 到该图中。 ④ 考虑完正常事件后再考虑边界情况和特殊情况，包括在不适当时候发 生的事件。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/tmp/%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/tmp/%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6/</guid>
      <description>复习笔记
一、可行性研究的任务 1 可行性研究的目的 用最小的代价在尽可能短的时间内确定问题是否能够解决。 2 可行性研究的任务 （1）对以后的行动方针提出建议。 （2）分析几种主要的候选解法的利弊，研究其可行性。 3 可行性研究的3个方面 （1）技术可行性； （2）经济可行性； （3）操作可行性。
二、可行性研究过程典型的可行性研究过程为： 1．复查系统规模和目标； 2．研究目前正在使用的系统； 3．导出新系统的高层逻辑模型； 4．进一步定义问题； 5．导出并评价供选择的解法； 6．推荐行动方针； 7．草拟开发计划； 8．书写文档提交审查。
三、系统流程图 1 定义 系统流程图是概括地描绘物理系统的传统工具。 2 基本思想 用图形符号以黑盒子形式描绘组成系统的每个部件（程序、文档、数据 库、人工过程等）。 【注意】系统流程图表达的是数据在系统各部件之间流动的情况，而不 是对数据进行加工处理的控制过程。3 符号 （1）以概括的方式抽象地描绘实际系统时，使用图2-1中列出的基本符 号就足够了。 图2-1 基本符号 【注意】这5种基本符号是常考点。 （2）需要更具体地描绘一个物理系统时，还需要使用图2-2中列出的系 统符号。图2-2 系统符号 【注意】系统流程图的习惯画法是使信息在图中从顶向下或从左向右流 动。
四、数据流图 1 概念 （1）定义 数据流图（DFD）是一种图形化技术。它描绘信息流和数据从输入移动到输出的过程中所经受的变换。 （2）特点 ① 数据流图中没有具体的物理部件，只是描绘数据在软件中流动和被处 理的逻辑过程。 ② 数据流图是系统逻辑功能的图形表示，是分析员与用户之间极好的通 信工具。 ③ 设计时只需考虑系统必须完成的基本逻辑功能，不考虑怎样具体地实 现这些功能。 2 符号 如图2-3（a）所示，数据流图有4种基本符号；图2-3（b）给出了附加符 号的含义。其中星号（*）表示数据流之间是“与”关系；加号（＋）表 示“或”关系；⊕号表示只能从中选一个（互斥的关系）。图2-3 数据流图的符号 【注意】数据流中用箭头表示数据流，第5章的程序流程图中用箭头表示 的控制流。
五、数据字典概念 （1）定义 数据字典是关于数据的信息的集合，是对数据流图中包含的所有元素的 定义的集合。 （2）意义 数据流图和数据字典共同构成系统的逻辑模型。 2 组成元素 ① 数据流； ② 数据流分量，即数据元素； ③ 数据存储； ④ 处理。 3 数据字典的用途 （1）作为分析阶段的工具（最重要）。 （2）数据字典中包含的每个数据元素的控制信息是很有价值的。 （3）数据字典是开发数据库的第一步，而且是很有价值的一步。4 数据字典的实现 （1）开发大型软件系统时建议使用数据字典处理程序。 （2）在开发小型软件系统时建议采用卡片形式书写数据字典 数据字典卡片</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/tmp/%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/tmp/%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1/</guid>
      <description>复习笔记
一、设计过程 1 目的 总体设计的基本目的就是回答“系统应该如何实现”这个问题。 2 主要任务 （1）划分出组成系统的物理元素——程序、文件、数据库、人工过程和 文档等。 （2）确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的 关系。 【注意】每个物理元素的具体实现是详细阶段的任务。 3 必要性 可以站在全局高度上，以较少的成本选出最佳方案和最合理的软件结构 并开发出较高质量的软件系统。4 组成阶段 （1）系统设计阶段，确定系统的具体实现方案。 （2）结构设计阶段，确定软件结构。 5 典型的总体设计过程（略）
二、设计原理 1 模块化 （1）定义 模块化就是把程序划分成独立命名且可独立访问的模块，每个模块完成 一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能 满足用户的需求。 （2）优点 ① 使软件结构清晰，不仅容易设计也容易阅读和理解。 ② 使软件容易测试和调试，有助于提高软件的可靠性。 ③ 提高软件的可修改性。 ④ 有助于软件开发工程的组织管理。 【注意】模块是构成程序的基本构件。 2 抽象 （1）定义 抽象就是抽出事物的本质特性而暂时不考虑它们的细节。 （2）优点 ① 简化了软件的设计和实现； ② 提高了软件的可理解性和可测试性； ③ 使得软件更容易维护。 3 逐步求精 （1）定义 定义为：为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。 （2）原理 ① 逐步求精是一种自顶向下的设计策略。 ② 求精实际上是细化过程。 4 信息隐藏和局部化 （1）局部化定义 指把一些关系密切的软件元素物理地放得彼此靠近。（2）信息隐藏原理 使得一个模块内包含的信息（主要是实现细节）对于不需要这些信息的 模块来说，是不能访问的。 5 模块独立 （1）定义 开发的模块具有独立功能而且和其他模块之间没有过多的相互作用的模 块，就可以做到模块独立。 （2）两个度量标准：耦合和内聚。 （3）耦合 ① 定义 耦合是对一个软件结构内不同模块之间互连程度的度量。 ② 分类 a．完全独立； b．数据耦合； c．控制耦合； d．特征耦合； e．公共环境耦合；f．内容耦合。 【说明】教材中给出上述六种分类，但个人所学和网上更普遍的分类是 下图中的七种。 （4）内聚 ① 定义 内聚衡量一个模块内部各个元素彼此结合的紧密程度。 ② 分类 【注意】考生牢记：设计的软件尽量满足“高内聚、低耦合”和“高扇入、 低扇出”原则。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/tmp/%E7%BC%96%E7%A0%81%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/tmp/%E7%BC%96%E7%A0%81%E6%B5%8B%E8%AF%95/</guid>
      <description>复习笔记
一、编码 一般将编码和测试统称为实现。 1．编码的定义 编码是把软件设计结果翻译成用程序设计语言书写的程序。 2．效率 效率主要指处理机时间和存储器容量两个方面。
二、软件测试基础 1 软件测试的定义 测试是为了发现程序中的错误而执行程序的过程。 2 软件测试的目标 （1）好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案。 （2）成功的测试是发现了至今为止尚未发现的错误的测试。（3）根本目标是尽可能多地发现并排除软件中潜藏的错误，最终把一个 高质量的软件系统交给用户使用。 【注意】测试只能查找出程序中的错误，不能证明程序中没有错误。测 试的目标是发现错误，调试的任务是在测试的基础上去改正错误。 3 测试方法 （1）白盒测试 ① 白盒测试（结构测试）把程序看成装在一个透明的白盒子里，测试者 完全知道程序的结构和处理算法。 ② 按照程序内部的逻辑测试程序，检测程序中的主要执行通路是否都能 按预定要求正确工作。 （2）黑盒测试 ① 黑盒测试（功能测试）把程序看作一个黑盒子，完全不考虑程序的内 部结构和处理过程。 ② 黑盒测试是在程序接口进行的测试，只检查程序功能是否能按照规格 说明书的规定正常使用。 4 测试步骤 （1）单元测试（模块测试） ① 定义：单元测试把每个模块作为一个单独的实体来测试，检验其正确性。 ② 目的：保证每个模块作为一个单元能正确运行。 【注意】单元测试发现的是编码和详细设计的错误。 （2）子系统测试 ① 定义：子系统测试把经过单元测试的模块放在一起形成一个子系统来 测试。 ② 目的：着重测试模块的接口。 （3）系统测试 ① 定义：系统测试是把经过测试的子系统装配成一个完整的系统来测 试。 ② 目的：发现设计和编码的错误，并验证系统确实能提供需求说明书中 指定的功能。 【注意】子系统测试和系统测试都属于集成测试。 （4）验收测试（确认测试） ① 定义：在用户的参与下，把软件系统作为单一的实体，使用实际数据 进行测试。 ② 目的：验证系统确实能够满足用户的需要。 【注意】验收测试发现的是系统需求说明书中的错误。
三、单元测试（模块 ） 单元测试主要使用白盒测试技术。 1．测试重点 （1）模块接口； （2）局部数据结构； （3）重要的执行通路； （4）出错处理通路； （5）边界条件。 2．测试方法 （1）代码审查； （2）计算机测试。 【注意】必须要为每个单元测试开发驱动软件和（或）存根软件。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/tmp/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/tmp/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1/</guid>
      <description>复习笔记
一、结构程序设计 详细设计不仅仅是逻辑上正确地实现每个模块的功能，更重要的是设计 出的处理过程应该尽可能简明易懂。结构程序设计技术是实现详细设计 目标的关键技术，也是详细设计的逻辑基础。 1．经典定义 如果一个程序的代码块仅仅通过顺序、选择和循环这3种基本控制结构 进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是 结构化的。 2．控制结构 （1）基本控制结构 三种基本的控制结构是“顺序”“选择”和“循环”，它们的流程图分别为图 6-1（a），6-1（b）和6-1（c）。图6-1 三种基本的控制结构 【注意】牢记三种基本控制结构，此为常考内容。 （2）扩展的控制结构 DO UNTIL和DO CASE的流程图分别是图6-2（a）和图6-2（b）。 图6-2 其他常用的控制结构
三、人机界面设计 1 重要性 （1）对于交互式系统来说，人机界面设计和数据设计、体系结构设计及 过程设计一样重要。 （2）人机界面的质量直接影响用户对软件产品的接受程度。 2 设计问题 （1）系统响应时间； （2）用户帮助设施； （3）出错信息处理； （4）命令交互。 3 设计过程 用户界面设计是一个迭代的过程，也就是说，通常先创建设计模型，再 用原型实现这个设计模型，并由用户试用和评估，然后根据用户意见进 行修改。
四、过程设计的工具 1 程序流程图（程序框图）（1）符号表示 程序流程图中使用的符号表示如图6-3所示。 图6-3 程序流程图中使用的符号 符号含义：（a）选择（分支）；（b）注释；（c）预先定义的处理； （d）多分支；（e）开始或停止；（f）准备； （g）循环上界限；（h）循环下界限；（i）虚线；（j）省略符；（k） 并行方式；（l）处理；（m）输入输出；（n）连接；（o）换页连接； （p）控制流。 （2）优点 对控制流程的描绘很直观，便于初学者掌握。 （3）缺点 ① 没遵循逐步求精的原则，它诱使程序员过早地考虑程序的控制流程， 而不去考虑程序的全局结构。② 程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以随 意转移控制。 ③ 程序流程图不易表示数据结构。 2 盒图（N-S图） （1）特点 ① 功能域明确； ② 不可能任意转移控制； ③ 很容易确定局部和全程数据的作用域； ④ 很容易表示嵌套关系，也可以表示模块的层次结构。 （2）表示 图6-4给出了结构化控制结构的盒图表示，也给出了调用子程序的盒图 表示方法。图6-4 盒图的基本符号 符号含义：（a）顺序结构；（b）IF_THEN_ELSE型分支；（c）CASE 型多分支；（d）循环结构；（e）调用子程序A。 （3）优点 ① 盒图没有箭头，因此不允许随意转移控制。 ② 盒图可以使程序员逐步养成用结构化的方式思考问题和解决问题的习 惯。 3 PAD图（问题分析图） （1）符号表示 PAD图用二维树形结构的图来表示程序的控制流，图6-5给出PAD图的 基本符号。图6-5 PAD图的基本符号 符号含义：（a）顺序（先执行P1后执行P2）；（b）选择（IF C THEN Pl ELSE P2）；（c）CASE型多分支；（d）WHILE型循环（WHILE C DO P）；（e）UNTIL型循环（REPEAT P UNTIL C）；（f）语句标 号；（g）定义。 （2）优点 ① 使用PAD符号所设计出来的程序必然是结构化程序。 ② PAD图所描绘的程序结构十分清晰。 ③ 用PAD图表现程序逻辑，易读、易懂、易记。 ④ 容易使用软件工具将PAD图自动转换成高级语言源程序，提高了软件可靠性和软件生产率。 ⑤ 即可用于表示程序逻辑，也可用于描绘数据结构。 ⑥ PAD图的符号支持自顶向下、逐步求精方法的使用。 【注意】PAD图中竖线的总条数就是程序的层次数。 4 判定表 （1）适用性 算法中包含多重嵌套的条件选择时使用判定表。 （2）组成 ① 左上部列出所有条件； ② 左下部是所有可能做的动作； ③ 右上部是表示各种条件组合的一个矩阵； ④ 右下部是和每种条件组合相对应的动作。 【注意】判定表右半部的每一列实质上是一条规则，规定了与特定的条 件组合相对应的动作。 5 过程设计语言 （1）定义过程设计语言（PDL），即伪码，它是用正文形式表示数据和处理过程 的设计工具。 （2）优点 ① 可作为注释直接插在源程序中，有助于保持文档和程序的一致性，提 高文档的质量。 ② 可以使用普通的正文编辑程序或文字处理系统，很方便地完成PDL的 书写和编辑工作。 ③ 已经有自动处理PDL的程序存在，且可以自动由PDL生成程序代码。 （3）缺点 不如图形工具形象直观，不如判定表清晰简单。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/tmp/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/tmp/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</guid>
      <description>复习笔记
一、软件危机 1 软件危机的介绍 （1）概念 软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。 （2）典型表现 ① 对软件开发成本和进度的估计不准确。 ② 用户对“已完成的”软件系统不满意的现象经常发生。 ③ 软件产品的质量往往靠不住。 ④ 软件常常是不可维护的。 ⑤ 软件通常没有适当的文档资料。 ⑥ 软件成本在计算机系统总成本中所占的比例逐年上升。 ⑦ 软件开发跟不上计算机应用迅速普及深入的趋势。 【注意】考试中常考查软件的概念，记住公式：软件＝程序＋数据＋文档。
2 产生软件危机的原因 （1）客观原因 ① 软件是计算机系统中的逻辑部件，缺乏“可见性”，因此管理和控制软 件开发过程相当困难。 ② 软件维护通常意味着改正或修改原来的设计，因此软件较难维护。 ③ 软件规模庞大，而程序复杂性将随着程序规模的增加而呈指数上升。 （2）主观原因 ① 存在与软件开发和维护有关的许多错误认识和做法。 ② 对用户要求没有完整准确的认识就匆忙着手编写程序。 ③ 开发人员只重视程序而忽视软件配置的其余成分（文档和数据等）。 ④ 软件开发人员轻视维护。
3 消除软件危机的途径 （1）应该对计算机软件有一个正确的认识。 （2）应该充分认识到软件开发是一种组织良好、管理严密、各类人员协 同配合、共同完成的工程项目。 （3）应该推广使用在实践中总结出来的开发软件的成功的技术和方法，并且研究探索更好更有效的技术和方法。 （4）应该开发和使用更好的软件工具。
二、软件工程 1 软件工程的介绍 （1）概念 采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考 验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来， 以经济地开发出高质量的软件并有效地维护它，这就是软件工程。 （2）本质特征 ① 软件工程关注于大型程序的构造； ② 软件工程的中心课题是控制复杂性； ③ 软件经常变化； ④ 开发软件的效率非常重要； ⑤ 和谐地合作是开发软件的关键； ⑥ 软件必须有效地支持它的用户； ⑦ 软件工程领域由具有一种文化背景的人替具有另一种文化背景的人创 造产品。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/tmp/%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/tmp/%E8%BD%AF%E4%BB%B6%E7%BB%B4%E6%8A%A4/</guid>
      <description>复习笔记
一、软件维护的定义 软件工程的主要目的就是要提高软件的可维护性，减少软件维护所需要 的工作量，降低软件系统的总成本。 1．定义 软件维护是在软件已经交付使用后，为了改正错误或满足新的需要而修 改软件的过程。 2．分类 （1）改正性维护； （2）适应性维护； （3）完善性维护； （4）预防性维护。
二、软件维护的特点 1 结构化维护与非结构化维护差别巨大2 维护的代价高昂 软件维护中无形的代价有： （1）软件维护的费用高昂。 （2）因为可用的资源必须供维护任务使用，以致耽误甚至丧失了开发的 良机。 （3）生产率的大幅度下降。 3 维护的问题 （1）理解别人写的程序非常困难，而且困难程度随着软件配置成分的减 少而迅速增加。 （2）需要维护的软件往往没有合格的文档，或者文档资料显著不足。 （3）当要求对软件进行维护时，不能指望由开发人员给人们仔细说明软 件。 （4）绝大多数软件在设计时没有考虑将来的修改。 （5）软件维护不是一项吸引人的工作。
三、软件维护过程 1 定义 维护过程本质上是修改和压缩了的软件定义和开发过程。2 具体过程 （1）维护组织； （2）维护报告； （3）维护的事件流； 图8-1 （4）保存维护记录； （5）评价维护活动。
四、软件的可维护性 维护阶段的事件流1 定义 可维护性指的是维护人员理解、改正、改动或改进这个软件的难易程 度。 2 决定软件可维护性的因素 （1）可理解性； （2）可测试性； （3）可修改性； （4）可移植性； （5）可重用性。 3 文档 （1）重要性 文档是影响软件可维护性的决定因素，文档比程序代码更重要。 （2）分类 软件系统的文档可以分为用户文档和系统文档两类。
五、预防性维护 定义 预防性维护指的是把今天的方法学应用到昨天的系统上，以支持明天的 需求。 2 实质 预防性维护实质上是软件再工程。
六、软件再工程过程 1 典型软件再工程模型 典型的软件再工程过程模型如图8-2所示。图8-2 软件再工程过程模型 【注意】在某些情况下这些活动以线性顺序发生，但也并非总是这样。 2 六类活动 （1）库存目录分析； （2）文档重构； （3）逆向工程； （4）代码重构； （5）数据重构； （6）正向工程。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/tmp/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/tmp/%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/</guid>
      <description>复习笔记
一、需求分析的任务 1 需求分析的定义 需求分析是发现、求精、建模、规格说明和复审的过程。 2 需求分析的必要性 为了开发出真正满足用户需求的成功的软件产品，必须知道用户的需 求。 3 需求分析的任务 （1）确定对系统的综合要求； （2）分析系统的数据要求； （3）导出系统的逻辑模型； （4）修正系统开发计划。4 对软件系统的综合需求 （1）功能需求 （2）性能需求 （3）可靠性和可用性需求 （4）出错处理需求 （5）接口需求 （6）约束 （7）逆向需求 （8）将来可能提出的要求 【注意】在描绘系统中的数据结构，使用层次方框图或Warnier图等图形 工具。
二、与用户沟通获取需求的方法 1 访谈 2 面向数据流自顶向下求精 3 简易的应用规格说明技术 4 快速建立软件原型
三、分析建模与规格说明 1 分析建模 （1）模型 模型由一组图形符号和组织这些符号的规则组成。 （2）建模过程 结构化分析实质上是一种创建模型的活动，应从不同的角度抽象目标系 统的特性。 2 软件需求规格说明 软件需求规格说明书是需求分析阶段得出的最主要的文档。
四、实体-联系图 1 数据模型的定义 概念性数据模型是一种面向问题的数据模型，是按照用户的观点对数据 建立的模型。 2 数据模型的构成 （1）数据对象① 定义 数据对象是对软件必须理解的复合信息的抽象。 ② 特点 a．可以由一组属性来定义的实体都可以被认为是数据对象。 b．数据对象彼此间是有关联的。 c．数据对象只封装了数据而没有对施加于数据上的操作的引用。 （2）属性 属性定义了数据对象的性质。 （3）联系 数据对象彼此之间相互连接的方式称为联系，也称为关系。联系也可能 有属性。联系可分为以下3种类型。 ① 一对一联系（1：1） ② 一对多联系（1：N） ③ 多对多联系（M：N） 3 实体-联系图（E-R图） （1）基本成分E-R图中包含了实体（数据对象）、关系和属性3种基本成分，通常用矩 形框代表实体，用连接相关实体的菱形框表示关系，用椭圆形或圆角矩 形表示实体（或关系）的属性，并用直线把实体（或关系）与其属性连 接起来。 （2）优点 ① E-R模型比较接近人的习惯思维方式； ② E-R模型使用简单的图形符号来描述问题，便于用户理解。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/untitled/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/untitled/</guid>
      <description>软件工程导论重点 - 焦政的博客
软件特点 1、软件是计算机系统中的逻辑部件而不是物理部件，其显著特点是缺乏可见性。因此管理和控制软件开发过程相当困难。此外，软件维护通常意味着改正或修正原有的设计，从而使得软件较难维护。 2、软件的另一个特点就是规模庞大，程序的复杂性将随着程序规模的增加以指数型速度上升。
软件危机定义 软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。
两方面问题 软件危机包含下述两方面的问题：如何开发软件，以满足对软件日益增长的需求；如何维护数量不断膨胀的已有软件。
产生原因 一方面与软件本身的特点有关，另一方面也和软件开发与维护的方法不正确有关。 客观：①软件不同于硬件，它是计算机系统中的逻辑部件而不是物理部件。由于软件缺乏 “可见性”，管理和控制软件开发过程相当困难。 ②软件的一个显著特点是规模庞大，而且程序复杂性将随着程序规模的增加而呈指数上升。 主观：计算机系统发展的早期阶段软件开发的个体化特点，忽视软件需求分析的重要性，认为软件开发就是写程序并设法使之运行，轻视软件维护，忽视评审，忽视测试等，引入一个变动要对所有已完成的配置成分都做相应的修改，不仅工作量大，而且逻辑上也更复杂，因此付出的代价剧增。
典型表现 （1）对软件开发成本和进度的估计常常很不准确。 （2）用户对 “已完成的” 软件系统不满意的现象经常发生。 （3）软件产品的质量往往靠不住。 （4）软件常常是不可维护的。 （5）软件通常没有适当的文档资料。 （6）软件成本在计算机系统总成本中所占的比例逐年上升。 （7）软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势。 ​
消除途径 1、应该树立对计算机软件的正确认识。认识到软件是程序、数据及文档的完整集合。（软件定义） 2、为了解决软件危机，既要有技术措施（方法和工具），又要有必要的组织管理措施。 3、充分认识软件开发是组织良好、管理严密、各类人员协同配合、共同完成的工程项目。（工程定义） 4、推广使用在实践中总结出来的开发软件的成功的技术和方法。 5、应该积极开发和使用计算机辅助软件工程（CASE）工具。
软件工程定义（背诵两种定义） 1、软件工程就是为了经济地获得可靠的且能在实际机器上有效地运行的软件，而建立和使用完善的工程原理。 2、软件工程是：①把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件；②研究①中提到的途径。”
本质特征（未考过，背） 软件工程关注于大型程序的构造 软件工程的中心课题是控制复杂性 软件经常变化 开发软件的效率非常重要 和谐地合作是开发软件的关键 软件必须有效地支持它的用户 在软件工程领域中通常由具有一种文化背景的人替具有另一种文化背景的人创造产品 基本原理 用分阶段的生命周期计划严格管理
坚持进行阶段评审
实行严格的产品控制
采用现代程序设计技术
结果应能清楚地审查
开发小组的人员应该少而精
承认不断改进软件工程实践的必要性
方法学三要素 (知道） 3 个要素：方法、工具和过程。(方济各)
方法是完成软件开发的各项任务的技术方法，回答 “怎样做” 的问题；
工具是为运用方法而提供的自动的或半自动的软件工程支撑环境；
过程是为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。
传统方法学（生命周期方法学，结构化范型）（各自特点，优缺点，背诵） 特点： 1、把软件生命周期的全过程依次划分为若干个阶段，然后顺序地完成每个阶段的任务。 2、每一个阶段的开始和结束都有严格标准，对于任何两个相邻的阶段而言，前一阶段的结束标准就是后一阶段的开始标准。 3、在每一个阶段结束之前都必须进行正式严格的技术审查和管理复审 4、审查的一条主要标准就是每个阶段都应该交出 “最新式的”（即和所开发的软件完全一致的）高质量的文档资料，从而保证在软件开发工程结束时有一个完整准确的软件配置交付使用。 优点： 降低了软件开发工程的困难程度，保证了软件质量，提高了软件的可维护性，大大提高了软件的开发成功率和生产率。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/%E5%A4%8D%E8%AF%95%E9%97%AE%E7%AD%94/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/%E5%A4%8D%E8%AF%95%E9%97%AE%E7%AD%94/</guid>
      <description>你为什么选择跨专业考研？
自我介绍
各位老师上午好，我是xxx，非常荣幸能够进入林科大软件工程的复试。我本科就读于中南林业科技大学的食品质量与安全专业，在林科大的四年里，优越的人文环境，浓厚的学习氛围时刻熏陶着我，专业成绩良好。 我选择跨考软件工程这一专业，最重要的原因就是热爱，对编程的兴趣起源于高中信息技术教材上的VB语言，从简单的打字测速程序到复杂的管理系统让我感受到了编程的强大力量。其次是因为一直以来我的理想就是成为一名程序员，我在高考后de暑假自学了C语言，本科期间自学了python和数据结构。 不忘初心，方得始终，希望有机会能够继续跟随学校优秀的老师们学习软件工程相关知识，相信凭借自己的勤奋和踏实，能在计算机领域提升自己的专业素养和实践能力，谢谢老师，我的自我介绍完毕。 Hello teachers, good morning. I am xxx, and it is my great honor to have the opportunity to participate in the software engineering interview at Central South University of Forestry and Technology. I majored in Food Quality and Safety at Central South University of Forestry and Technology for my undergraduate studies. During my four years at Central South University of Forestry and Technology, I have been influenced by the excellent humanistic environment and strong academic atmosphere, and my academic performance was outstanding.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>单向链表 //插入节点 newNode-&amp;gt;next = curNode-&amp;gt;next; curNode-&amp;gt;next = newNode; //删除节点 preNode-&amp;gt;next = curNode-&amp;gt;next; free(curNode); 树 树相关定义 根节点：没有父节点 非根节点：只有一个父节点 节点的度：子树的数目 d叶子：度为零的节点</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/%E6%A0%B8%E5%BF%83%E7%BA%B2%E8%A6%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/%E6%A0%B8%E5%BF%83%E7%BA%B2%E8%A6%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</guid>
      <description>mo x本文由 简悦 SimpRead 转码， 原文地址 marlous.github.io
Mo&amp;rsquo;s Blog at GitHub
参考：
1、 《软件工程导论》张海潘版
2、 软件工程——思维导图
3、 软件工程导论张海潘 (第六版) 第 1-13 章总结
4、 软件工程的基本概念
5、 软件工程期末考试重点
6、 软件工程考试重点内容
7、 软件工程期末考试复习题及答案
软件工程 来源见水印。
1 工具 参考博文 《DevOps 与 CI/CD 的概念》。
项目管理： 任务跟踪：禅道、Trello、Teambition 等。 项目计划：禅道、Trello、Teambition 等。 团队沟通：Slack、Teambition 等。 需求分析： 需求跟踪：禅道、Teambition、Trello 等。 原型制作：Adobe XD CC、Axure、Sketch 等，参考：16 种原型制作工具及使用介绍。 设计： UML 建模：Violet UM、ProcessOn、StarUML、Visio 等。（类图、对象图；用例图、状态图、活动图、序列图。参考：UML 各种图总结精华、各种图含义作用 ） 图表制作：Excel、亿图等。 开发： 源代码管理：GitHub、GitLab、SubVersion 等（Git、SVN）。 持续集成：Jenkins、CireleCI、AppCenter、Travis CI、flow.ci 等。 测试： Bug 跟踪：禅道、Teambition、Trello、The Bug Genie 等。 测试管理平台：TestLink、Redmine、禅道、TestCenter 等。 自动化测试：常用的：QPT、LR。/ 开源功能自动化测试工具：Watir、Selenium、MaxQ、WebInject。/ 开源性能自动化测试工具：Jmeter、OpenSTA、DBMonster、TPTEST、Web Application Load Simulator。 补充，自动化构建和测试: Apache Ant、Maven 、Selenium、PyUnit、QUnit、JMeter、Gradle、PHPUnit。 运行维护： 自动化部署：Jenkins、ElectricFlow、DeployBot、CireleCI、AppCenter、Travis CI 等。 日志分析：Logstash、CollectD、StatsD 等。 线上监控：Nagios、Ganglia、Sensu、zabbix、ICINGA、Graphite、Kibana 等。 2 软件工程文档 需要文档的几个方面： 立项文档 需求分析文档 概要设计和架构设计 详细设计 源代码 配置文档 单元测试文档 集成测试文档 验收文档 维护文档 用户操作手册 项目管理文档 具体文档： 项目管理文档：</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</guid>
      <description>神经元 一个神经元的功能是求得输入向量与权向量的内积后加偏置，经一个非线性传递函数得到一个标量结果。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8E%9F%E6%9D%A5%E8%BF%99%E5%B0%B1%E6%98%AF%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%8E%9F%E6%9D%A5%E8%BF%99%E5%B0%B1%E6%98%AF%E7%BD%91%E7%BB%9C/</guid>
      <description>原文：https://www.cnblogs.com/flashsun/p/14266148.html
家庭网络 分组交换 分组交换：在通信过程中，通信双方以分组为单位、使用存储-转发机制实现数据交互的通信方式
分组：由一块用户数据和必要的地址和管理信息组成，保证网络能够将数据传递到目标。类似于从邮局发送的包裹上注明的地址一样,只有提供给网络这些信息，网络（邮局）才能把分组（包裹）往正确的地址传送</description>
    </item>
    
    <item>
      <title></title>
      <link>https://zcy2875634712.github.io/posts/note/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/note/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/</guid>
      <description>软件危机 定义：软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题 原因： （1）客观原因 ① 软件是计算机系统中的逻辑部件，缺乏“可见性”，因此管理和控制软 件开发过程相当困难 ② 软件维护通常意味着改正或修改原来的设计，因此软件较难维护 ③ 软件规模庞大，而程序复杂性将随着程序规模的增加而呈指数上升 （2）主观原因 ① 存在与软件开发和维护有关的许多错误认识和做法 ② 对用户要求没有完整准确的认识就匆忙着手编写程序 ③ 开发人员只重视程序而忽视软件配置的其余成分（文档和数据等） ④ 软件开发人员轻视维护 软件工程 采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考 验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来， 以经济地开发出高质量的软件并有效地维护它
软件工程七条基本原理 1.用分阶段的生命周期计划严格管理 2.坚持进行阶段评审 3.实行严格的产品控制 4.采用现代程序设计技术 5.结果应能清楚地审查 6.开发小组的人员应该少而精 7.承认不断改进软件工程实践的必要性 软件工程方法学 技术方法的集合称为方法学（范型）。分为传统方法学和面向对象方法学 软件工程方法学包括3个要素：方法、工具和过程 传统方法学（生命周期方法学或结构化范型） 优点 把软件生命周期划分成若干相对独立、简单的阶段，便于不同人员分工协作，降低开发的困难程度 开发过程中采用科学的管理技术和良好的技术方法，且在每个阶段结束之前都进行严格的审查，保证了软件的质量，提高了软件的可维护性 大大提高了软件开发的成功率和生产率 缺点 不适用于软件规模庞大、或者对软件的需求是模糊的或会随时间变化而变化的情况 结构化范型技术把数据和操作人为地分离成两个独立的部分，增加了软件开发与维护的难度
面向对象方法学 与传统方法学的对比 a．传统方法学强调自顶向下、逐层分解、顺序开发 b．面向对象方法学强调主动地多次反复迭代地开发，保证了在各项开发活动之间的平滑过渡 优点 a．降低了软件产品的复杂性 b．提高了软件的可理解性 c．简化了软件的开发和维护工作 d．提高了软件的可重用性
软件过程 定义：获得高质量软件所需要完成的一系列任务的框架 表示：生命周期模型 瀑布模型的特点: 1.阶段间具有顺序性和依赖性。 2.推迟实 现的观点。3.质量保证的观点。 快速原型 是快速建立起来的可以在计算机上运行的程序，它 所能完成的功能往往是最终产品能完成功能的一个子集。 增量模型: 它分批地逐步向用户提交产品，整个软件产品被分 解成许多个增量构件，开发人员一个构件一个构件地向用户 提交产品。 螺旋模型; 基本思想是使用原型及其他方法来尽量降低风险。 理解这种模型的一个简单方法，是把它看作在每个阶段之前 都增加了风险分析过程的快速原型模型。 (使用于内部开发 的大规模软件项目 ) 喷泉模型: 强调的是“迭代”和“无缝“的特性 是典型的面 向对象的软件过程模型之一.</description>
    </item>
    
    <item>
      <title>python速查</title>
      <link>https://zcy2875634712.github.io/posts/%E9%80%9F%E6%9F%A5/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://zcy2875634712.github.io/posts/%E9%80%9F%E6%9F%A5/</guid>
      <description>字符串 运算 a=&amp;#39;hello,&amp;#39; b=&amp;#39;world&amp;#39; print(a + b) print(&amp;#39;#&amp;#39;*5)	#输出&amp;#39;#####&amp;#39; 输出 a = &amp;#39;hello&amp;#39; b = &amp;#39;world&amp;#39; # hello,world print(f&amp;#39;{a},{b}&amp;#39;)	print(&amp;#39;{},{}&amp;#39;.format(a, b)) print(&amp;#39;%s,%s&amp;#39; % (a, b)) 列表（list） # 创建列表 li1 = [] li2 = [1, 2, 3] li3 = list((1, 2, 3))	#元组转换为列表 li4 = list(range(1, 4)) li5 = [x for x in range(1, 4)] # 更新列表元素 li = [1, 2] li.append(3) li.insert(2, 4)	#[1, 2, 4, 3], 下标为2插入4 # 删除列表元素 del listname[index] del listname[start : end]	#包括start，不包括end listname.</description>
    </item>
    
  </channel>
</rss>
