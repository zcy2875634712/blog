<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>软件工程导论 | ybyb</title><meta name=keywords content><meta name=description content="软件危机 定义：软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题 原因： 客观原因 软件是计算机系统中的逻辑部件，缺乏“可见性”，因此管理和控制软 件开发过程相当困难 软件维护通常意味着改正或修改原来的设计，因此软件较难维护 软件规模庞大，而程序复杂性将随着程序规模的增加而呈指数上升 主观原因 存在与软件开发和维护有关的许多错误认识和做法 对用户要求没有完整准确的认识就匆忙着手编写程序 开发人员只重视程序而忽视软件配置的其余成分（文档和数据等） 软件开发人员轻视维护 软件工程 采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考 验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来， 以经济地开发出高质量的软件并有效地维护它
软件工程七条基本原理 1.用分阶段的生命周期计划严格管理 2.坚持进行阶段评审 3.实行严格的产品控制 4.采用现代程序设计技术 5.结果应能清楚地审查 6.开发小组的人员应该少而精 7.承认不断改进软件工程实践的必要性 软件工程方法学 技术方法的集合称为方法学（范型）。分为传统方法学和面向对象方法学 软件工程方法学包括3个要素：方法、工具和过程 传统方法学（生命周期方法学或结构化范型） 优点 把软件生命周期划分成若干相对独立、简单的阶段，便于不同人员分工协作，降低开发的困难程度 开发过程中采用科学的管理技术和良好的技术方法，且在每个阶段结束之前都进行严格的审查，保证了软件的质量，提高了软件的可维护性 大大提高了软件开发的成功率和生产率 缺点 不适用于软件规模庞大、或者对软件的需求是模糊的或会随时间变化而变化的情况 结构化范型技术把数据和操作人为地分离成两个独立的部分，增加了软件开发与维护的难度
面向对象方法学 与传统方法学的对比 a．传统方法学强调自顶向下、逐层分解、顺序开发 b．面向对象方法学强调主动地多次反复迭代地开发，保证了在各项开发活动之间的平滑过渡 优点 a．降低了软件产品的复杂性 b．提高了软件的可理解性 c．简化了软件的开发和维护工作 d．提高了软件的可重用性
软件过程 定义：获得高质量软件所需要完成的一系列任务的框架 表示：生命周期模型 瀑布模型的特点: 1.阶段间具有顺序性和依赖性。 2.推迟实 现的观点。3.质量保证的观点。 快速原型 是快速建立起来的可以在计算机上运行的程序，它 所能完成的功能往往是最终产品能完成功能的一个子集。 增量模型: 它分批地逐步向用户提交产品，整个软件产品被分 解成许多个增量构件，开发人员一个构件一个构件地向用户 提交产品。 螺旋模型; 基本思想是使用原型及其他方法来尽量降低风险。 理解这种模型的一个简单方法，是把它看作在每个阶段之前 都增加了风险分析过程的快速原型模型。 (使用于内部开发 的大规模软件项目 ) 喷泉模型: 强调的是“迭代”和“无缝“的特性 是典型的面 向对象的软件过程模型之一."><meta name=author content="Me"><link rel=canonical href=https://zcy2875634712.github.io/posts/note/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zcy2875634712.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://zcy2875634712.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://zcy2875634712.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://zcy2875634712.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://zcy2875634712.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="软件工程导论"><meta property="og:description" content="软件危机 定义：软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题 原因： 客观原因 软件是计算机系统中的逻辑部件，缺乏“可见性”，因此管理和控制软 件开发过程相当困难 软件维护通常意味着改正或修改原来的设计，因此软件较难维护 软件规模庞大，而程序复杂性将随着程序规模的增加而呈指数上升 主观原因 存在与软件开发和维护有关的许多错误认识和做法 对用户要求没有完整准确的认识就匆忙着手编写程序 开发人员只重视程序而忽视软件配置的其余成分（文档和数据等） 软件开发人员轻视维护 软件工程 采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考 验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来， 以经济地开发出高质量的软件并有效地维护它
软件工程七条基本原理 1.用分阶段的生命周期计划严格管理 2.坚持进行阶段评审 3.实行严格的产品控制 4.采用现代程序设计技术 5.结果应能清楚地审查 6.开发小组的人员应该少而精 7.承认不断改进软件工程实践的必要性 软件工程方法学 技术方法的集合称为方法学（范型）。分为传统方法学和面向对象方法学 软件工程方法学包括3个要素：方法、工具和过程 传统方法学（生命周期方法学或结构化范型） 优点 把软件生命周期划分成若干相对独立、简单的阶段，便于不同人员分工协作，降低开发的困难程度 开发过程中采用科学的管理技术和良好的技术方法，且在每个阶段结束之前都进行严格的审查，保证了软件的质量，提高了软件的可维护性 大大提高了软件开发的成功率和生产率 缺点 不适用于软件规模庞大、或者对软件的需求是模糊的或会随时间变化而变化的情况 结构化范型技术把数据和操作人为地分离成两个独立的部分，增加了软件开发与维护的难度
面向对象方法学 与传统方法学的对比 a．传统方法学强调自顶向下、逐层分解、顺序开发 b．面向对象方法学强调主动地多次反复迭代地开发，保证了在各项开发活动之间的平滑过渡 优点 a．降低了软件产品的复杂性 b．提高了软件的可理解性 c．简化了软件的开发和维护工作 d．提高了软件的可重用性
软件过程 定义：获得高质量软件所需要完成的一系列任务的框架 表示：生命周期模型 瀑布模型的特点: 1.阶段间具有顺序性和依赖性。 2.推迟实 现的观点。3.质量保证的观点。 快速原型 是快速建立起来的可以在计算机上运行的程序，它 所能完成的功能往往是最终产品能完成功能的一个子集。 增量模型: 它分批地逐步向用户提交产品，整个软件产品被分 解成许多个增量构件，开发人员一个构件一个构件地向用户 提交产品。 螺旋模型; 基本思想是使用原型及其他方法来尽量降低风险。 理解这种模型的一个简单方法，是把它看作在每个阶段之前 都增加了风险分析过程的快速原型模型。 (使用于内部开发 的大规模软件项目 ) 喷泉模型: 强调的是“迭代”和“无缝“的特性 是典型的面 向对象的软件过程模型之一."><meta property="og:type" content="article"><meta property="og:url" content="https://zcy2875634712.github.io/posts/note/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"><meta property="og:image" content="https://zcy2875634712.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="og:site_name" content="ybyb"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zcy2875634712.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="软件工程导论"><meta name=twitter:description content="软件危机 定义：软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题 原因： 客观原因 软件是计算机系统中的逻辑部件，缺乏“可见性”，因此管理和控制软 件开发过程相当困难 软件维护通常意味着改正或修改原来的设计，因此软件较难维护 软件规模庞大，而程序复杂性将随着程序规模的增加而呈指数上升 主观原因 存在与软件开发和维护有关的许多错误认识和做法 对用户要求没有完整准确的认识就匆忙着手编写程序 开发人员只重视程序而忽视软件配置的其余成分（文档和数据等） 软件开发人员轻视维护 软件工程 采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考 验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来， 以经济地开发出高质量的软件并有效地维护它
软件工程七条基本原理 1.用分阶段的生命周期计划严格管理 2.坚持进行阶段评审 3.实行严格的产品控制 4.采用现代程序设计技术 5.结果应能清楚地审查 6.开发小组的人员应该少而精 7.承认不断改进软件工程实践的必要性 软件工程方法学 技术方法的集合称为方法学（范型）。分为传统方法学和面向对象方法学 软件工程方法学包括3个要素：方法、工具和过程 传统方法学（生命周期方法学或结构化范型） 优点 把软件生命周期划分成若干相对独立、简单的阶段，便于不同人员分工协作，降低开发的困难程度 开发过程中采用科学的管理技术和良好的技术方法，且在每个阶段结束之前都进行严格的审查，保证了软件的质量，提高了软件的可维护性 大大提高了软件开发的成功率和生产率 缺点 不适用于软件规模庞大、或者对软件的需求是模糊的或会随时间变化而变化的情况 结构化范型技术把数据和操作人为地分离成两个独立的部分，增加了软件开发与维护的难度
面向对象方法学 与传统方法学的对比 a．传统方法学强调自顶向下、逐层分解、顺序开发 b．面向对象方法学强调主动地多次反复迭代地开发，保证了在各项开发活动之间的平滑过渡 优点 a．降低了软件产品的复杂性 b．提高了软件的可理解性 c．简化了软件的开发和维护工作 d．提高了软件的可重用性
软件过程 定义：获得高质量软件所需要完成的一系列任务的框架 表示：生命周期模型 瀑布模型的特点: 1.阶段间具有顺序性和依赖性。 2.推迟实 现的观点。3.质量保证的观点。 快速原型 是快速建立起来的可以在计算机上运行的程序，它 所能完成的功能往往是最终产品能完成功能的一个子集。 增量模型: 它分批地逐步向用户提交产品，整个软件产品被分 解成许多个增量构件，开发人员一个构件一个构件地向用户 提交产品。 螺旋模型; 基本思想是使用原型及其他方法来尽量降低风险。 理解这种模型的一个简单方法，是把它看作在每个阶段之前 都增加了风险分析过程的快速原型模型。 (使用于内部开发 的大规模软件项目 ) 喷泉模型: 强调的是“迭代”和“无缝“的特性 是典型的面 向对象的软件过程模型之一."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zcy2875634712.github.io/posts/"},{"@type":"ListItem","position":2,"name":"软件工程导论","item":"https://zcy2875634712.github.io/posts/note/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"软件工程导论","name":"软件工程导论","description":"软件危机 定义：软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题 原因： 客观原因 软件是计算机系统中的逻辑部件，缺乏“可见性”，因此管理和控制软 件开发过程相当困难 软件维护通常意味着改正或修改原来的设计，因此软件较难维护 软件规模庞大，而程序复杂性将随着程序规模的增加而呈指数上升 主观原因 存在与软件开发和维护有关的许多错误认识和做法 对用户要求没有完整准确的认识就匆忙着手编写程序 开发人员只重视程序而忽视软件配置的其余成分（文档和数据等） 软件开发人员轻视维护 软件工程 采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考 验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来， 以经济地开发出高质量的软件并有效地维护它\n软件工程七条基本原理 1.用分阶段的生命周期计划严格管理 2.坚持进行阶段评审 3.实行严格的产品控制 4.采用现代程序设计技术 5.结果应能清楚地审查 6.开发小组的人员应该少而精 7.承认不断改进软件工程实践的必要性 软件工程方法学 技术方法的集合称为方法学（范型）。分为传统方法学和面向对象方法学 软件工程方法学包括3个要素：方法、工具和过程 传统方法学（生命周期方法学或结构化范型） 优点 把软件生命周期划分成若干相对独立、简单的阶段，便于不同人员分工协作，降低开发的困难程度 开发过程中采用科学的管理技术和良好的技术方法，且在每个阶段结束之前都进行严格的审查，保证了软件的质量，提高了软件的可维护性 大大提高了软件开发的成功率和生产率 缺点 不适用于软件规模庞大、或者对软件的需求是模糊的或会随时间变化而变化的情况 结构化范型技术把数据和操作人为地分离成两个独立的部分，增加了软件开发与维护的难度\n面向对象方法学 与传统方法学的对比 a．传统方法学强调自顶向下、逐层分解、顺序开发 b．面向对象方法学强调主动地多次反复迭代地开发，保证了在各项开发活动之间的平滑过渡 优点 a．降低了软件产品的复杂性 b．提高了软件的可理解性 c．简化了软件的开发和维护工作 d．提高了软件的可重用性\n软件过程 定义：获得高质量软件所需要完成的一系列任务的框架 表示：生命周期模型 瀑布模型的特点: 1.阶段间具有顺序性和依赖性。 2.推迟实 现的观点。3.质量保证的观点。 快速原型 是快速建立起来的可以在计算机上运行的程序，它 所能完成的功能往往是最终产品能完成功能的一个子集。 增量模型: 它分批地逐步向用户提交产品，整个软件产品被分 解成许多个增量构件，开发人员一个构件一个构件地向用户 提交产品。 螺旋模型; 基本思想是使用原型及其他方法来尽量降低风险。 理解这种模型的一个简单方法，是把它看作在每个阶段之前 都增加了风险分析过程的快速原型模型。 (使用于内部开发 的大规模软件项目 ) 喷泉模型: 强调的是“迭代”和“无缝“的特性 是典型的面 向对象的软件过程模型之一.","keywords":[],"articleBody":" 软件危机 定义：软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题 原因： 客观原因 软件是计算机系统中的逻辑部件，缺乏“可见性”，因此管理和控制软 件开发过程相当困难 软件维护通常意味着改正或修改原来的设计，因此软件较难维护 软件规模庞大，而程序复杂性将随着程序规模的增加而呈指数上升 主观原因 存在与软件开发和维护有关的许多错误认识和做法 对用户要求没有完整准确的认识就匆忙着手编写程序 开发人员只重视程序而忽视软件配置的其余成分（文档和数据等） 软件开发人员轻视维护 软件工程 采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考 验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来， 以经济地开发出高质量的软件并有效地维护它\n软件工程七条基本原理 1.用分阶段的生命周期计划严格管理 2.坚持进行阶段评审 3.实行严格的产品控制 4.采用现代程序设计技术 5.结果应能清楚地审查 6.开发小组的人员应该少而精 7.承认不断改进软件工程实践的必要性 软件工程方法学 技术方法的集合称为方法学（范型）。分为传统方法学和面向对象方法学 软件工程方法学包括3个要素：方法、工具和过程 传统方法学（生命周期方法学或结构化范型） 优点 把软件生命周期划分成若干相对独立、简单的阶段，便于不同人员分工协作，降低开发的困难程度 开发过程中采用科学的管理技术和良好的技术方法，且在每个阶段结束之前都进行严格的审查，保证了软件的质量，提高了软件的可维护性 大大提高了软件开发的成功率和生产率 缺点 不适用于软件规模庞大、或者对软件的需求是模糊的或会随时间变化而变化的情况 结构化范型技术把数据和操作人为地分离成两个独立的部分，增加了软件开发与维护的难度\n面向对象方法学 与传统方法学的对比 a．传统方法学强调自顶向下、逐层分解、顺序开发 b．面向对象方法学强调主动地多次反复迭代地开发，保证了在各项开发活动之间的平滑过渡 优点 a．降低了软件产品的复杂性 b．提高了软件的可理解性 c．简化了软件的开发和维护工作 d．提高了软件的可重用性\n软件过程 定义：获得高质量软件所需要完成的一系列任务的框架 表示：生命周期模型 瀑布模型的特点: 1.阶段间具有顺序性和依赖性。 2.推迟实 现的观点。3.质量保证的观点。 快速原型 是快速建立起来的可以在计算机上运行的程序，它 所能完成的功能往往是最终产品能完成功能的一个子集。 增量模型: 它分批地逐步向用户提交产品，整个软件产品被分 解成许多个增量构件，开发人员一个构件一个构件地向用户 提交产品。 螺旋模型; 基本思想是使用原型及其他方法来尽量降低风险。 理解这种模型的一个简单方法，是把它看作在每个阶段之前 都增加了风险分析过程的快速原型模型。 (使用于内部开发 的大规模软件项目 ) 喷泉模型: 强调的是“迭代”和“无缝“的特性 是典型的面 向对象的软件过程模型之一. 软件周期 1.问题定义: 必须回答的关键问题是， “要解决的问题是什么? ”。 2.可行性研究: 阶段回答的关键问题是: “对于上一个阶段所确定的问题有行得通的解决办法吗? ” 3.需求分析: “目标系统必须做什么”，确定目标系统必须具备哪些功能。 4.总体设计: 必须回答的关键问题是: “概括地说，应该怎样实现目标系统? ”总体设计又称为概要设计。 5.详细设计: 关键问题是: “应该怎样具体地实现这个系统呢? ” 6.编码和单元测试: 关键任务是写出正确的容易理解、容易维护的程序模块。 7.综合测试: 关键任务是通过各种类型的测试使软件达到预定的要求。 8.软件维护: 通过各种必要的维护活动使系统持久地满足用户的需要。 可行性研究 可行性研究的任务 可行性研究方面 1.技术可行性 2.经济可行性 3.操作可行性 可行性研究过程 1.复查系统规模和目标； 2.研究目前正在使用的系统； 3.导出新系统的高层逻辑模型； 4.进一步定义问题； 5.导出并评价供选择的解法； 6.推荐行动方针； 7.草拟开发计划； 8书写文档提交审查。 系统流程图 描绘物理系统，表达的是数据在系统各部件之间流动的情况 数据流图 描绘数据在软件中流动和被处理的逻辑过程，表示系统逻辑模型，是功能模型 矩形：数据的源点/终点 圆角：数据处理 开口：数据存储 箭头：数据流 数据字典 标识符 = 字母字符 + 字母数字串 字母数字串 = 0{字母或数字}7 字母或数字 = [字母字符 | 数字字符] 成本/效益分析 目的：帮助客户组织负责人从经济角度判断是否继续投资于这项工程。 方法： 代码行技术； 任务分解技术 自动估计成本技术 需求分析 任务： 确认对系统的综合要求 分析系统的数据要求 导出系统的逻辑模型 修正系统开发计划 需求分析中的三种模型： 数据模型（E-R 图） 功能模型（数据流图） 行为模型（状态转换图） 规格说明 实体-联系图 包括实体（数据对象）、关系和属性3种基本成分 矩形-\u003e实体 菱形-\u003e关系 圆角-\u003e属性 状态转换图 初态-\u003e实心圆 终态-\u003e空心包实心圆 中间-\u003e圆角 其他图形工具 1.层次方框图（数据层次结构） 2.Warnier图 3.IPO图 总体设计 设计原理 模块化 模块独立（低耦合与高内聚） 抽象 逐步求精 信息隐藏和局部化 启发原则 改进软件结构提高模块独立性 模块规模应该适中 深度、宽度、扇出和扇入都应适当 模块的作用域应该在控制域之内 力争降低模块接口的复杂程度 设计单入口单出口的模块 模块功能应该可以预测 描绘软件结构的图形工具 1.层次图 2.HIPO图 3.结构图 面向数据流的设计方法 1.变换流 2.事务流 详细设计 结构程序设计 结构化程序：仅顺序、选择和循环，且单入单出的程序 人机界面设计 过程设计 1.程序流程图（程序框图） 2.盒图（N-S图） 3.PAD图（问题分析图） 4.判定表 5.判断树 6.过程设计语言（PDL，伪码） PAD图\n面向数据结构的设计方法 程序复杂程度的定量度量价值 环形复杂度（McCabe方法）： V(G)=区域数 V(G)=E-N+2（E:edge N:node） V(G)=P+1（P是判断节点数） 实现（编码、单元测试、综合测试） 测试 软件测试的定义 测试是为了发现程序中的错误而执行程序的过程。 软件测试的目标 好的测试方案是尽可能发现迄今为止尚未发现的错误的测试方案 成功的测试是发现了至今为止尚未发现的错误的测试 根本目标是尽可能多地发现并排除软件中潜藏的错误，最终把一个高质量的软件系统交给用户使用 测试方法：白盒测试和黑盒测试 测试步骤： 单元测试（模块测试）：测试模块，发现编码和详细设计的错误 子系统测试：测试模块接口 系统测试：发现软件设计中和需求说明中的错误 验收测试（确认测试）：发现系统需求说明书中的错误 白盒测试 1.语句覆盖：一个if要一个测试用例 2.判断覆盖：一个if要两个测试用例 3.条件覆盖：每个条件取值至少出现一次 4.判断/条件覆盖： 5.条件组合覆盖：每个判定表达式中条件的各种可能组合都至少出现一次. 6.路径覆盖：所有节点路径数的乘积 黑盒测试 1.等价划分 2.边界值分析 3.错误推测 集成测试 底驱顶根：自顶向下需要存根程序，自底向上需要驱动程序 确认测试 Alpha测试：开发者场所，受控 Beta测试：客户场所，不受控 面向对象 面向对象建模\n对象模型： 动态模型： 功能模型： 在UML图中： 对象模型：类图 动态模型：状态图和事件追踪图 功能模型：用例图 类图\n泛化（继承）：空心三角和实线 聚合：空心菱形 组合：实心菱形 设计准则 模块化 抽象 信息隐蔽 弱耦合 强内聚 可重用 软件重用 重用也称为再用或复用，是指同一事物不经修改或稍加改动就多次重复使用 重用级别： 代码重用 设计结果重用 分析结果重用 类构件的重用方式： 实例重用 继承重用 多态重用 设计优化 确认优先级 提高效率的几项技术 增加冗余关联以提高访问效率 调整查询次序 保留派生属性 调整继承关系 设计类继承的方法 为提高继承程度而修改类定义 利用委托实现操作共享 程序设计风格 1.提高可重用性 （1）提高方法的内聚 （2）减小方法的规模 （3）保持方法的一致性 （4）把策略与实现分开 （5）全面覆盖输入条件的各种可能组合 （6）尽量不使用全局信息 （7）充分利用继承机制 2.提高可扩充性 提高可重用性的准则同样也能提高程序的可扩充性 （1）封装类的实现细节 （2）不要用一个方法遍历多条关联链。 （3）避免使用多分支语句 （4）精心选择和定义公有方法 3.提高健壮性 （1）预防用户的错误操作 （2）检查参数的合法性 （3）不要预先设定数据结构的限制条件 （4）先测试后优化 设计测试用例 测试类 随机测试 划分测试 基于故障测试 集成测试 多类测试：随机测试和划分测试 从动态模型导出测试用例 软件项目管理 软件项目管理就是通过计划、组织和控制等一系列活动，合理地配置 和使用各种资源，以达到既定目标的过程。\n计划：估计软件规模，工作量估算，进度计划 组织：民主制程序员组，主程序员组，现代程序员组 控制：质量保证，配置管理\n大纲 一、软件工程概述 软件生命周期、软件过程 二、需求分析 需求分析的任务、建模和规格说明、UML（类图、状态 图、顺序图、活动图) 三、总体设计 设计原理、启发规则、面向数据流的设计方法、 四、详细设计和实现 过程设计工具、面向数据结构的设计方法、程序复杂度的度量、编码、软件测试基础、单元测试、集成测试、白盒测试、黑盒测试 五、面向对象分析、設計和实现 面向对象分析过程、对象模型、动态模型、功能模型 面向对象设计准则、软件重用、设计优化、程序设计风格、设计测试用例 六、软件项目管理 工作量估算、进度计划、质量保证、软件配置 ","wordCount":"323","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zcy2875634712.github.io/posts/note/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA/"},"publisher":{"@type":"Organization","name":"ybyb","logo":{"@type":"ImageObject","url":"https://zcy2875634712.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zcy2875634712.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://zcy2875634712.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zcy2875634712.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://zcy2875634712.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://github.com/zcy2875634712 title=github><span>github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zcy2875634712.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zcy2875634712.github.io/posts/>Posts</a></div><h1 class=post-title>软件工程导论</h1><div class=post-meta>2 min&nbsp;·&nbsp;323 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/note/%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#软件危机>软件危机</a></li><li><a href=#软件工程>软件工程</a></li><li><a href=#传统方法学生命周期方法学或结构化范型>传统方法学（生命周期方法学或结构化范型）</a></li><li><a href=#面向对象方法学>面向对象方法学</a></li><li><a href=#软件过程>软件过程</a></li><li><a href=#软件周期>软件周期</a></li></ul></li><li><a href=#可行性研究>可行性研究</a><ul><li><a href=#可行性研究的任务>可行性研究的任务</a></li><li><a href=#系统流程图>系统流程图</a></li><li><a href=#数据流图>数据流图</a></li><li><a href=#数据字典>数据字典</a></li><li><a href=#成本效益分析>成本/效益分析</a></li></ul></li><li><a href=#需求分析>需求分析</a><ul><li><a href=#实体-联系图>实体-联系图</a></li><li><a href=#状态转换图>状态转换图</a></li><li><a href=#其他图形工具>其他图形工具</a></li></ul></li><li><a href=#总体设计>总体设计</a><ul><li><a href=#设计原理>设计原理</a></li><li><a href=#启发原则>启发原则</a></li><li><a href=#描绘软件结构的图形工具>描绘软件结构的图形工具</a></li><li><a href=#面向数据流的设计方法>面向数据流的设计方法</a></li></ul></li><li><a href=#详细设计>详细设计</a><ul><li><a href=#结构程序设计>结构程序设计</a></li><li><a href=#人机界面设计>人机界面设计</a></li><li><a href=#过程设计>过程设计</a></li><li><a href=#面向数据结构的设计方法>面向数据结构的设计方法</a></li><li><a href=#程序复杂程度的定量度量价值>程序复杂程度的定量度量价值</a></li></ul></li><li><a href=#实现编码单元测试综合测试>实现（编码、单元测试、综合测试）</a><ul><li><a href=#测试>测试</a></li><li><a href=#白盒测试>白盒测试</a></li><li><a href=#黑盒测试>黑盒测试</a></li><li><a href=#集成测试>集成测试</a></li><li><a href=#确认测试>确认测试</a></li></ul></li><li><a href=#面向对象>面向对象</a><ul><li><a href=#设计准则>设计准则</a></li><li><a href=#软件重用>软件重用</a></li><li><a href=#设计优化>设计优化</a></li><li><a href=#程序设计风格>程序设计风格</a></li><li><a href=#设计测试用例>设计测试用例</a></li></ul></li><li><a href=#软件项目管理>软件项目管理</a></li><li><a href=#大纲>大纲</a></li></ul></nav></div></details></div><div class=post-content><hr><h3 id=软件危机>软件危机<a hidden class=anchor aria-hidden=true href=#软件危机>#</a></h3><pre tabindex=0><code>定义：软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题
原因：
客观原因
    软件是计算机系统中的逻辑部件，缺乏“可见性”，因此管理和控制软
    件开发过程相当困难
    软件维护通常意味着改正或修改原来的设计，因此软件较难维护
    软件规模庞大，而程序复杂性将随着程序规模的增加而呈指数上升
主观原因
    存在与软件开发和维护有关的许多错误认识和做法
    对用户要求没有完整准确的认识就匆忙着手编写程序
    开发人员只重视程序而忽视软件配置的其余成分（文档和数据等）
    软件开发人员轻视维护
</code></pre><h3 id=软件工程>软件工程<a hidden class=anchor aria-hidden=true href=#软件工程>#</a></h3><p>采用<strong>工程</strong>的概念、原理、技术和方法来开发与维护软件，把经过时间考
验而证明正确的<strong>管理技术</strong>和当前能够得到的最好的<strong>技术方法</strong>结合起来，
以经济地开发出高质量的软件并有效地维护它</p><pre tabindex=0><code>
软件工程七条基本原理
    1.用分阶段的生命周期计划严格管理
    2.坚持进行阶段评审
    3.实行严格的产品控制
    4.采用现代程序设计技术
    5.结果应能清楚地审查
    6.开发小组的人员应该少而精
    7.承认不断改进软件工程实践的必要性
软件工程方法学
    技术方法的集合称为方法学（范型）。分为传统方法学和面向对象方法学
    软件工程方法学包括3个要素：方法、工具和过程
</code></pre><h3 id=传统方法学生命周期方法学或结构化范型>传统方法学（生命周期方法学或结构化范型）<a hidden class=anchor aria-hidden=true href=#传统方法学生命周期方法学或结构化范型>#</a></h3><p><strong>优点</strong>
把软件生命周期划分成若干相对独立、简单的<strong>阶段</strong>，便于不同人员分工<strong>协作</strong>，降低开发的困难程度
开发过程中采用科学的<strong>管理技术</strong>和良好的<strong>技术方法</strong>，且在每个阶段结束之前都进行严格的<strong>审查</strong>，保证了软件的质量，提高了软件的可维护性
大大提高了软件开发的成功率和生产率
<strong>缺点</strong>
不适用于软件<strong>规模</strong>庞大、或者对软件的<strong>需求</strong>是模糊的或会随时间变化而变化的情况
结构化范型技术把<strong>数据和操</strong>作人为地分离成两个独立的部分，增加了软件开发与维护的难度</p><h3 id=面向对象方法学>面向对象方法学<a hidden class=anchor aria-hidden=true href=#面向对象方法学>#</a></h3><p>与传统方法学的对比
a．传统方法学强调自顶向下、逐层分解、顺序开发
b．面向对象方法学强调主动地多次反复迭代地开发，保证了在各项开发活动之间的平滑过渡
优点
a．降低了软件产品的复杂性
b．提高了软件的可理解性
c．简化了软件的开发和维护工作
d．提高了软件的可重用性</p><h3 id=软件过程>软件过程<a hidden class=anchor aria-hidden=true href=#软件过程>#</a></h3><pre tabindex=0><code>定义：获得高质量软件所需要完成的一系列任务的框架
表示：生命周期模型
瀑布模型的特点: 1.阶段间具有顺序性和依赖性。 2.推迟实
现的观点。3.质量保证的观点。 

快速原型 是快速建立起来的可以在计算机上运行的程序，它
所能完成的功能往往是最终产品能完成功能的一个子集。

增量模型: 它分批地逐步向用户提交产品，整个软件产品被分
解成许多个增量构件，开发人员一个构件一个构件地向用户
提交产品。

螺旋模型; 基本思想是使用原型及其他方法来尽量降低风险。
理解这种模型的一个简单方法，是把它看作在每个阶段之前
都增加了风险分析过程的快速原型模型。 (使用于内部开发
的大规模软件项目 )

喷泉模型: 强调的是“迭代”和“无缝“的特性 是典型的面
向对象的软件过程模型之一.
</code></pre><h3 id=软件周期>软件周期<a hidden class=anchor aria-hidden=true href=#软件周期>#</a></h3><pre tabindex=0><code>1.问题定义: 必须回答的关键问题是， “要解决的问题是什么? ”。
2.可行性研究: 阶段回答的关键问题是: “对于上一个阶段所确定的问题有行得通的解决办法吗? ”
3.需求分析: “目标系统必须做什么”，确定目标系统必须具备哪些功能。
4.总体设计: 必须回答的关键问题是: “概括地说，应该怎样实现目标系统? ”总体设计又称为概要设计。
5.详细设计: 关键问题是: “应该怎样具体地实现这个系统呢? ”
6.编码和单元测试: 关键任务是写出正确的容易理解、容易维护的程序模块。
7.综合测试: 关键任务是通过各种类型的测试使软件达到预定的要求。
8.软件维护: 通过各种必要的维护活动使系统持久地满足用户的需要。
</code></pre><hr><h2 id=可行性研究>可行性研究<a hidden class=anchor aria-hidden=true href=#可行性研究>#</a></h2><h3 id=可行性研究的任务>可行性研究的任务<a hidden class=anchor aria-hidden=true href=#可行性研究的任务>#</a></h3><pre tabindex=0><code>
可行性研究方面
    1.技术可行性
    2.经济可行性
    3.操作可行性
可行性研究过程
    1.复查系统规模和目标；
    2.研究目前正在使用的系统；
    3.导出新系统的高层逻辑模型；
    4.进一步定义问题；
    5.导出并评价供选择的解法；
    6.推荐行动方针；
    7.草拟开发计划；
    8书写文档提交审查。
</code></pre><h3 id=系统流程图>系统流程图<a hidden class=anchor aria-hidden=true href=#系统流程图>#</a></h3><pre tabindex=0><code>描绘物理系统，表达的是数据在系统各部件之间流动的情况
</code></pre><h3 id=数据流图>数据流图<a hidden class=anchor aria-hidden=true href=#数据流图>#</a></h3><pre tabindex=0><code>描绘数据在软件中流动和被处理的逻辑过程，表示系统逻辑模型，是功能模型
矩形：数据的源点/终点
圆角：数据处理
开口：数据存储
箭头：数据流
</code></pre><h3 id=数据字典>数据字典<a hidden class=anchor aria-hidden=true href=#数据字典>#</a></h3><pre tabindex=0><code>标识符 = 字母字符 + 字母数字串
字母数字串 = 0{字母或数字}7
字母或数字 = [字母字符 | 数字字符]
</code></pre><h3 id=成本效益分析>成本/效益分析<a hidden class=anchor aria-hidden=true href=#成本效益分析>#</a></h3><pre tabindex=0><code>目的：帮助客户组织负责人从经济角度判断是否继续投资于这项工程。
方法：
    代码行技术；
    任务分解技术
    自动估计成本技术
</code></pre><hr><h2 id=需求分析>需求分析<a hidden class=anchor aria-hidden=true href=#需求分析>#</a></h2><pre tabindex=0><code>任务：
    确认对系统的综合要求
    分析系统的数据要求
    导出系统的逻辑模型
    修正系统开发计划
需求分析中的三种模型：
    数据模型（E-R 图）
    功能模型（数据流图）
    行为模型（状态转换图）
规格说明
</code></pre><h3 id=实体-联系图>实体-联系图<a hidden class=anchor aria-hidden=true href=#实体-联系图>#</a></h3><pre tabindex=0><code>包括实体（数据对象）、关系和属性3种基本成分
矩形-&gt;实体 菱形-&gt;关系 圆角-&gt;属性
</code></pre><h3 id=状态转换图>状态转换图<a hidden class=anchor aria-hidden=true href=#状态转换图>#</a></h3><pre tabindex=0><code>初态-&gt;实心圆 终态-&gt;空心包实心圆 中间-&gt;圆角
</code></pre><h3 id=其他图形工具>其他图形工具<a hidden class=anchor aria-hidden=true href=#其他图形工具>#</a></h3><pre tabindex=0><code>1.层次方框图（数据层次结构）
2.Warnier图
3.IPO图
</code></pre><hr><h2 id=总体设计>总体设计<a hidden class=anchor aria-hidden=true href=#总体设计>#</a></h2><h3 id=设计原理>设计原理<a hidden class=anchor aria-hidden=true href=#设计原理>#</a></h3><pre tabindex=0><code>模块化
模块独立（低耦合与高内聚）
抽象
逐步求精
信息隐藏和局部化
</code></pre><h3 id=启发原则>启发原则<a hidden class=anchor aria-hidden=true href=#启发原则>#</a></h3><pre tabindex=0><code>改进软件结构提高模块独立性
模块规模应该适中
深度、宽度、扇出和扇入都应适当
模块的作用域应该在控制域之内
力争降低模块接口的复杂程度
设计单入口单出口的模块
模块功能应该可以预测
</code></pre><h3 id=描绘软件结构的图形工具>描绘软件结构的图形工具<a hidden class=anchor aria-hidden=true href=#描绘软件结构的图形工具>#</a></h3><pre tabindex=0><code>1.层次图
2.HIPO图
3.结构图
</code></pre><h3 id=面向数据流的设计方法>面向数据流的设计方法<a hidden class=anchor aria-hidden=true href=#面向数据流的设计方法>#</a></h3><pre tabindex=0><code>1.变换流
2.事务流
</code></pre><hr><h2 id=详细设计>详细设计<a hidden class=anchor aria-hidden=true href=#详细设计>#</a></h2><h3 id=结构程序设计>结构程序设计<a hidden class=anchor aria-hidden=true href=#结构程序设计>#</a></h3><pre tabindex=0><code>结构化程序：仅顺序、选择和循环，且单入单出的程序
</code></pre><h3 id=人机界面设计>人机界面设计<a hidden class=anchor aria-hidden=true href=#人机界面设计>#</a></h3><pre tabindex=0><code></code></pre><h3 id=过程设计>过程设计<a hidden class=anchor aria-hidden=true href=#过程设计>#</a></h3><pre tabindex=0><code>1.程序流程图（程序框图）
2.盒图（N-S图）
3.PAD图（问题分析图）
4.判定表
5.判断树
6.过程设计语言（PDL，伪码）
</code></pre><p>PAD图</p><p><img loading=lazy src=https://raw.githubusercontent.com/zcy2875634712/blogImg/master/dfc4789688644722856588bee556f0f0tplv-mlhdmxsy5m-q7500.jpeg alt=dfc4789688644722856588bee556f0f0tplv-mlhdmxsy5m-q7500></p><h3 id=面向数据结构的设计方法>面向数据结构的设计方法<a hidden class=anchor aria-hidden=true href=#面向数据结构的设计方法>#</a></h3><pre tabindex=0><code></code></pre><h3 id=程序复杂程度的定量度量价值>程序复杂程度的定量度量价值<a hidden class=anchor aria-hidden=true href=#程序复杂程度的定量度量价值>#</a></h3><pre tabindex=0><code>环形复杂度（McCabe方法）：
    V(G)=区域数
    V(G)=E-N+2（E:edge N:node）
    V(G)=P+1（P是判断节点数）
</code></pre><hr><h2 id=实现编码单元测试综合测试>实现（编码、单元测试、综合测试）<a hidden class=anchor aria-hidden=true href=#实现编码单元测试综合测试>#</a></h2><h3 id=测试>测试<a hidden class=anchor aria-hidden=true href=#测试>#</a></h3><pre tabindex=0><code>软件测试的定义
    测试是为了发现程序中的错误而执行程序的过程。
软件测试的目标
    好的测试方案是尽可能发现迄今为止尚未发现的错误的测试方案
    成功的测试是发现了至今为止尚未发现的错误的测试
    根本目标是尽可能多地发现并排除软件中潜藏的错误，最终把一个高质量的软件系统交给用户使用

测试方法：白盒测试和黑盒测试
测试步骤：
    单元测试（模块测试）：测试模块，发现编码和详细设计的错误
    子系统测试：测试模块接口
    系统测试：发现软件设计中和需求说明中的错误
    验收测试（确认测试）：发现系统需求说明书中的错误
</code></pre><h3 id=白盒测试>白盒测试<a hidden class=anchor aria-hidden=true href=#白盒测试>#</a></h3><pre tabindex=0><code>1.语句覆盖：一个if要一个测试用例
2.判断覆盖：一个if要两个测试用例
3.条件覆盖：每个条件取值至少出现一次
4.判断/条件覆盖：
5.条件组合覆盖：每个判定表达式中条件的各种可能组合都至少出现一次.

6.路径覆盖：所有节点路径数的乘积
</code></pre><h3 id=黑盒测试>黑盒测试<a hidden class=anchor aria-hidden=true href=#黑盒测试>#</a></h3><pre tabindex=0><code>1.等价划分
2.边界值分析
3.错误推测
</code></pre><h3 id=集成测试>集成测试<a hidden class=anchor aria-hidden=true href=#集成测试>#</a></h3><pre tabindex=0><code>底驱顶根：自顶向下需要存根程序，自底向上需要驱动程序
</code></pre><h3 id=确认测试>确认测试<a hidden class=anchor aria-hidden=true href=#确认测试>#</a></h3><pre tabindex=0><code>Alpha测试：开发者场所，受控
Beta测试：客户场所，不受控
</code></pre><hr><h2 id=面向对象>面向对象<a hidden class=anchor aria-hidden=true href=#面向对象>#</a></h2><p>面向对象建模</p><pre tabindex=0><code>对象模型：
动态模型：
功能模型：
在UML图中：
    对象模型：类图
    动态模型：状态图和事件追踪图
    功能模型：用例图
</code></pre><p>类图</p><pre tabindex=0><code>泛化（继承）：空心三角和实线
聚合：空心菱形
组合：实心菱形
</code></pre><h3 id=设计准则>设计准则<a hidden class=anchor aria-hidden=true href=#设计准则>#</a></h3><pre tabindex=0><code>模块化
抽象
信息隐蔽
弱耦合
强内聚
可重用
</code></pre><h3 id=软件重用>软件重用<a hidden class=anchor aria-hidden=true href=#软件重用>#</a></h3><pre tabindex=0><code>重用也称为再用或复用，是指同一事物不经修改或稍加改动就多次重复使用
重用级别：
    代码重用
    设计结果重用
    分析结果重用
类构件的重用方式：
    实例重用
    继承重用
    多态重用
</code></pre><h3 id=设计优化>设计优化<a hidden class=anchor aria-hidden=true href=#设计优化>#</a></h3><pre tabindex=0><code>确认优先级
提高效率的几项技术
    增加冗余关联以提高访问效率
    调整查询次序
    保留派生属性
调整继承关系
    设计类继承的方法
    为提高继承程度而修改类定义
    利用委托实现操作共享
</code></pre><h3 id=程序设计风格>程序设计风格<a hidden class=anchor aria-hidden=true href=#程序设计风格>#</a></h3><pre tabindex=0><code>1.提高可重用性
    （1）提高方法的内聚
    （2）减小方法的规模
    （3）保持方法的一致性
    （4）把策略与实现分开
    （5）全面覆盖输入条件的各种可能组合
    （6）尽量不使用全局信息
    （7）充分利用继承机制
2.提高可扩充性
提高可重用性的准则同样也能提高程序的可扩充性
    （1）封装类的实现细节
    （2）不要用一个方法遍历多条关联链。
    （3）避免使用多分支语句
    （4）精心选择和定义公有方法
3.提高健壮性
    （1）预防用户的错误操作
    （2）检查参数的合法性
    （3）不要预先设定数据结构的限制条件
    （4）先测试后优化
</code></pre><h3 id=设计测试用例>设计测试用例<a hidden class=anchor aria-hidden=true href=#设计测试用例>#</a></h3><pre tabindex=0><code>测试类
    随机测试
    划分测试
    基于故障测试
集成测试
    多类测试：随机测试和划分测试
    从动态模型导出测试用例
</code></pre><hr><h2 id=软件项目管理>软件项目管理<a hidden class=anchor aria-hidden=true href=#软件项目管理>#</a></h2><p>软件项目管理就是通过<strong>计划、组织和控制</strong>等一系列活动，合理地配置
和使用各种资源，以达到既定目标的过程。</p><p>计划：估计软件规模，工作量估算，进度计划
组织：民主制程序员组，主程序员组，现代程序员组
控制：质量保证，配置管理</p><h2 id=大纲>大纲<a hidden class=anchor aria-hidden=true href=#大纲>#</a></h2><pre tabindex=0><code>一、软件工程概述
软件生命周期、软件过程
二、需求分析
需求分析的任务、建模和规格说明、UML（类图、状态
图、顺序图、活动图)
三、总体设计
设计原理、启发规则、面向数据流的设计方法、
四、详细设计和实现
过程设计工具、面向数据结构的设计方法、程序复杂度的度量、编码、软件测试基础、单元测试、集成测试、白盒测试、黑盒测试
五、面向对象分析、設計和实现
面向对象分析过程、对象模型、动态模型、功能模型
面向对象设计准则、软件重用、设计优化、程序设计风格、设计测试用例
六、软件项目管理
工作量估算、进度计划、质量保证、软件配置
</code></pre></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://zcy2875634712.github.io/posts/note/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/><span class=title>« Prev</span><br><span>深度学习</span></a>
<a class=next href=https://zcy2875634712.github.io/posts/note/go/%E9%80%9F%E6%9F%A5/><span class=title>Next »</span><br><span>速查</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 软件工程导论 on twitter" href="https://twitter.com/intent/tweet/?text=%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba&amp;url=https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E8%25BD%25AF%25E4%25BB%25B6%25E5%25B7%25A5%25E7%25A8%258B%25E5%25AF%25BC%25E8%25AE%25BA%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 软件工程导论 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E8%25BD%25AF%25E4%25BB%25B6%25E5%25B7%25A5%25E7%25A8%258B%25E5%25AF%25BC%25E8%25AE%25BA%2f&amp;title=%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba&amp;summary=%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba&amp;source=https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E8%25BD%25AF%25E4%25BB%25B6%25E5%25B7%25A5%25E7%25A8%258B%25E5%25AF%25BC%25E8%25AE%25BA%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 软件工程导论 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E8%25BD%25AF%25E4%25BB%25B6%25E5%25B7%25A5%25E7%25A8%258B%25E5%25AF%25BC%25E8%25AE%25BA%2f&title=%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 软件工程导论 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E8%25BD%25AF%25E4%25BB%25B6%25E5%25B7%25A5%25E7%25A8%258B%25E5%25AF%25BC%25E8%25AE%25BA%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 软件工程导论 on whatsapp" href="https://api.whatsapp.com/send?text=%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%20-%20https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E8%25BD%25AF%25E4%25BB%25B6%25E5%25B7%25A5%25E7%25A8%258B%25E5%25AF%25BC%25E8%25AE%25BA%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 软件工程导论 on telegram" href="https://telegram.me/share/url?text=%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba&amp;url=https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E8%25BD%25AF%25E4%25BB%25B6%25E5%25B7%25A5%25E7%25A8%258B%25E5%25AF%25BC%25E8%25AE%25BA%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://zcy2875634712.github.io/>ybyb</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>