<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>核心纲要读书笔记 | ybyb</title><meta name=keywords content><meta name=description content="mo x本文由 简悦 SimpRead 转码， 原文地址 marlous.github.io
Mo&rsquo;s Blog at GitHub
参考：
1、 《软件工程导论》张海潘版
2、 软件工程——思维导图
3、 软件工程导论张海潘 (第六版) 第 1-13 章总结
4、 软件工程的基本概念
5、 软件工程期末考试重点
6、 软件工程考试重点内容
7、 软件工程期末考试复习题及答案
软件工程 来源见水印。
1 工具 参考博文 《DevOps 与 CI/CD 的概念》。
项目管理： 任务跟踪：禅道、Trello、Teambition 等。 项目计划：禅道、Trello、Teambition 等。 团队沟通：Slack、Teambition 等。 需求分析： 需求跟踪：禅道、Teambition、Trello 等。 原型制作：Adobe XD CC、Axure、Sketch 等，参考：16 种原型制作工具及使用介绍。 设计： UML 建模：Violet UM、ProcessOn、StarUML、Visio 等。（类图、对象图；用例图、状态图、活动图、序列图。参考：UML 各种图总结精华、各种图含义作用 ） 图表制作：Excel、亿图等。 开发： 源代码管理：GitHub、GitLab、SubVersion 等（Git、SVN）。 持续集成：Jenkins、CireleCI、AppCenter、Travis CI、flow.ci 等。 测试： Bug 跟踪：禅道、Teambition、Trello、The Bug Genie 等。 测试管理平台：TestLink、Redmine、禅道、TestCenter 等。 自动化测试：常用的：QPT、LR。/ 开源功能自动化测试工具：Watir、Selenium、MaxQ、WebInject。/ 开源性能自动化测试工具：Jmeter、OpenSTA、DBMonster、TPTEST、Web Application Load Simulator。 补充，自动化构建和测试: Apache Ant、Maven 、Selenium、PyUnit、QUnit、JMeter、Gradle、PHPUnit。 运行维护： 自动化部署：Jenkins、ElectricFlow、DeployBot、CireleCI、AppCenter、Travis CI 等。 日志分析：Logstash、CollectD、StatsD 等。 线上监控：Nagios、Ganglia、Sensu、zabbix、ICINGA、Graphite、Kibana 等。 2 软件工程文档 需要文档的几个方面： 立项文档 需求分析文档 概要设计和架构设计 详细设计 源代码 配置文档 单元测试文档 集成测试文档 验收文档 维护文档 用户操作手册 项目管理文档 具体文档： 项目管理文档："><meta name=author content="Me"><link rel=canonical href=https://zcy2875634712.github.io/posts/note/%E6%A0%B8%E5%BF%83%E7%BA%B2%E8%A6%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://zcy2875634712.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://zcy2875634712.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://zcy2875634712.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://zcy2875634712.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://zcy2875634712.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="核心纲要读书笔记"><meta property="og:description" content="mo x本文由 简悦 SimpRead 转码， 原文地址 marlous.github.io
Mo&rsquo;s Blog at GitHub
参考：
1、 《软件工程导论》张海潘版
2、 软件工程——思维导图
3、 软件工程导论张海潘 (第六版) 第 1-13 章总结
4、 软件工程的基本概念
5、 软件工程期末考试重点
6、 软件工程考试重点内容
7、 软件工程期末考试复习题及答案
软件工程 来源见水印。
1 工具 参考博文 《DevOps 与 CI/CD 的概念》。
项目管理： 任务跟踪：禅道、Trello、Teambition 等。 项目计划：禅道、Trello、Teambition 等。 团队沟通：Slack、Teambition 等。 需求分析： 需求跟踪：禅道、Teambition、Trello 等。 原型制作：Adobe XD CC、Axure、Sketch 等，参考：16 种原型制作工具及使用介绍。 设计： UML 建模：Violet UM、ProcessOn、StarUML、Visio 等。（类图、对象图；用例图、状态图、活动图、序列图。参考：UML 各种图总结精华、各种图含义作用 ） 图表制作：Excel、亿图等。 开发： 源代码管理：GitHub、GitLab、SubVersion 等（Git、SVN）。 持续集成：Jenkins、CireleCI、AppCenter、Travis CI、flow.ci 等。 测试： Bug 跟踪：禅道、Teambition、Trello、The Bug Genie 等。 测试管理平台：TestLink、Redmine、禅道、TestCenter 等。 自动化测试：常用的：QPT、LR。/ 开源功能自动化测试工具：Watir、Selenium、MaxQ、WebInject。/ 开源性能自动化测试工具：Jmeter、OpenSTA、DBMonster、TPTEST、Web Application Load Simulator。 补充，自动化构建和测试: Apache Ant、Maven 、Selenium、PyUnit、QUnit、JMeter、Gradle、PHPUnit。 运行维护： 自动化部署：Jenkins、ElectricFlow、DeployBot、CireleCI、AppCenter、Travis CI 等。 日志分析：Logstash、CollectD、StatsD 等。 线上监控：Nagios、Ganglia、Sensu、zabbix、ICINGA、Graphite、Kibana 等。 2 软件工程文档 需要文档的几个方面： 立项文档 需求分析文档 概要设计和架构设计 详细设计 源代码 配置文档 单元测试文档 集成测试文档 验收文档 维护文档 用户操作手册 项目管理文档 具体文档： 项目管理文档："><meta property="og:type" content="article"><meta property="og:url" content="https://zcy2875634712.github.io/posts/note/%E6%A0%B8%E5%BF%83%E7%BA%B2%E8%A6%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><meta property="og:image" content="https://zcy2875634712.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="og:site_name" content="ybyb"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://zcy2875634712.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="核心纲要读书笔记"><meta name=twitter:description content="mo x本文由 简悦 SimpRead 转码， 原文地址 marlous.github.io
Mo&rsquo;s Blog at GitHub
参考：
1、 《软件工程导论》张海潘版
2、 软件工程——思维导图
3、 软件工程导论张海潘 (第六版) 第 1-13 章总结
4、 软件工程的基本概念
5、 软件工程期末考试重点
6、 软件工程考试重点内容
7、 软件工程期末考试复习题及答案
软件工程 来源见水印。
1 工具 参考博文 《DevOps 与 CI/CD 的概念》。
项目管理： 任务跟踪：禅道、Trello、Teambition 等。 项目计划：禅道、Trello、Teambition 等。 团队沟通：Slack、Teambition 等。 需求分析： 需求跟踪：禅道、Teambition、Trello 等。 原型制作：Adobe XD CC、Axure、Sketch 等，参考：16 种原型制作工具及使用介绍。 设计： UML 建模：Violet UM、ProcessOn、StarUML、Visio 等。（类图、对象图；用例图、状态图、活动图、序列图。参考：UML 各种图总结精华、各种图含义作用 ） 图表制作：Excel、亿图等。 开发： 源代码管理：GitHub、GitLab、SubVersion 等（Git、SVN）。 持续集成：Jenkins、CireleCI、AppCenter、Travis CI、flow.ci 等。 测试： Bug 跟踪：禅道、Teambition、Trello、The Bug Genie 等。 测试管理平台：TestLink、Redmine、禅道、TestCenter 等。 自动化测试：常用的：QPT、LR。/ 开源功能自动化测试工具：Watir、Selenium、MaxQ、WebInject。/ 开源性能自动化测试工具：Jmeter、OpenSTA、DBMonster、TPTEST、Web Application Load Simulator。 补充，自动化构建和测试: Apache Ant、Maven 、Selenium、PyUnit、QUnit、JMeter、Gradle、PHPUnit。 运行维护： 自动化部署：Jenkins、ElectricFlow、DeployBot、CireleCI、AppCenter、Travis CI 等。 日志分析：Logstash、CollectD、StatsD 等。 线上监控：Nagios、Ganglia、Sensu、zabbix、ICINGA、Graphite、Kibana 等。 2 软件工程文档 需要文档的几个方面： 立项文档 需求分析文档 概要设计和架构设计 详细设计 源代码 配置文档 单元测试文档 集成测试文档 验收文档 维护文档 用户操作手册 项目管理文档 具体文档： 项目管理文档："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zcy2875634712.github.io/posts/"},{"@type":"ListItem","position":2,"name":"核心纲要读书笔记","item":"https://zcy2875634712.github.io/posts/note/%E6%A0%B8%E5%BF%83%E7%BA%B2%E8%A6%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"核心纲要读书笔记","name":"核心纲要读书笔记","description":"mo x本文由 简悦 SimpRead 转码， 原文地址 marlous.github.io\nMo\u0026rsquo;s Blog at GitHub\n参考：\n1、 《软件工程导论》张海潘版\n2、 软件工程——思维导图\n3、 软件工程导论张海潘 (第六版) 第 1-13 章总结\n4、 软件工程的基本概念\n5、 软件工程期末考试重点\n6、 软件工程考试重点内容\n7、 软件工程期末考试复习题及答案\n软件工程 来源见水印。\n1 工具 参考博文 《DevOps 与 CI/CD 的概念》。\n项目管理： 任务跟踪：禅道、Trello、Teambition 等。 项目计划：禅道、Trello、Teambition 等。 团队沟通：Slack、Teambition 等。 需求分析： 需求跟踪：禅道、Teambition、Trello 等。 原型制作：Adobe XD CC、Axure、Sketch 等，参考：16 种原型制作工具及使用介绍。 设计： UML 建模：Violet UM、ProcessOn、StarUML、Visio 等。（类图、对象图；用例图、状态图、活动图、序列图。参考：UML 各种图总结精华、各种图含义作用 ） 图表制作：Excel、亿图等。 开发： 源代码管理：GitHub、GitLab、SubVersion 等（Git、SVN）。 持续集成：Jenkins、CireleCI、AppCenter、Travis CI、flow.ci 等。 测试： Bug 跟踪：禅道、Teambition、Trello、The Bug Genie 等。 测试管理平台：TestLink、Redmine、禅道、TestCenter 等。 自动化测试：常用的：QPT、LR。/ 开源功能自动化测试工具：Watir、Selenium、MaxQ、WebInject。/ 开源性能自动化测试工具：Jmeter、OpenSTA、DBMonster、TPTEST、Web Application Load Simulator。 补充，自动化构建和测试: Apache Ant、Maven 、Selenium、PyUnit、QUnit、JMeter、Gradle、PHPUnit。 运行维护： 自动化部署：Jenkins、ElectricFlow、DeployBot、CireleCI、AppCenter、Travis CI 等。 日志分析：Logstash、CollectD、StatsD 等。 线上监控：Nagios、Ganglia、Sensu、zabbix、ICINGA、Graphite、Kibana 等。 2 软件工程文档 需要文档的几个方面： 立项文档 需求分析文档 概要设计和架构设计 详细设计 源代码 配置文档 单元测试文档 集成测试文档 验收文档 维护文档 用户操作手册 项目管理文档 具体文档： 项目管理文档：","keywords":[],"articleBody":" mo x本文由 简悦 SimpRead 转码， 原文地址 marlous.github.io\nMo’s Blog at GitHub\n参考：\n1、 《软件工程导论》张海潘版\n2、 软件工程——思维导图\n3、 软件工程导论张海潘 (第六版) 第 1-13 章总结\n4、 软件工程的基本概念\n5、 软件工程期末考试重点\n6、 软件工程考试重点内容\n7、 软件工程期末考试复习题及答案\n软件工程 来源见水印。\n1 工具 参考博文 《DevOps 与 CI/CD 的概念》。\n项目管理： 任务跟踪：禅道、Trello、Teambition 等。 项目计划：禅道、Trello、Teambition 等。 团队沟通：Slack、Teambition 等。 需求分析： 需求跟踪：禅道、Teambition、Trello 等。 原型制作：Adobe XD CC、Axure、Sketch 等，参考：16 种原型制作工具及使用介绍。 设计： UML 建模：Violet UM、ProcessOn、StarUML、Visio 等。（类图、对象图；用例图、状态图、活动图、序列图。参考：UML 各种图总结精华、各种图含义作用 ） 图表制作：Excel、亿图等。 开发： 源代码管理：GitHub、GitLab、SubVersion 等（Git、SVN）。 持续集成：Jenkins、CireleCI、AppCenter、Travis CI、flow.ci 等。 测试： Bug 跟踪：禅道、Teambition、Trello、The Bug Genie 等。 测试管理平台：TestLink、Redmine、禅道、TestCenter 等。 自动化测试：常用的：QPT、LR。/ 开源功能自动化测试工具：Watir、Selenium、MaxQ、WebInject。/ 开源性能自动化测试工具：Jmeter、OpenSTA、DBMonster、TPTEST、Web Application Load Simulator。 补充，自动化构建和测试: Apache Ant、Maven 、Selenium、PyUnit、QUnit、JMeter、Gradle、PHPUnit。 运行维护： 自动化部署：Jenkins、ElectricFlow、DeployBot、CireleCI、AppCenter、Travis CI 等。 日志分析：Logstash、CollectD、StatsD 等。 线上监控：Nagios、Ganglia、Sensu、zabbix、ICINGA、Graphite、Kibana 等。 2 软件工程文档 需要文档的几个方面： 立项文档 需求分析文档 概要设计和架构设计 详细设计 源代码 配置文档 单元测试文档 集成测试文档 验收文档 维护文档 用户操作手册 项目管理文档 具体文档： 项目管理文档：\n《软件项目计划》、《项目进度报告》、《项目开发总结报告》\n管理控制文档：\n《配置文档》、《维护文档》\n软件开发文档：\n《需求规格说明》、《概要设计说明》、《详细设计说明》、《软件源码文档》、《测试计划》、《软件测试分析报告》\n产品文档：\n《用户操作手册》、《演示文件》\n一 软件工程学概述 软件工程方法学： 软件工程包括：技术、管理。 软件工程方法学三要素：过程（步骤）、方法（如何做）、工具（支持环境）。 传统方法学：强调自顶向下。面向对象方法学：强调主动多次反复迭代。（四个要点：对象、类、继承、消息。） 软件周期（三个时期，八个阶段）：\n软件过程：\n瀑布模型：规范、文档驱动；最终产品可能不是用户真正需求；难以按模型进行，开发过程逆转代价大。\n快速原型模型：快速构建可在计算机上运行的原型系统，让用户反馈，开发周期短；客户与开发者对原型的理解不同，准确的设计原型困难。\n螺旋模型：可看作增加了风险分析过程的快速原型模型；风险驱动，适用内部大型项目的开发。\n增量模型：短期提交可完成部分，逐步增加功能；软件需具备开放性会导致失去整体结构，也可能有无法集成的问题。\n喷泉模型：体现了面向对象软件开发过程无缝迭代特性。\n补充，敏捷开发：是一套价值观和原则，大项目由各个可独立运行的小项目组成，此期间软件一直处于可使用状态。迭代式开发与增量交付。敏捷开发视频课程，敏捷开发之 Scrum 视频课程。\n敏捷开发之 Scrum：计划、构建、测试、回顾。不断重复这四步来做增量式发布，最后形成一个可发布的版本。/ 三个角色：产品经理、Scrum 负责人、Scrum 团队（开发、测试、文案等人员）。/ 产品经理需求、用户视角需求。/ 三个会议：计划会议（产品经理与负责人）、每日例会（团队工作进度）、回顾会议（展示和改进）。\n敏捷开发之极限编程：\n一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期；通过积极的交流、反馈以及其它一系列的方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。/\n计划在极限编程中被视为临时工件；高质量的代码在极限编程项目中是必不可少的；良好的单元测试和验收测试是极限编程项目的标志。\n小结：\n各阶段具体任务：\n二 可行性研究 目的：\n确定问题是否值得去解决。\n实质：\n在较高层次去用抽象的方法进行系统分析、设计的过程。\n内容：\n进一步分析定义问题，导出逻辑模型，探索若干种可供选择的解决方法。\n从几个方面研究可行性：\n技术、经济、操作可行性、运行可行性、法律等。\n可行性研究的步骤：\n具体步骤：\n复查系统规模和目标 -\u003e 研究目前正在使用的系统 -\u003e 导出新系统的高层逻辑模型 -\u003e 进一步定义问题 -\u003e 导出和评价供选择的解法 -\u003e 推荐行动方针 -\u003e 草拟开发计划 -\u003e 书写文档提交审查 小结：\n对问题正确定义的基础上，分析问题，导出试探性的解，（复查修正定义，再次分析问题，改进解）最终提出逻辑模型，根据逻辑模型设想可能的系统模型，并从多角度研究可行性，提交用户客户组织负责人审查批准。 系统流程图（物理）：\n概括描述物理系统的传统工具。\n数据流图（逻辑）：\n只描述数据在软件中流动和被处理的逻辑过程。\n数据字典（逻辑）：\n概念：关于数据的信息集合（作为分析阶段工具，开发数据库的第一步）。数据字典和数据流图共同构成逻辑模型。 数据字典的实现，例：\n符号：= 定义为，+ 连接两个分量，[ ] 其中有若干个，分量用 | 表示，{ } 重复，左边写下限，右边写上限，( ) 可选，其中的分量可有可无。 举例：标识符 = 字母字符 + 字母数字串，字母数字串 = 0{字母或数字}7，字母或数字 = [字母字符 | 数字字符]。 成本效益分析： 货币时间价值：P 为现在价值、F 为未来价值、i 为年利率、n 为年数，F=P(1+i)^n，同理 P=F/((1+i)^n)。 投资回报率：P 为现在投资额、Fi 为第 i 年底的效益（i=1、2、…）、n 为系统使用寿命、j 为投资回报率。P=Fi/((1+j)^n) ，i 从 1 到 n，累加。 补充 项目计划：\n它是软件开发工作的第一步。 项目计划的目标是为项目负责人提供一个框架，使之能合理地估算软件项目开发所需的资源 、经费和开发进度，并控制软件项目开发过程按此计划进行。 在做计划时，必须就需要的人力、项目持续时间及成本作出估算。这种估算大多是参考 以前的花费作出的。软件项目计划包括二个任务：研究和估算。即通过研究确定该软件 项目的主要功能、性能和系统界面。 范围：项目目标、主要功能、性能限制、系统接口、特殊要求、开发概述。 资源：人员资源、硬件资源、软件资源、其他。 进度安排：工程网络图、Gantt 图、任务资源表、成本估算、培训计划。 流程规范：\n软件工程方法（怎样做）。\n风险管理：\n风险识别：头脑风暴法、面谈、Delphi 法、核对表、SWOT 技术。 风险量化：风险因子计算、PERT 估计、决策树分析、风险模拟。 风险应对计划制定：回避、转移、缓和、接受。 风险监控：核对表、定期项目评估、挣值分析。 配置管理：\n软件配置管理，贯穿于整个软件生命周期，它为软件研发提供了一套管理办法和活动原则。软件配置管理无论是对于软件企业管理人员还是研发人员都有着重要的意义。/ 关键活动包括：配置项、工作空间管理、版本控制、变更控制、状态报告、配置审计等。/ 软件配置管理可以提炼为三个方面的内容： VersionControl 版本控制 ChangeControl 变更控制 ProcessSupport 过程支持 配置管理的目的： 配置识别：识别配置、配置项目和基准。 配置控管：导入变更控管流程。该流程通常由变更控制委员会来运行，其主要的职责是核准或拒绝有悖任何基准的所有变更请求。 配置状态报告：记录和呈报与开发过程状态相关的所有必要信息。 配置审核：确保这些配置包含所有预期内容，且备有完整的规定文件（包括要求、结构规范和用户手册）。 建构管理：管理用于建构的流程和工具。 流程管理：确保遵循企业组织的开发流程。 环境管理：管理承载系统的软硬件。 团队合作：促进流程中团队彼此间的交互。 缺陷追踪：确保可溯及每个缺陷的源头。 三 需求分析 概念： 定义：确定系统必须完成哪些工作。写出软件需求规格说明书，以书面形式准确描述软件需求。 需求内容：功能需求、性能需求、可靠性需求、出错需求、接口需求、逆向需求、将来可能提出的需求。 系统分析的数据要求： 建立数据模型（E-R 图） 描绘数据结构（层次方框图、Warnier 图） 数据结构规范化 需求分析中的三种模型： 数据模型（E-R 图）。 功能模型（数据流图）。 行为模型（状态转换图）。\n三种模型对应的三种图： E-R 图：由数据对象（矩形）、属性（圆角矩形）、关系（菱形）组成。\n数据流图：由起点 / 终点（矩形）、数据处理（标号圆角矩形）、数据存储（标号不封闭矩形）、数据流（箭头）组成。\n状态转换图：由状态、事件组成。\n补充： 结构化分析方法：\n传统软件方法学使用结构化分析技术。实质上是一种建模活动，在需求分析阶段通常建立数据模型（E-R 图）、功能模型（数据流图）、行为模型（状态转换图）。\n书写需求分析文档：\n通常从需求的一致性、完整性、现实性、有效性 4 个方面复审软件需求规格说明书。通过严格评审和用户确认后，作为此阶段的最终成果。\n需求分析与可行性研究间的关系：\n软件需求分析就是把软件计划期间建立的软件可行性分析求精和细化，分析各种可能的解法，并且分配给各个软件元素。\n数据字典的作用：\n数据字典描述在数据模型、功能模型、行为模型中出现的数据对象、控制信息的特性，给出它们的准确定义。数据字典成为把 3 种分析模型粘合在一起的 “粘合剂”。\n补充 需求分析：\n见上。\n变更管理：\n参考：\n1、 百度经验：如何理解变更管理\n需要确保变更在可控的方式下被记录、评估、授权、确定优先级、计划、测试、实施、备案以及回顾。\n四 形式化说明技术（略） 五 总体设计（系统设计） 设计原理：\n模块化、模块独立、抽象、逐步求精、信息隐藏、局部化。\n设计任务与过程：\n总体设计任务：用抽象概括的方式确定系统如何完成预定的任务，并确定组成系统的每个程序的结构。 总体设计过程：系统设计（全局。数据流图触发确定系统的具体实现物理方案）；结构设计（局部。确定软件结构。软件由哪些模块组成，及其动态调用过程。/ 功能分解、设计软件结构、设计数据库、制定测试文档）。 模块化、模块独立概念： 模块化：把程序划分为独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体。 模块独立：是抽象、模块化（低耦合）、信息隐藏、局部化（高内聚）概念的直接结果。 模块独立程度的定性度量标准（低耦合与高内聚）： 概念：耦合：模块间互连程度。/ 内聚：一个模块内各个元素彼此结合的紧密程度。 六种耦合：无直接耦合、数据耦合、标记耦合、控制耦合、公共环境耦合、内容耦合。 六种内聚：功能内聚、顺序内聚，通信内聚、过程内聚，时间内聚、逻辑内聚、偶然内聚。 描述软件结构的图形工具：\n层次方框图：\n层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构。 a) 层次图、HIPO 图：（层次图无 HIPO 图中的标号）。\nb) 结构图：\nWarnier 图:\n和层次方框图类似，Warnier 图也用树形结构描绘信息，但是这种图形工具比层次方框图提供了更丰富的描绘手段。\nIPO 图：\nIPO 图是输入、处理、输出图的简称，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。\n数据字典、数据流图、数据库间的关系： 数据字典是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合。 数据字典、数据流图共同构成逻辑模型。 从数据字典、数据流图出发，首先得到的是数据库的概念结构。 小结：（数据字典 -\u003e 数据流图）可行性研究的逻辑模型 -\u003e 数据库的概念模型 启发式规则：\n面向数据流的设计方法（结构化设计方法）：\n概念：把数据流图变成软件结构。 方法（变换分析设计）：数据流图求精 -\u003e 独立出变化中心 -\u003e 各个控制模块 -\u003e 映射成软件中适当的模块\n变换流与事物流： 数据流图（DFD）一般可分为 “变换流”，“事物流” 两种。这是信息流的两种类型。 “变换流”：由输入、处理、输出三部分组成，是一顺序结构。 “事物流”：它的某个加工，分离成许多分散的数据流，形成许多加工路径，并且根据输入值选择其中一个路径来执行。 从数据流导出软件的层次结构： 数据流图反应的是数据的系统逻辑模型，是信息流在系统中的流动反应，结构图是系统的物理模型，他反应的是系统的层次结构和功能关系。 在系统设计阶段，可以根据 DFD 图，分别通过变换分析和事务分析方法，先设计结构图的顶端主模块，然后自顶向下逐步细化，从 DFD 图导出满足数据流图要求的、标准形式的系统结构图。 总体设计与需求分析间的关系：\n总体设计需求分析的结果，需求分析是系统设计的依据。/ 补充：将逻辑模型（分析模型）转换为物理模型（设计模型）。 补充 架构设计： 它是一个软件系统从整体到部分的最高层次的划分。/ 一个系统通常是由元件组成的，而这些元件如何形成、相互之间如何发生作用，则是关于这个系统本身结构的重要信息。\n架构设计详细地说，就是要包括架构元件（Architecture Component）、联结器（Connector）、任务流（TASk-flow）。所谓架构元素，也就是组成系统的核心” 砖瓦”，而联结器则描述这些元件之间通讯的路径、通讯的机制、通讯的预期结果，任务流则描述系统如何使用这些元件和联结器完成某一项需求。\n三个方面：\n逻辑架构、物理架构、系统架构。\n技术选型： 参考：架构设计和技术选型的思路总结 重构： 概念：\n重构（Refactoring）就是通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。\n重构的时机：\n在添加新功能时进行重构、在修改 bug 时进行重构、在代码复审时进行重构、到了最后的交付期限不进行重构。\n重构难题：\n（a 关系数据库与面向对象编程的问题——在对象模型和数据库模型之间插入一个分隔层，这就可以隔离两个模型各自的变化，升级某一模型时只需同时升级上述的分隔层即可，这样的分隔层会增加系统复杂度，但是能增加灵活度。/ （b\n修改接口的问题——修改已发布的接口，因为已发布的接口会供外部人员（其它公司）使用，因此修改接口会导致引用接口的其它程序不修改程序就无法运行。修改接口的最好的办法是增加一个新的接口，让旧接口调用新接口，这样原来的程序就不用修改了。对于接口的另一个建议是尽量不要发布接口。\n六 详细设计（模块设计） 结构程序设计概念：\n是进行以模块功能和处理过程设计为主的详细设计的基本原则。结构化程序设计是过程式程序设计的一个子集，它对写入的程序使用逻辑结构，使得理解和修改更有效更容易。 经典的结构程序设计：三种基本控制结构。 扩展的结构程序设计：允许使用 do-case、do-until 循环结构。 修正的结构程序设计：允许加上 break 结构。 过程设计工具：\n用图形、表格、语言。 程序流程图：不易表示数据结构。 盒图（N-S 图）：\nPAD 图（问题分析图）：\n判定树。\n判定表。\n过程设计语言（PDL 伪码）。 Jackson 程序设计方法：\n从目标系统的输入、输出数据结构入手，导出程序框架结构，再补充其它细节，就可得到完整的程序结构图。这一方法对输入、输出数据结构明确的中小型系统特别有效，如商业应用中的文件表格处理。该方法也可与其它方法结合，用于模块的详细设计。\nWarnier 程序设计方法：\nWarnier 提出的软件开发方法与 Jackson 方法类似。差别有三点：一是它们使用的图形工具不同，分别使用 Warnier 图和 Jackson 图；另一个差别是使用的伪码不同；最主要的差别是在构造程序框架时，Warnier 方法仅考虑输入数据结构，而 Jackson 方法不仅考虑输入数据结构，而且还考虑输出数据结构。\n程序复杂结构的定量度量：\n七 实现（编码、单元测试、综合测试） 编码：\n选择程序设计语言、编码风格。\n测试等见最后的总结。\n黑盒测试之等价划分方法：\n有 / 无效等价类 测试用例\n黑盒测试之边界值分析方法：\n白盒测试之逻辑覆盖：\n参考：白盒测试：语句覆盖、条件覆盖、判定覆盖、条件 - 判定覆盖、组合覆盖、路径覆盖\n八 维护 四项活动：\n改正性维护、适应性维护、完善性维护、预防性维护。\n决定软件可维护性因素：\n可理解性、可测试性、可修改性、可靠性、可移植性、可使用性。\n九、十 面向对象方法学引论与面向对象分析 面向对象开发方法：\n概念：\n面向对象三大特性：\n封装、继承、多态。\n面向对象建模：\n定义类：类名、属性、服务。 面向对象分析之建模的三个模型： 对象模型：静态结构。定义了做事情的实体。 功能模型：功能。系统应该做什么。 动态模型：交互次序。规定了什么时候做。 面向对象分析之五个层次：\n主题层、类与对象、结构层、属性层、服务层。\nUML：\n十一 面向对象设计 概念：\n模块化、低耦合高内聚、抽象、信息隐藏。 十二（第十二章略） 十三 软件项目管理 十四 总结（知识框架） 仅针对本书。\n← Previous Post Next Post → 软件工程 1 工具 2 软件工程文档 一 软件工程学概述 二 可行性研究 补充 三 需求分析 补充 四 形式化说明技术（略） 五 总体设计（系统设计） 补充 六 详细设计（模块设计） 七 实现（编码、单元测试、综合测试） 八 维护 九、十 面向对象方法学引论与面向对象分析 十一 面向对象设计 十二（第十二章略） 十三 软件项目管理 十四 总结（知识框架） FEATURED TAGS 学习笔记— title: 速查 Variables:\ngoCopy codevar name string = \"John\" age := 30 // type inferred as int var ( city string = \"New York\" zipCode int = 10001 ) Data Types:\ngoCopy codebool string int, int8, int16, int32, int64 uint, uint8, uint16, uint32, uint64, uintptr byte (alias for uint8) rune (alias for int32) float32, float64 complex64, complex128 Constants:\ngoCopy codeconst pi = 3.14 const ( monday = \"Monday\" tuesday = \"Tuesday\" ) Control Structures:\ngoCopy codeif age \u003e= 18 { fmt.Println(\"You are an adult\") } else { fmt.Println(\"You are not an adult\") } for i := 0; i \u003c 5; i++ { fmt.Println(i) } switch day { case \"Monday\": fmt.Println(\"Today is Monday\") case \"Tuesday\": fmt.Println(\"Today is Tuesday\") default: fmt.Println(\"Unknown day\") } Arrays and Slices:\ngoCopy codevar names [3]string names[0] = \"John\" names[1] = \"Jane\" names[2] = \"Bob\" scores := []int{10, 20, 30} scores = append(scores, 40) Maps:\ngoCopy codeages := map[string]int{ \"John\": 30, \"Jane\": 25, \"Bob\": 35, } fmt.Println(ages[\"John\"]) // Output: 30 delete(ages, \"Bob\") Functions:\ngoCopy codefunc sayHello(name string) { fmt.Println(\"Hello,\", name) } func add(x int, y int) int { return x + y } func calculate(x, y int) (int, int) { sum := x + y diff := x - y return sum, diff } ```--- title: 数据结构 --- --- title: 数据结构 --- ### 单向链表 ```c //插入节点 newNode-\u003enext = curNode-\u003enext; curNode-\u003enext = newNode; //遍历节点 for (p = head-\u003enext; p != NULL; p = p-\u003enext) //删除节点 preNode-\u003enext = curNode-\u003enext; free(curNode); 树 树相关定义 根节点：没有父节点 非根节点：只有一个父节点 节点的度：子树的数目 叶子：度为零的节点 title: 复试问答 你为什么选择跨专业考研？\n自我介绍\n各位老师上午好，我是xxx，非常荣幸能够进入林科大软件工程的复试。我本科就读于中南林业科技大学的食品质量与安全专业，在林科大的四年里，优越的人文环境，浓厚的学习氛围时刻熏陶着我，专业成绩良好。 我选择跨考软件工程这一专业，最重要的原因就是热爱，对编程的兴趣起源于高中信息技术教材上的VB语言，从简单的打字测速程序到复杂的管理系统让我感受到了编程的强大力量。其次是因为一直以来我的理想就是成为一名程序员，我在高考后de暑假自学了C语言，本科期间自学了python和数据结构。 不忘初心，方得始终，希望有机会能够继续跟随学校优秀的老师们学习软件工程相关知识，相信凭借自己的勤奋和踏实，能在计算机领域提升自己的专业素养和实践能力，谢谢老师，我的自我介绍完毕。 Hello teachers, good morning. I am xxx, and it is my great honor to have the opportunity to participate in the software engineering interview at Central South University of Forestry and Technology. I majored in Food Quality and Safety at Central South University of Forestry and Technology for my undergraduate studies. During my four years at Central South University of Forestry and Technology, I have been influenced by the excellent humanistic environment and strong academic atmosphere, and my academic performance was outstanding. I chose to switch to software engineering because of my passion for programming. My interest in programming started from the VB language in the information technology textbook in high school. From simple typing speed measurement programs to complex management systems, I felt the power of programming. Moreover, my ideal has always been to become a programmer. After the college entrance examination, I self-studied C language during the summer vacation, and during my undergraduate studies, I self-studied Python and data structures. I will not forget my original intention and will always stick to it. I hope to have the opportunity to continue to learn software engineering-related knowledge from the excellent teachers at the university. I believe that with my diligence and hard work, I can improve my professional skills and practical abilities in the field of computer science. Thank you, teachers. That concludes my self-introduction. title: 软件工程导论 title: 软件工程笔记 软件危机 定义：软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题 原因： （1）客观原因 ① 软件是计算机系统中的逻辑部件，缺乏“可见性”，因此管理和控制软 件开发过程相当困难 ② 软件维护通常意味着改正或修改原来的设计，因此软件较难维护 ③ 软件规模庞大，而程序复杂性将随着程序规模的增加而呈指数上升 （2）主观原因 ① 存在与软件开发和维护有关的许多错误认识和做法 ② 对用户要求没有完整准确的认识就匆忙着手编写程序 ③ 开发人员只重视程序而忽视软件配置的其余成分（文档和数据等） ④ 软件开发人员轻视维护 软件工程 采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考 验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来， 以经济地开发出高质量的软件并有效地维护它\n软件工程七条基本原理 1.用分阶段的生命周期计划严格管理 2.坚持进行阶段评审 3.实行严格的产品控制 4.采用现代程序设计技术 5.结果应能清楚地审查 6.开发小组的人员应该少而精 7.承认不断改进软件工程实践的必要性 软件工程方法学 技术方法的集合称为方法学（范型）。分为传统方法学和面向对象方法学 软件工程方法学包括3个要素：方法、工具和过程 传统方法学（生命周期方法学或结构化范型） 优点 把软件生命周期划分成若干相对独立、简单的阶段，便于不同人员分工协作，降低开发的困难程度 开发过程中采用科学的管理技术和良好的技术方法，且在每个阶段结束之前都进行严格的审查，保证了软件的质量，提高了软件的可维护性 大大提高了软件开发的成功率和生产率 缺点 不适用于软件规模庞大、或者对软件的需求是模糊的或会随时间变化而变化的情况 结构化范型技术把数据和操作人为地分离成两个独立的部分，增加了软件开发与维护的难度\n面向对象方法学 与传统方法学的对比 a．传统方法学强调自顶向下、逐层分解、顺序开发 b．面向对象方法学强调主动地多次反复迭代地开发，保证了在各项开发活动之间的平滑过渡 优点 a．降低了软件产品的复杂性 b．提高了软件的可理解性 c．简化了软件的开发和维护工作 d．提高了软件的可重用性\n软件过程 定义：获得高质量软件所需要完成的一系列任务的框架 表示：生命周期模型 瀑布模型的特点: 1.阶段间具有顺序性和依赖性。 2.推迟实 现的观点。3.质量保证的观点。 快速原型 是快速建立起来的可以在计算机上运行的程序，它 所能完成的功能往往是最终产品能完成功能的一个子集。 增量模型: 它分批地逐步向用户提交产品，整个软件产品被分 解成许多个增量构件，开发人员一个构件一个构件地向用户 提交产品。 螺旋模型; 基本思想是使用原型及其他方法来尽量降低风险。 理解这种模型的一个简单方法，是把它看作在每个阶段之前 都增加了风险分析过程的快速原型模型。 (使用于内部开发 的大规模软件项目 ) 喷泉模型: 强调的是“迭代”和“无缝“的特性 是典型的面 向对象的软件过程模型之一. 软件周期 1.问题定义: 必须回答的关键问题是， “要解决的问题是什么? ”。 2.可行性研究: 阶段回答的关键问题是: “对于上一个阶段所确定的问题有行得通的解决办法吗? ” 3.需求分析: “目标系统必须做什么”，确定目标系统必须具备哪些功能。 4.总体设计: 必须回答的关键问题是: “概括地说，应该怎样实现目标系统? ”总体设计又称为概要设计。 5.详细设计: 关键问题是: “应该怎样具体地实现这个系统呢? ” 6.编码和单元测试: 关键任务是写出正确的容易理解、容易维护的程序模块。 7.综合测试: 关键任务是通过各种类型的测试使软件达到预定的要求。 8.软件维护: 通过各种必要的维护活动使系统持久地满足用户的需要。 可行性研究 可行性研究的任务 可行性研究方面 1.技术可行性 2.经济可行性 3.操作可行性 可行性研究过程 1.复查系统规模和目标； 2.研究目前正在使用的系统； 3.导出新系统的高层逻辑模型； 4.进一步定义问题； 5.导出并评价供选择的解法； 6.推荐行动方针； 7.草拟开发计划； 8书写文档提交审查。 系统流程图 描绘物理系统，表达的是数据在系统各部件之间流动的情况 数据流图 描绘数据在软件中流动和被处理的逻辑过程，表示系统逻辑模型，是功能模型 矩形：数据的源点/终点 圆角：数据处理 开口：数据存储 箭头：数据流 数据字典 标识符 = 字母字符 + 字母数字串 字母数字串 = 0{字母或数字}7 字母或数字 = [字母字符 | 数字字符] 成本/效益分析 目的：帮助客户组织负责人从经济角度判断是否继续投资于这项工程。 方法： 代码行技术； 任务分解技术 自动估计成本技术 需求分析 需求分析中的三种模型： 数据模型（E-R 图） 功能模型（数据流图） 行为模型（状态转换图） 实体-联系图 包括实体（数据对象）、关系和属性3种基本成分 矩形-\u003e实体 菱形-\u003e关系 圆角-\u003e属性 状态转换图 初态-\u003e实心圆 终态-\u003e空心包实心圆 中间-\u003e圆角 其他图形工具 1.层次方框图（数据层次结构） 2.Warnier图 3.IPO图 总体设计 设计原理 模块化 模块独立（低耦合与高内聚） 抽象 逐步求精 信息隐藏和局部化 描绘软件结构的图形工具 1.层次图 2.HIPO图 3.结构图 面向数据流的设计方法 1.变换流 2.事务流 详细设计 结构程序设计 结构化程序：仅顺序、选择和循环，且单入单出的程序 人机界面设计 过程设计 1.程序流程图（程序框图） 2.盒图（N-S图） 3.PAD图（问题分析图） 4.判定表 5.判断树 6.过程设计语言（PDL，伪码） PAD图\n面向数据结构的设计方法 程序复杂程度的定量度量价值 环形复杂度（McCabe方法）： V(G)=区域数 V(G)=E-N+2（E:edge N:node） V(G)=P+1（P是判断节点数） 实现（编码、单元测试、综合测试） 测试 软件测试的定义 测试是为了发现程序中的错误而执行程序的过程。 软件测试的目标 好的测试方案是尽可能发现迄今为止尚未发现的错误的测试方案 成功的测试是发现了至今为止尚未发现的错误的测试 根本目标是尽可能多地发现并排除软件中潜藏的错误，最终把一个高质量的软件系统交给用户使用 测试方法：白盒测试和黑盒测试 测试步骤： 单元测试（模块测试）：测试模块，发现编码和详细设计的错误 子系统测试：测试模块接口 系统测试：发现软件设计中和需求说明中的错误 验收测试（确认测试）：发现系统需求说明书中的错误 白盒测试 1.语句覆盖：一个if要一个测试用例 2.判断覆盖：一个if要两个测试用例 3.条件覆盖：每个条件取值至少出现一次 4.判断/条件覆盖： 5.条件组合覆盖：每个判定表达式中条件的各种可能组合都至少出现一次. 6.路径覆盖：所有节点路径数的乘积 黑盒测试 1.等价划分 2.边界值分析 3.错误推测 集成测试 底驱顶根：自顶向下需要存根程序，自底向上需要驱动程序 确认测试 Alpha测试：开发者场所，受控 Beta测试：客户场所，不受控 面向对象 面向对象建模\n对象模型： 动态模型： 功能模型： 在UML图中： 对象模型：类图 动态模型：状态图和事件追踪图 功能模型：用例图 类图\n泛化（继承）：空心三角和实线 聚合：空心菱形 组合：实心菱形 设计准则 软件重用 重用也称为再用或复用，是指同一事物不经修改或稍加改动就多次重复使用 重用级别： 代码重用 设计结果重用 分析结果重用 类构件的重用方式： 实例重用 继承重用 多态重用 设计优化 确认优先级 提高效率的几项技术 增加冗余关联以提高访问效率 调整查询次序 保留派生属性 调整继承关系 设计类继承的方法 为提高继承程度而修改类定义 利用委托实现操作共享 程序设计风格 1.提高可重用性 （1）提高方法的内聚 （2）减小方法的规模 （3）保持方法的一致性 （4）把策略与实现分开 （5）全面覆盖输入条件的各种可能组合 （6）尽量不使用全局信息 （7）充分利用继承机制 2.提高可扩充性 提高可重用性的准则同样也能提高程序的可扩充性 （1）封装类的实现细节 （2）不要用一个方法遍历多条关联链。 （3）避免使用多分支语句 （4）精心选择和定义公有方法 3.提高健壮性 （1）预防用户的错误操作 （2）检查参数的合法性 （3）不要预先设定数据结构的限制条件 （4）先测试后优化 设计测试用例 测试类 随机测试 划分测试 基于故障测试 集成测试 多类测试：随机测试和划分测试 从动态模型导出测试用例 软件项目管理 软件项目管理就是通过计划、组织和控制等一系列活动，合理地配置 和使用各种资源，以达到既定目标的过程。\n计划：估计软件规模，工作量估算，进度计划 组织：民主制程序员组，主程序员组，现代程序员组 控制：质量保证，配置管理\n大纲 一、软件工程概述 软件生命周期、软件过程 二、需求分析 需求分析的任务、建模和规格说明、UML（类图、状态 图、顺序图、活动图) 三、总体设计 设计原理、启发规则、面向数据流的设计方法、 四、详细设计和实现 过程设计工具、面向数据结构的设计方法、程序复杂度的度量、编码、软件测试基础、单元测试、集成测试、白盒测试、黑盒测试 五、面向对象分析、設計和实现 面向对象分析过程、对象模型、动态模型、功能模型 面向对象设计准则、软件重用、设计优化、程序设计风格、设计测试用例 六、软件项目管理 工作量估算、进度计划、质量保证、软件配置 title: 神经网络 神经元 一个神经元的功能是求得输入向量与权向量的内积后加偏置，经一个非线性传递函数得到一个标量结果。— title: 原来这就是网络 原文：https://www.cnblogs.com/flashsun/p/14266148.html\n家庭网络 分组交换：在通信过程中，通信双方以分组为单位、使用存储-转发机制实现数据交互的通信方式\n分组：由一块用户数据和必要的地址和管理信息组成，保证网络能够将数据传递到目标。类似于从邮局发送的包裹上注明的地址一样,只有提供给网络这些信息，网络（邮局）才能把分组（包裹）往正确的地址传送 title: vim 动词\nd # 表示删除delete r # 表示替换replace c # 表示修改change y # 表示复制yank v # 表示选取visual select 名词\nw # 表示一个单词word s # 表示一个句子sentence p # 表示一个段落paragraph t # 表示一个 HTML 标签tag 介词\ni # 表示在...之内 inside a # 表示环绕... around t # 表示到...位置前 to f # 表示到...位置上 forward 动词+介词+名词\ndiw di{ title: shell Bash 参数拓展 删除前缀后缀\necho $str\t# a.b.c.d echo ${str%.*}\t# a.b.c echo ${str%%.*}\t# a echo ${str#*.}\t#b.c.d echo ${str##*.}\t#d sed #删除 sed '/^$/d' title: linux命令 tar 解压tar -xvf filename\n压缩tar -zcvf filename.tar.gz filename— title: 可行性研究 复习笔记\n一、可行性研究的任务 1 可行性研究的目的 用最小的代价在尽可能短的时间内确定问题是否能够解决。 2 可行性研究的任务 （1）对以后的行动方针提出建议。 （2）分析几种主要的候选解法的利弊，研究其可行性。 3 可行性研究的3个方面 （1）技术可行性； （2）经济可行性； （3）操作可行性。\n二、可行性研究过程典型的可行性研究过程为： 1．复查系统规模和目标； 2．研究目前正在使用的系统； 3．导出新系统的高层逻辑模型； 4．进一步定义问题； 5．导出并评价供选择的解法； 6．推荐行动方针； 7．草拟开发计划； 8．书写文档提交审查。\n三、系统流程图 1 定义 系统流程图是概括地描绘物理系统的传统工具。 2 基本思想 用图形符号以黑盒子形式描绘组成系统的每个部件（程序、文档、数据 库、人工过程等）。 【注意】系统流程图表达的是数据在系统各部件之间流动的情况，而不 是对数据进行加工处理的控制过程。3 符号 （1）以概括的方式抽象地描绘实际系统时，使用图2-1中列出的基本符 号就足够了。 图2-1 基本符号 【注意】这5种基本符号是常考点。 （2）需要更具体地描绘一个物理系统时，还需要使用图2-2中列出的系 统符号。图2-2 系统符号 【注意】系统流程图的习惯画法是使信息在图中从顶向下或从左向右流 动。\n四、数据流图 1 概念 （1）定义 数据流图（DFD）是一种图形化技术。它描绘信息流和数据从输入移动到输出的过程中所经受的变换。 （2）特点 ① 数据流图中没有具体的物理部件，只是描绘数据在软件中流动和被处 理的逻辑过程。 ② 数据流图是系统逻辑功能的图形表示，是分析员与用户之间极好的通 信工具。 ③ 设计时只需考虑系统必须完成的基本逻辑功能，不考虑怎样具体地实 现这些功能。 2 符号 如图2-3（a）所示，数据流图有4种基本符号；图2-3（b）给出了附加符 号的含义。其中星号（*）表示数据流之间是“与”关系；加号（＋）表 示“或”关系；⊕号表示只能从中选一个（互斥的关系）。图2-3 数据流图的符号 【注意】数据流中用箭头表示数据流，第5章的程序流程图中用箭头表示 的控制流。\n五、数据字典概念 （1）定义 数据字典是关于数据的信息的集合，是对数据流图中包含的所有元素的 定义的集合。 （2）意义 数据流图和数据字典共同构成系统的逻辑模型。 2 组成元素 ① 数据流； ② 数据流分量，即数据元素； ③ 数据存储； ④ 处理。 3 数据字典的用途 （1）作为分析阶段的工具（最重要）。 （2）数据字典中包含的每个数据元素的控制信息是很有价值的。 （3）数据字典是开发数据库的第一步，而且是很有价值的一步。4 数据字典的实现 （1）开发大型软件系统时建议使用数据字典处理程序。 （2）在开发小型软件系统时建议采用卡片形式书写数据字典 数据字典卡片\n六、成本/效益分析 1 目的 帮助客户组织负责人从经济角度判断是否继续投资于这项工程。2 成本估计的方法 （1）代码行技术； （2）任务分解技术； （3）自动估计成本技术。 3 重要公式 （1）计算P元钱在n年后的价值：F=P(1+i)n，其中年利率为i。 （2）n年后能收入F元钱，计算这些钱的现在价值：P=F/(1+i)n。 （3）计算投资回收率： P=F1/(1+j)+F2/(1+j)2+…+Fn/(1+j)n 其中，P是现在的投资额；Fi是第i年年底的效益（i＝1，2，…，n）；n 是系统的使用寿命；j是投资回收率。— title: 详细设计 复习笔记\n一、结构程序设计 详细设计不仅仅是逻辑上正确地实现每个模块的功能，更重要的是设计 出的处理过程应该尽可能简明易懂。结构程序设计技术是实现详细设计 目标的关键技术，也是详细设计的逻辑基础。 1．经典定义 如果一个程序的代码块仅仅通过顺序、选择和循环这3种基本控制结构 进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是 结构化的。 2．控制结构 （1）基本控制结构 三种基本的控制结构是“顺序”“选择”和“循环”，它们的流程图分别为图 6-1（a），6-1（b）和6-1（c）。图6-1 三种基本的控制结构 【注意】牢记三种基本控制结构，此为常考内容。 （2）扩展的控制结构 DO UNTIL和DO CASE的流程图分别是图6-2（a）和图6-2（b）。 图6-2 其他常用的控制结构\n三、人机界面设计 1 重要性 （1）对于交互式系统来说，人机界面设计和数据设计、体系结构设计及 过程设计一样重要。 （2）人机界面的质量直接影响用户对软件产品的接受程度。 2 设计问题 （1）系统响应时间； （2）用户帮助设施； （3）出错信息处理； （4）命令交互。 3 设计过程 用户界面设计是一个迭代的过程，也就是说，通常先创建设计模型，再 用原型实现这个设计模型，并由用户试用和评估，然后根据用户意见进 行修改。\n四、过程设计的工具 1 程序流程图（程序框图）（1）符号表示 程序流程图中使用的符号表示如图6-3所示。 图6-3 程序流程图中使用的符号 符号含义：（a）选择（分支）；（b）注释；（c）预先定义的处理； （d）多分支；（e）开始或停止；（f）准备； （g）循环上界限；（h）循环下界限；（i）虚线；（j）省略符；（k） 并行方式；（l）处理；（m）输入输出；（n）连接；（o）换页连接； （p）控制流。 （2）优点 对控制流程的描绘很直观，便于初学者掌握。 （3）缺点 ① 没遵循逐步求精的原则，它诱使程序员过早地考虑程序的控制流程， 而不去考虑程序的全局结构。② 程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以随 意转移控制。 ③ 程序流程图不易表示数据结构。 2 盒图（N-S图） （1）特点 ① 功能域明确； ② 不可能任意转移控制； ③ 很容易确定局部和全程数据的作用域； ④ 很容易表示嵌套关系，也可以表示模块的层次结构。 （2）表示 图6-4给出了结构化控制结构的盒图表示，也给出了调用子程序的盒图 表示方法。图6-4 盒图的基本符号 符号含义：（a）顺序结构；（b）IF_THEN_ELSE型分支；（c）CASE 型多分支；（d）循环结构；（e）调用子程序A。 （3）优点 ① 盒图没有箭头，因此不允许随意转移控制。 ② 盒图可以使程序员逐步养成用结构化的方式思考问题和解决问题的习 惯。 3 PAD图（问题分析图） （1）符号表示 PAD图用二维树形结构的图来表示程序的控制流，图6-5给出PAD图的 基本符号。图6-5 PAD图的基本符号 符号含义：（a）顺序（先执行P1后执行P2）；（b）选择（IF C THEN Pl ELSE P2）；（c）CASE型多分支；（d）WHILE型循环（WHILE C DO P）；（e）UNTIL型循环（REPEAT P UNTIL C）；（f）语句标 号；（g）定义。 （2）优点 ① 使用PAD符号所设计出来的程序必然是结构化程序。 ② PAD图所描绘的程序结构十分清晰。 ③ 用PAD图表现程序逻辑，易读、易懂、易记。 ④ 容易使用软件工具将PAD图自动转换成高级语言源程序，提高了软件可靠性和软件生产率。 ⑤ 即可用于表示程序逻辑，也可用于描绘数据结构。 ⑥ PAD图的符号支持自顶向下、逐步求精方法的使用。 【注意】PAD图中竖线的总条数就是程序的层次数。 4 判定表 （1）适用性 算法中包含多重嵌套的条件选择时使用判定表。 （2）组成 ① 左上部列出所有条件； ② 左下部是所有可能做的动作； ③ 右上部是表示各种条件组合的一个矩阵； ④ 右下部是和每种条件组合相对应的动作。 【注意】判定表右半部的每一列实质上是一条规则，规定了与特定的条 件组合相对应的动作。 5 过程设计语言 （1）定义过程设计语言（PDL），即伪码，它是用正文形式表示数据和处理过程 的设计工具。 （2）优点 ① 可作为注释直接插在源程序中，有助于保持文档和程序的一致性，提 高文档的质量。 ② 可以使用普通的正文编辑程序或文字处理系统，很方便地完成PDL的 书写和编辑工作。 ③ 已经有自动处理PDL的程序存在，且可以自动由PDL生成程序代码。 （3）缺点 不如图形工具形象直观，不如判定表清晰简单。\n五、面向数据结构的设计方法 1 Jackson图 （1）分类 Jackson图根据程序中数据元素彼此间的逻辑关系可分为顺序结构、选择 结构和重复结构3类，具体如下： ① 顺序结构 图6-6是表示顺序结构的Jackson图的一个例子。图6-6 A由B、C、D3个元素顺序组成 【注意】图中每个元素只出现一次，出现的次序依次是B、C和D。 ② 选择结构 图6-7是表示3个中选1个结构的Jackson图。 图6-7 根据条件A是B或C或D中的某一个 【注意】在B、C和D的右上角有小圆圈做标记。 ③ 重复结构 图6-8是表示重复结构的Jackson图。 图6-8 A由B出现N次（N≥0）组成【注意】在B的右上角有星号标记。 （2）优点 ① 便于表示层次结构，而且是对结构进行自顶向下分解的有力工具。 ② 形象直观可读性好。 ③ 既能表示数据结构也能表示程序结构。 （3）缺点 ① 图中无法表示选择条件或循环结束条件，影响了图的表达能力，也不 易直接把图翻译成程序。 ② 框间连线为斜线，不易在行式打印机上输出。 2 改进的Jackson图 （1）表示 图6-9中给出了改进的Jackson图。图6-9 改进的Jackson图 （a）顺序结构：B、C、D中任一个都不能是选择出现或重复出现的数据 元素。 （b）选择结构：S右面括号中的数字i是分支条件的编号。 （c）可选结构：A或者是元素B或者不出现。 （d）重复结构：循环结束条件的编号为i。 （2）与层次图的比较 ① 层次图中的一个方框代表一个模块；而Jackson图中一个方框并不代 表一个模块。 ② 层次图表现的是调用关系；而Jackson图表现的是组成关系。\n六、程序复杂程度的定量度量价值 2 McCabe方法 （1）流图 ① 定义 流图实质上是“退化了的”程序流程图，它仅仅描绘程序的控制流程，完 全不表现对数据具体操作以及分支或循环的具体条件。 ② 程序流程图映射成流图 图6-10说明了把程序流程图映射成流图的方法。图6-10 把程序流程图映射成流图 a．流图中用圆表示结点，一个圆代表一条或多条语句。程序流程图中 的一个顺序的处理框序列和一个菱形判定框，可以映射成流图中的一个结点。 b．流图中的箭头线称为边，代表控制流。流图中一条边必须终止于一 个结点，即使这个结点并不代表任何语句。 c．由边和结点围成的面积称为区域，计算区域数时应包括图外部未被 围起来的区域。 ③ PDL翻译成流图 a．基本情况 图6-11是用PDL表示的处理过程及与之对应的流图。图6-11 由PDL翻译成的流图 b．包含复合条件 复合条件，就是在条件中包含了一个或多个布尔运算符。图6-12是由包 含复合条件的PDL片段翻译成的流图。 图6-12 由包含复合条件的PDL映射成的流图 （2）环形复杂度 ① 定义 McCabe方法根据程序控制流的复杂程度定量度量程序的复杂程度，度 量出的结果称为程序的环形复杂度。② 计算方法 环形复杂度定量度量程序的逻辑复杂度，可以用下述3种方法中的任何 一种来计算环形复杂度： a．流图中线性无关的区域数等于环形复杂度。 b．流图G的环形复杂度V(G)=E-N+2，其中，E是流图中边的条数，N是 结点数。 c．流图G的环形复杂度V(G)=P+1，其中，P是流图中判定结点的数目。 3 Halstead方法 （1）定义 Halstead方法是根据程序中运算符和操作数的总数来度量程序的复杂程 度。 （2）方法 ① 程序长度N定义（N1为程序中运算符出现的总次数，N2为操作数出现 的总次数）：N=N1+N2； ② 预测程序长度的公式（使用的不同运算符的个数n1，不同操作数的个 数n2）：H=n1log2n1+n2log2n2； ③ 预测程序中包含错误的个数的公式：E=Nlog2(n1+n2)/3000。6.2 课后习题— title: 软件维护 复习笔记\n一、软件维护的定义 软件工程的主要目的就是要提高软件的可维护性，减少软件维护所需要 的工作量，降低软件系统的总成本。 1．定义 软件维护是在软件已经交付使用后，为了改正错误或满足新的需要而修 改软件的过程。 2．分类 （1）改正性维护； （2）适应性维护； （3）完善性维护； （4）预防性维护。\n二、软件维护的特点 1 结构化维护与非结构化维护差别巨大2 维护的代价高昂 软件维护中无形的代价有： （1）软件维护的费用高昂。 （2）因为可用的资源必须供维护任务使用，以致耽误甚至丧失了开发的 良机。 （3）生产率的大幅度下降。 3 维护的问题 （1）理解别人写的程序非常困难，而且困难程度随着软件配置成分的减 少而迅速增加。 （2）需要维护的软件往往没有合格的文档，或者文档资料显著不足。 （3）当要求对软件进行维护时，不能指望由开发人员给人们仔细说明软 件。 （4）绝大多数软件在设计时没有考虑将来的修改。 （5）软件维护不是一项吸引人的工作。\n三、软件维护过程 1 定义 维护过程本质上是修改和压缩了的软件定义和开发过程。2 具体过程 （1）维护组织； （2）维护报告； （3）维护的事件流； 图8-1 （4）保存维护记录； （5）评价维护活动。\n四、软件的可维护性 维护阶段的事件流1 定义 可维护性指的是维护人员理解、改正、改动或改进这个软件的难易程 度。 2 决定软件可维护性的因素 （1）可理解性； （2）可测试性； （3）可修改性； （4）可移植性； （5）可重用性。 3 文档 （1）重要性 文档是影响软件可维护性的决定因素，文档比程序代码更重要。 （2）分类 软件系统的文档可以分为用户文档和系统文档两类。\n五、预防性维护 定义 预防性维护指的是把今天的方法学应用到昨天的系统上，以支持明天的 需求。 2 实质 预防性维护实质上是软件再工程。\n六、软件再工程过程 1 典型软件再工程模型 典型的软件再工程过程模型如图8-2所示。图8-2 软件再工程过程模型 【注意】在某些情况下这些活动以线性顺序发生，但也并非总是这样。 2 六类活动 （1）库存目录分析； （2）文档重构； （3）逆向工程； （4）代码重构； （5）数据重构； （6）正向工程。— title: 8 复习笔记\n一、面向对象方法学概述 1 要点 （1）定义 面向对象方法是一种以数据或信息为主线，把数据和处理相结合的方 法。 （2）要点 ① 对象； ② 类； ③ 继承性； ④ 封装性。 【注意】考生需理解四个要点各自的含义。 2 面向对象方法学的优点 （1）与人类习惯的思维方法一致；（2）稳定性好； （3）可重用性好； （4）较易开发大型软件产品； （5）可维护性好。\n二、面向对象的概念 1 对象 （1）对象的定义 ① 面向对象程序设计的角度：对象是具有相同状态的一组操作的集合。 ② 结构化的角度：对象是封装了数据结构及可以施加在这些数据结构上 的操作的封装体。 （2）对象的特点 ① 以数据为中心； ② 对象是主动的； ③ 实现了数据封装； ④ 具有并行性； ⑤ 模块独立性好。2 其他概念 （1）类 类是对具有相同数据和相同操作的一组相似对象的定义。 （2）实例 实例就是由某个特定的类所描述的一个具体的对象。 【注意】类是对象的抽象，对象是类的实例。 （3）消息 ① 定义：消息就是要求某个对象执行在定义它的那个类中所定义的某个 操作的规格说明。 ② 组成：一个消息由接收消息的对象、消息选择符、零个或多个变元组 成。 （4）方法 方法就是对象所能执行的操作，也就是类中所定义的服务。 （5）属性 属性就是类中所定义的数据，它是对客观世界实体所具有的性质的抽 象。 （6）封装 封装是把数据和实现操作的代码集中起来放在对象内部。（7）继承 ① 定义 继承是子类自动地共享基类中定义的数据和方法的机制。 ② 特点 a．继承具有传递性； b．低层的性质将屏蔽高层的同名性质。 ③ 分类 a．单继承：一个类只允许有一个父类，即类等级为树形结构。 b．多重继承：允许一个类有多个父类。 （8）多态性 ① 定义 多态性指在类等级的不同层次中可以共享一个方法的名字，不同层次中 的每个类各自按自己的需要来实现这个行为。 【注意】在C++中，多态性是通过虚函数来实现的。 ② 动态联编 在运行时刻根据接收消息的对象所属于的类，决定执行哪个特定版本的 函数，这称为动态联编（滞后联编）。 ③ 优点a．增加了面向对象软件系统的灵活性，进一步减少了信息冗余。 b．显著提高了软件的可重用性和可扩充性。 （9）重载 ① 分类 a．函数重载 在同一作用域内的若干个参数特征不同的函数可以使用相同的函数名 字。 【注意】常考点：重载函数的形式参数（指参数的个数或者类型或者顺 序）必须不同，而与函数返回值类型无关。 b．运算符重载 同一个运算符可以施加于不同类型的操作数上面。 ② 实现 a．函数重载是通过静态联编（先前联编）实现的。 b．运算符重载是在编译时根据被操作数的类型，决定使用该算符的哪 种语义。 ③ 优点 进一步提高了面向对象系统的灵活性和可读性。\n三、面向对象建模 模型 （1）定义 模型是为了理解事物而对事物作出的一种抽象，是对事物的一种无歧义 的书面描述。 （2）作用 ① 是一种思考工具，利用这种工具可以把知识规范地表示出来。 ② 可以帮助人们思考问题、定义术语、在选择术语时作出适当的假设， 并且有助于保持定义和假设的一致性。 2 模型分类 （1）对象模型：描述系统数据结构。 （2）动态模型：描述系统控制结构。 （3）功能模型：描述系统功能。\n四、对象模型 1 概念 （1）定义 它是对模拟客观世界实体的对象以及对象彼此间的关系的映射，描述了 系统的静态结构。【注意】对象模型表示静态的、结构化的系统的数据性质。 （2）工具 使用UML提供的类图来建立对象模型。 2 类图的基本符号 类图描述类及类与类之间的静态关系。类图是一种静态模型，它是创建 其他UML图的基础。 （1）类 UML中类的图形符号为长方形，用两条横线把长方形分为上、中、下3 个区域，3个区域分别放类的名字、属性和服务，如图9-1所示。 图9-1 表示类的图形符号 【注意】类名应该是富于描述性的、简洁的而且无二义性的。 （2）属性 ① UML描述属性的语法格式为： 可见性 属性名：类型名＝初值{性质串} ② 属性的可见性分为公有的（＋）、私有的（－）和保护的（#），没 有默认的可见性。（3）服务 ① 服务也就是操作，UML描述操作的语法格式为： 可见性 操作名（参数表）：返回值类型{性质串} ② 操作的可见性分为公有的（＋）、私有的（－）和保护的（#），没 有默认的可见性。 ③ 参数表中描述一个参数的语法为：参数名：类型名＝默认值 3 表示关系的符号 类与类之间通常有关联、泛化（继承）、依赖和细化4种关系。 （1）关联 ① 定义 关联表示两个类的对象之间存在某种语义上的联系。 ② 普通关联 a．定义 只要在类与类之间存在连接关系就可以用普通关联表示。 b．表示 第一，普通关联的图示符号是连接两个类之间的直线。 第二，关联是双向的，可为关联起一个名字。在名字前面（或后面）加一个表示关联方向的黑三角。 第三，在表示关联的直线两端可以写上重数。 ③ 限定关联 a．定义 限定关联用在一对多或多对多的关联关系中，可以把重数从一对多变成 一对一，或从多对多简化成多对一。 b．表示 在类图中把限定词放在关联关系末端的一个小方框内。 ④ 关联类 a．定义 为了说明关联的性质，可能需要一些附加信息。关联类可以用来记录相 关信息。 b．表示 关联中的每个连接与关联类的一个对象相联系。关联类通过一条虚线与 关联连接。 （2）聚集 聚集（聚合）是关联的特例。表示类与类之间的关系是整体与部分的关 系。 ① 共享聚集a．定义 如果在聚集关系中处于部分方的对象可同时参与多个处于整体方对象的 构成，则该聚集称为共享聚集。 b．表示 在表示关联关系的直线末端紧挨着整体类的地方画一个空心菱形。 ② 组合聚集 a．定义 如果部分类完全隶属于整体类，部分与整体共存，整体不存在了部分也 会随之消失，则该聚集称为组合聚集。 b．表示 在表示关联关系的直线末端紧挨着整体类的地方画一个实心菱形。 （3）泛化 ① 定义 UML中的泛化关系就是继承关系，它是通用元素和具体元素之间的一 种分类关系。 ② 表示 在UML中，用一端为空心三角形的连线表示泛化关系，三角形的顶角 紧挨着通用元素。③ 分类 泛化关系包括普通泛化和受限泛化。 ④ 约束 预定义的约束有4种：多重、不相交、完全和不完全。 ⑤ 继承分类 分为多重继承、不相交继承、完全继承、不完全继承四类。 （4）依赖和细化 ① 依赖关系 a．定义 依赖关系描述两个模型元素之间的语义连接关系：其中一个模型元素是 独立的，另一个模型元素不是独立的，它依赖于独立的模型元素，如果 独立的模型元素改变了，将影响依赖于它的模型元素。 b．表示 在UML类图中用带箭头的虚线连接有依赖关系的两个类，箭头指向独 立的类。 ② 细化关系 a．定义 对同一个事物在不同抽象层次上描述时，这些描述之间具有细化关系。b．表示 细化的图示符号为由元素B指向元素A的一端为空心三角形的虚线。\n五、动态模型 1 概念 动态模型表示瞬时的、行为化的系统的控制性质，它规定了对象模型中 的对象的合法变化序列。 2 建模 每个类的动态行为用一张状态图来描绘，各个类的状态图通过共享事件 合并起来，从而构成系统的动态模型。\n六、功能模型 1 概念 （1）定义 功能模型表示变化的系统的功能性质，它指明了系统应该做什么。 （2）组成 功能模型由一组数据流图组成。 2 用例图在UML中把用用例图建立起来的系统模型称为用例模型。 （1）定义 用例模型描述的是外部行为者所理解的系统功能。用例模型的建立是系 统开发者和用户反复讨论的结果，它描述了开发者和用户对需求规格所 达成的共识。 （2）组成和表示 ① 系统，用方框表示。 ② 用例，用椭圆表示。 ③ 行为者，用线条人表示。 ④ 关系，用连线表示。 （3）关系的分类 UML用例之间主要有扩展和使用两种关系，它们是泛化关系的两种不 同形式。 ① 扩展关系 向一个用例中添加一些动作后构成了另一个用例，这两个用例之间的关 系就是扩展关系，后者继承前者的一些行为，通常把后者称为扩展用 例。 ② 使用关系 一个用例使用另一个用例时，这两个用例之间就构成了使用关系。七、3种模型之间的关系 1 针对每个类建立的动态模型，描述了类实例的生命周期或运行周 期。 2 状态转换驱使行为发生，这些行为在数据流图中被映射成处理，在 用例图中被映射成用例，它们同时与类图中的服务相对应。 3 功能模型中的处理对应于对象模型中的类所提供的服务。 4 数据流图中的数据存储，以及数据的源点/终点，通常是对象模型中 的对象。 5 数据流图中的数据流，往往是对象模型中对象的属性值，也可能是 整个对象。 6 用例图中的行为者，可能是对象模型中的对象。 7 功能模型中的处理可能产生动态模型中的事件。 8 对象模型描述了数据流图中的数据流、数据存储以及数据源点/终点的结构。9.2 课后习题— title: 9 复习笔记\n一、面向对象分析的基本过程 1 概述 （1）定义 面向对象分析，就是抽取和整理用户需求并建立问题域精确模型的过 程。 （2）过程 ① 分析陈述用户需求的文件； ② 深入理解用户需求，抽象出目标系统的本质属性； ③ 用模型准确地表示。 （3）目的 全面深入地理解问题域和用户的真实需求，建立问题域的精确模型。 2 3个子模型与5个层次 （1）3个模型面向对象建模得到的模型包含系统的三个要素，即 ① 静态结构（对象模型）； ② 交互次序（动态模型）； ③ 数据变换（功能模型）。 【注意】3种模型中，对象模型是最基本、最重要、最核心的。 （2）5个层次 复杂问题的对象模型由5个层次组成，如图10-1所示。 图10-1 复杂问题的对象模型的5个层次\n二、需求陈述 1 内容 （1）阐明“做什么”而不是“怎样做”。 （2）描述用户的需求而不是提出解决问题的方法。 （3）指出哪些是系统必要的性质，哪些是任选的性质。 （4）避免对设计策略施加过多的约束，不描述系统的内部结构。2 书写要点 （1）做到语法正确，慎重选用名词、动词、形容词和同义词。 （2）必须把需求与实现策略区分开。 （3）需求陈述可简可繁。 （4）避免出现具有二义性的、不完整的、不一致的内容。\n三、建立对象模型 1 先建立对象模型的原因 （1）静态数据结构对应用细节依赖较少，比较容易确定。 （2）当用户的需求变化时，静态数据结构相对来说比较稳定。 2 信息来源 需求陈述、应用领域的专业知识、客观世界的常识是建立对象模型时的 主要信息来源。 3 建立对象模型的步骤 （1）确定类与对象。 ① 找出候选的类与对象；② 筛选出正确的类与对象。 （2）确定关联。 【注意】在分析确定关联的过程中，不必花过多的精力去区分关联和聚 集，聚集是一种特殊的关联。 （3）划分主题。 （4）确定属性。 （5）识别继承关系。 （6）反复修改。\n四、建立动态模型 1 概念 （1）适用性 ① 对于仅存储静态数据的系统来说，动态模型并没有什么意义。 ② 在开发交互式系统时，动态模型起着很重要的作用。 ③ 应用系统的主要工作是收集输入信息时，建立正确的动态模型是至关 重要的。 （2）步骤 ① 编写典型交互行为的脚本。② 从脚本中提取出事件，确定触发每个事件的动作对象以及接受事件的 目标对象。 ③ 排列事件发生的次序，确定每个对象的状态及状态间的转换关系，用 状态图描绘。 ④ 比较各个对象的状态图，确保事件之间的匹配。 2 编写脚本 （1）定义 脚本是指系统在某一执行期间内出现的一系列事件。 （2）目的 编写脚本的目的是保证不遗漏重要的交互步骤，有助于确保交互过程的 正确性、清晰性。 3 设想用户界面 （1）重要性 用户界面的好坏往往对用户是否喜欢、是否接受一个系统起很重要的作 用。 （2）目的 确保能够完成全部必要的信息交换，而不会丢失重要的信息。【注意】当前阶段重要的是在界面下的信息交换方式，而不是用户界面 的细节。 4 画事件跟踪图 （1）一条竖线代表一个对象； （2）每个事件用一条水平的箭头线表示； （3）箭头方向从事件的发送对象指向接受对象； （4）时间从上向下递增； （5）用箭头线在垂直方向上的相对位置表示事件发生的先后，不表示事 件间的时间差。 5 画状态图 （1）定义 状态图描绘事件与对象状态的关系，它确定了由事件序列引出的状态序 列。 （2）方法 ① 仅考虑事件跟踪图中指向某条竖线的那些箭头线。把这些事件作为状 态图中的有向边，边上标以事件名。 ② 给每个状态取个有意义的名字。③ 根据一张事件跟踪图画出状态图后，再把其他脚本的事件跟踪图合并 到该图中。 ④ 考虑完正常事件后再考虑边界情况和特殊情况，包括在不适当时候发 生的事件。\n五、建立功能模型 1 画出基本系统模型图 基本的系统模型有下述两部分组成： （1）数据源点/终点 数据源点输入的数据和输出到数据终点的数据，是系统与外部世界间交 互事件的参数。 （2）处理框 处理框代表了系统加工、变换数据的整体功能。 2 画出功能级数据流图 把基本系统模型中单一的处理框分解成若干个处理框，以描述系统加 工、变换数据的基本功能，就得到功能级数据流图。 3 描述处理框功能 （1）要点着重描述每个处理框所代表的功能，而不是实现功能的具体算法。 （2）描述分类 ① 说明性描述（更重要）； ② 过程性描述。 六、定义服务（略）10.2 课后习题— title: 10 复习笔记\n一、面向对象设计的准则 1 模块化 2 抽象 3 信息隐藏 在面向对象的软件中，信息隐藏通过对象的封装来实现，即类结构分离 了接口与实现，从而支持了信息隐藏。 4 弱耦合 一般而言，对象之间的耦合可分为两大类： （1）交互耦合 对象间的耦合通过消息连接来实现，则这种耦合是交互耦合。要使交互 耦合尽可能松散。 （2）继承耦合继承耦合的模块彼此之间应该结合得越紧密越好。 5 强内聚 在面向对象设计中存在下述3种内聚： （1）服务内聚； （2）类内聚； （3）一般-特殊内聚。 6 可重用 重用有两方面的含义： ① 尽量使用已有的类。 ② 如果需要创建新类，则在设计这些新类的协议时应该考虑将来的可重 复使用性。\n二、启发规则 1 设计结果应该清晰易懂 2 一般-特殊结构的深度应适当3 设计简单的类 4 使用简单的协议 5 使用简单的服务 6 把设计变动减至最小 图11-1 理想的设计变动情况 理想的设计变动曲线如图11-1所示。即在设计的早期阶段，变动较大， 随着时间推移，设计方案日趋成熟，改动也越来越小了。\n三、软件重用 1 概述（1）重用 重用也叫再用或复用，是指同一事物不作修改或稍加改动就多次重复使 用。软件重用可分为以下3个层次： ① 知识重用； ② 方法和标准的重用； ③ 软件成分的重用。 （2）软件成分的重用级别 ① 代码重用； ② 设计结果重用； ③ 分析结果重用。 （3）典型的可重用软件成分 ① 项目计划； ② 成本估计； ③ 体系结构； ④ 需求模型和规格说明； ⑤ 设计； ⑥ 源代码；⑦ 用户文档和技术文档； ⑧ 用户界面； ⑨ 数据； ⑩ 测试用例。 2 类构件 （1）可重用软构件的特点 ① 模块独立性强； ② 具有高度可塑性； ③ 接口清晰、简明、可靠。 （2）类构件的重用方式 ① 实例重用； ② 继承重用； ③ 多态重用。 3 软件重用的效益 （1）重用给软件产品的质量和可靠性带来实质性的提高。 （2）使生产率得到了提高。（3）节省了成本。 软件重用带来的净成本节省可以用下式估算：C＝Cs－Cr－Cd。其中， Cs是项目从头开发时所需要的成本；Cr是与重用相关联的成本；Cd是交 付给客户的软件的实际成本。\n四、系统分解 1 分解的思想 在设计比较复杂的应用系统时，先把系统分解成若干个较小部分，然后 分别设计每个部分。这样做有利于降低设计的难度，有利于分工协作， 也有利于维护人员对系统理解和维护。 2 子系统 （1）定义 系统的主要组成部分称为子系统，通常根据所提供的功能来划分子系 统。 （2）划分原则 ① 根据所提供的功能来划分子系统，子系统数目应该与系统规模基本匹 配。 ② 各个子系统之间应该具有尽可能简单、明确的接口。 ③ 应该尽量减少子系统彼此间的依赖性。3 分解面向对象设计模型 （1）表示 图11-2 典型的面向对象设计模型 典型的面向对象设计模型，如图11-2所示。 ① 面向对象设计模型由主题、类与对象、结构、属性、服务5个层次组 成。 ② 面向对象设计模型在逻辑上都由4大部分组成，分别对应于组成目标 系统的4个子系统，即问题域子系统、人机交互子系统、任务管理子系 统和数据管理子系统。 （2）子系统间交互方式 ① 客户-供应商关系（较好）； ② 平等伙伴关系。 【注意】单项交互比双向交互更容易理解，也更容易设计和修改，因此 应该尽量使用客户-供应商关系。 （3）组织系统的方案① （水平）层次组织； ② （垂直）块状组织； ③ 层次和块的组合； ④ 设计系统的拓扑结构。 典型的拓扑结构有管道形、树形、星形等。\n五、设计问题域子系统 1 概念 （1）面向对象分析所得出的问题域精确模型，为设计问题域子系统建立 了完整的框架。 （2）保持面向对象分析所建立的问题域结构。 （3）面向对象设计仅需从实现角度对问题域模型做一些补充或修改。 （4）问题域子系统过分复杂庞大时，应该把它进一步分解成若干个更小 的子系统。 2 对问题域模型进行的处理 （1）调整需求； （2）重用已有的类； （3）把问题域类组合在一起；（4）增添一般化类以建立协议； （5）调整继承层次。\n六、设计人机交互子系统 1 概念 （1）主要内容 设计人机交互子系统包括指定窗口和报表的形式、设计命令层次等内 容。 （2）重要性 人机界面设计得好，则会吸引用户，激发用户的创造力，提高工作效 率；人机界面设计得不好，使用户感到不方便、不习惯，甚至会产生厌 烦和恼怒的情绪。 2 设计策略 （1）分类用户； （2）描述用户； （3）设计命令层次； （4）设计人机交互类。\n七、设计任务管理子系统1 设计的必要性 （1）许多对象之间往往存在相互依赖关系。 （2）在实际使用的硬件中，可能仅由一个处理器支持多个对象。 2 设计步骤 （1）分析并发性。 （2）设计任务管理子系统。 ① 确定事件驱动型任务； ② 确定时钟驱动型任务； ③ 确定优先任务； ④ 确定关键任务； ⑤ 确定协调任务； ⑥ 尽量减少任务数； ⑦ 确定资源需求。\n八、设计数据管理子系统 1 概念 数据管理子系统是系统存储或检索对象的基本设施。2 选择数据存储管理模式 （1）文件管理系统 ① 优点 具有成本低和简单的优点。 ② 缺点 文件操作的级别低，为提供适当的抽象级别必须编写额外的代码，不同 操作系统的文件管理系统有明显差异。 （2）关系数据库管理系统 ① 理论基础 关系数据库管理系统的理论基础是关系代数。 ② 优点 a．理论基础坚实。 b．提供了各种最基本的数据管理功能，例如中断恢复，多用户共享， 多应用共享，完整性，事务支持等。 c．为多种应用提供了一致的接口。 d．标准化的语言。 ③ 缺点a．运行开销大。 b．不能满足高级应用的需求。 c．与程序设计语言的连接不自然。 （3）面向对象数据库管理系统 面向对象数据库管理系统主要有两种设计途径： ① 扩展的关系数据库管理系统； ② 扩展的面向对象程序设计语言。 3 设计数据管理子系统 （1）设计数据格式； （2）设计相应的服务。\n九、设计类中的服务 1 确定类中应有的服务 （1）确定服务的总体思想； （2）确定操作目标对象的启发规则； （3）确定处理归属的启发规则。2 设计实现服务的方法 （1）设计实现服务的算法； （2）选择数据结构； （3）算法与数据结构的关系； （4）定义内部类和内部操作。\n十、设计关联 1 确定实现关联的策略 （1）选定一个全局性的策略统一实现所有关联。 （2）分别为每个关联选择具体的实现策略，以与它在应用系统中的使用 方式相适应。 2 使用关联的方式 （1）关联的遍历 ① 单向遍历； ② 双向遍历。 （2）实现单向关联图11-3用指针实现单向关联 图11-4用指针实现双向关联 ① 关联的重数是一元的（如图11-3所示），则实现关联的指针是一个简 单指针。 ② 重数是多元的，则需要用一个指针集合实现关联（如图11-4所示）。 （3）实现双向关联图11-5 用对象实现关联 ① 只用属性实现一个方向的关联。 ② 两个方向的关联都用属性实现，如图11-4所示。 ③ 用独立的关联对象实现双向关联，如图11-5所示。 （4）关联对象的实现 ① 定义 用一个关联类来保存描述关联性质的信息，关联中的每个连接对应关联 类的一个对象。 ② 方法 a．对于一对一的关联，关联对象可以与参与关联的任一个对象合并。 b．对于一对多的关联，关联对象可以与多端对象合并。 c．对于多对多的关联，关联链的性质不可能只与一个参与关联的对象有关。\n十一、设计优化 1 确定优先级 2 提高效率的几项技术 （1）增加冗余关联以提高访问效率。 （2）调整查询次序。 （3）保留派生属性。 3 调整继承关系 （1）继承关系 继承关系能够为一个类族定义一个协议，并能在类之间实现代码共享以 减少冗余。 （2）建立类继承 ① 抽象与具体的持续演化； ② 为提高继承程度而修改类定义； ③ 利用委托实现行为共享。11.2 课后习题— title: 编码测试 复习笔记\n一、编码 一般将编码和测试统称为实现。 1．编码的定义 编码是把软件设计结果翻译成用程序设计语言书写的程序。 2．效率 效率主要指处理机时间和存储器容量两个方面。\n二、软件测试基础 1 软件测试的定义 测试是为了发现程序中的错误而执行程序的过程。 2 软件测试的目标 （1）好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案。 （2）成功的测试是发现了至今为止尚未发现的错误的测试。（3）根本目标是尽可能多地发现并排除软件中潜藏的错误，最终把一个 高质量的软件系统交给用户使用。 【注意】测试只能查找出程序中的错误，不能证明程序中没有错误。测 试的目标是发现错误，调试的任务是在测试的基础上去改正错误。 3 测试方法 （1）白盒测试 ① 白盒测试（结构测试）把程序看成装在一个透明的白盒子里，测试者 完全知道程序的结构和处理算法。 ② 按照程序内部的逻辑测试程序，检测程序中的主要执行通路是否都能 按预定要求正确工作。 （2）黑盒测试 ① 黑盒测试（功能测试）把程序看作一个黑盒子，完全不考虑程序的内 部结构和处理过程。 ② 黑盒测试是在程序接口进行的测试，只检查程序功能是否能按照规格 说明书的规定正常使用。 4 测试步骤 （1）单元测试（模块测试） ① 定义：单元测试把每个模块作为一个单独的实体来测试，检验其正确性。 ② 目的：保证每个模块作为一个单元能正确运行。 【注意】单元测试发现的是编码和详细设计的错误。 （2）子系统测试 ① 定义：子系统测试把经过单元测试的模块放在一起形成一个子系统来 测试。 ② 目的：着重测试模块的接口。 （3）系统测试 ① 定义：系统测试是把经过测试的子系统装配成一个完整的系统来测 试。 ② 目的：发现设计和编码的错误，并验证系统确实能提供需求说明书中 指定的功能。 【注意】子系统测试和系统测试都属于集成测试。 （4）验收测试（确认测试） ① 定义：在用户的参与下，把软件系统作为单一的实体，使用实际数据 进行测试。 ② 目的：验证系统确实能够满足用户的需要。 【注意】验收测试发现的是系统需求说明书中的错误。\n三、单元测试（模块 ） 单元测试主要使用白盒测试技术。 1．测试重点 （1）模块接口； （2）局部数据结构； （3）重要的执行通路； （4）出错处理通路； （5）边界条件。 2．测试方法 （1）代码审查； （2）计算机测试。 【注意】必须要为每个单元测试开发驱动软件和（或）存根软件。\n四、集成测试 1 概念 （1）方法分类 ① 非渐增式测试。② 渐增式测试。 （2）非渐增式测试的缺点 ① 把所有模块放在一起，测试者面对的情况十分复杂。 ② 在庞大的程序中诊断定位一个错误非常困难。 ③ 一旦改正一个错误之后，又会遇到新的错误，没有穷尽。 （3）渐增式测试的优点 ① 把程序划分成小段来构造和测试，比较容易定位和改正错误。 ② 对接口可以进行更彻底的测试。 ③ 可以使用系统化的测试方法。 2 渐增式测试的策略 （1）自顶向下集成 包含深度优先和宽度优先两种结合策略。 （2）自底向上集成 3 两种集成策略的比较 （1）自顶向下集成 ① 优点a．不需要测试驱动程序。 b．能够在测试阶段的早期实现并验证系统的主要功能。 c．能在早期发现上层模块的接口错误。 ② 缺点 a．需要存根程序，可能遇到与此相联系的测试困难。 b．低层关键模块中的错误发现较晚。 c．在早期不能充分展开人力。 （2）自底向上集成 ① 优点 a．不需要存根程序，不会遇到与存根程序相联系的测试困难。 b．能较早的发现低层关键模块的错误。 c．能在早期充分展开人力。 ② 缺点 a．需要测试驱动程序。 b．不能在测试阶段早期实现并验证系统的主要功能。 c．在早期不能发现上层模块的接口错误。4 其他集成测试策略 （1）改进的自顶向下测试方法； （2）混合法。 5 回归测试 （1）定义 回归测试是指重新执行已经做过的测试的某个子集，以保证上述这些变 化没有带来非预期的副作用。 （2）目的 保证由于调试或其他原因引起的变化，不会导致非预期的软件行为或额 外错误的测试活动。\n五、确认测试 1 确认测试通常使用黑盒测试法。 2 验收测试由最终用户而不是系统的开发者进行。 3 分为Alpha测试和Beta测试。\n六、白盒测试技术 逻辑覆盖 ① 语句覆盖 语句覆盖的含义是选择足够多的测试数据，使被测程序中每个语句至少 执行一次。 ② 判定覆盖（分支覆盖） 判定覆盖的含义是不仅每个语句必须至少执行一次，而且每个判定的每 种可能的结果都应该至少执行一次。 ③ 条件覆盖 条件覆盖的含义是不仅每个语句至少执行一次，而且使判定表达式中的 每个条件都取到各种可能的结果。 ④ 判定/条件覆盖 判定/条件覆盖的含义是不仅使得判定表达式中的每个条件都取到各种 可能的值，而且每个判定表达式也都取到各种可能的结果。它同时满足 判定覆盖和条件覆盖。 ⑤ 条件组合覆盖 条件组合覆盖要求选取足够多的测试数据，使得每个判定表达式中条件 的各种可能组合都至少出现一次。满足条件组合覆盖，也一定满足判定 覆盖、条件覆盖和判定/条件覆盖标准。 ⑥ 点覆盖 要求选取足够多的测试数据，使得程序执行路径至少经过流图的每个结点一次。 【注意】点覆盖标准和语句覆盖标准是相同的。 ⑦ 边覆盖 要求选取足够多测试数据，使程序执行路径至少经过流图中每条边一 次。 【注意】边覆盖与判定覆盖是相同的。 ⑧ 路径覆盖 路径覆盖含义是选取足够多测试数据，使程序的每条可能路径都至少执 行一次，如果程序图中有环，则要求每个环至少经过一次。 2 控制结构测试 （1）基本路径测试 【注意】某些独立路径不能以独立的方式测试，即程序的正常流程不能 形成独立执行该路径所需要的数据组合。 （2）条件测试 （3）循环测试 在结构化的程序中通常只有3种循环，即简单循环、串接循环和嵌套循 环。\n七、黑盒测试技术 1 等价划分 把程序的输入域划分成若干个数据类，选取每个等价类中的一个典型值或任意值作为测试数据。 2 边界值分析 确定边界情况，选取刚好等于、稍小于和稍大于等价类边界值的数据作为测试数据。 3 错误推测 利用判定表或判定树为工具，列出输入数据各种组合与程序应做的动作之间的对应关系，然后为判定表的每一列至少设计一个测试用例。\n八、调试 1 定义 调试是在测试发现错误之后排除错误的过程。 2 调试途径 （1）蛮干法。 （2）回溯法。 （3）原因排除法。 ① 对分查找法； ② 归纳法； ③ 演绎法。 【注意】考生务必注意测试和调试的区别。改错是调试的任务，测试的任务是发现错误。\n九、软件可靠性 基本概念 （1）软件可靠性 软件可靠性是程序在给定的时间间隔内，按照规格说明书的规定成功地 运行的概率。 （2）软件的可用性 软件可用性是程序在给定的时间点，按照规格说明书的规定，成功地运 行的概率。 （3）MTTF和MTTR ① 概念 a．平均维修时间MTTR 表示修复一个故障平均需要用的时间。 b．平均无故障时间MTTF 表示系统按规格说明书规定成功地运行的平均时间。 ② 计算公式 如果在一段时间内，软件系统故障停机时间分别为td1，td2，…，正常运 行时间分别为tu1，tu2，…，则系统的稳态可用性为： （7.1）其中： （7.1）式可以变成 （7.2） 2 估算平均无故障时间的方法 （1）符号 ① ET：测试之前程序中错误总数； ② IT：程序长度（机器指令总数）； ③ τ：测试（包括调试）时间； ④ Ed(τ)：在0至τ期间发现的错误数； ⑤ Ec(τ)：在0至τ期间改正的错误数。 （2）基本假定 ① 单位长度里的错误数ET/IT近似为常数。通常0.5×10-2≤ET/IT≤2×10-2。② 失效率正比于软件中潜藏的错误数，平均无故障时间MTTF与剩余的 错误数成反比。 ③ 假设发现的每一个错误都立即正确地改正了，即Ec(τ)=Ed(τ)。 a．剩余的错误数 （7.3） b．单位长度程序中剩余的错误数 （7.4） （3）估算平均无故障时间 ① 平均无故障时间与单位长度程序中剩余的错误数成反比（K经典值为 200），即 （7.5） ② 估算平均无故障时间的公式，可以评价软件测试进展情况。由 （7.5）式可得： （7.6） （4）估计错误总数的方法① 植入错误法 假设人为地植入的错误数为Ns，经过一段时间的测试之后发现ns个植入 的错误，还发现了n个原有的错误。则估计出程序中原有错误的总数 为： （7.7） 其中 即是错误总数ET的估计值。 ② 分别测试法 假定测试员乙发现有标记错误和发现无标记错误的概率相同，则可以估 计出测试前程序中的错误总数为： （7.8） 其中，测试员甲发现的错误数为B1，测试员乙发现的错误数为B2，两个 测试员发现的相同错误数为bc。7.2 课后习题— title: 11 复习笔记\n一、程序设计语言 面向对象实现需要把面向对象设计结果翻译成用某种程序语言书写的面 向对象程序，并对其测试和调试。 1 面向对象语言的优点 （1）一致的表示方法； （2）可重用性好； （3）可维护性好。 2 面向对象语言的技术特点 （1）支持类与对象概念的机制。 【注意】自动管理内存必须采用先进的垃圾收集算法才能减少开销。 （2）实现聚集结构的机制。 （3）实现泛化结构的机制。（4）实现属性和服务的机制。 （5）类型检查。 （6）提供类库。 （7）效率高。 （8）持久保存对象。 （9）参数化类。 （10）有良好的软件工具和软件工程环境。 3 选择面向对象语言的标准 （1）将来能否占主导地位。 （2）可重用性。 （3）类库和开发环境。 【注意】语言、开发环境和类库这3个因素综合起来，共同决定了可重用 性。 （4）其他因素。 ① 对用户学习面向对象分析、设计和编码技术所能提供的培训服务； ② 在使用这个面向对象语言期间能提供的技术支持； ③ 能提供给开发人员使用的开发工具、开发平台、发行平台；④ 对机器性能和内存的需求； ⑤ 集成已有软件的容易程度等。\n二、程序设计风格 1 概念 （1）良好的程序设计风格的重要性 ① 能明显减少维护或扩充的开销。 ② 有助于在新项目中重用已有的程序代码。 （2）良好的面向对象程序设计风格的内容 ① 传统的程序设计风格准则。 ② 为适应面向对象方法所特有的概念而必须遵循的一些新准则。 2 提高可重用性 （1）代码重用 ① 内部重用，即本项目内的代码重用。 ② 外部重用，即新项目重用旧项目的代码。 （2）实现代码重用的主要准则 ① 提高方法的内聚。② 减小方法的规模。 ③ 保持方法的一致性。 ④ 把策略与实现分开。 ⑤ 全面覆盖。 ⑥ 尽量不使用全局信息。 ⑦ 利用继承机制。 a．调用子过程： 图12-1 通过调用公用方法实现代码重用 b．分解因子： 图12-2 c．使用委托； d．把代码封装在类中。 通过因子分解实现代码重用3 提高可扩充性 提高可扩充行的主要准则为： （1）封装实现策略； （2）不要用一个方法遍历多条关联链； （3）避免使用多分支语句； （4）精心确定公有方法。 4 提高健壮性 （1）健壮性定义 健壮性是在硬件故障、输入的数据无效或操作错误等意外环境下，系统 能做出适当响应的程度。 （2）提高健壮性的主要准则 ① 预防用户的操作错误； ② 检查参数的合法性； ③ 不要预先确定限制条件； ④ 先测试后优化。\n三、测试策略1 经典的测试策略 测试软件的经典策略是，从“小型测试”开始，逐步过渡到“大型测试”。 可以分为以下三步： （1）单元测试； （2）集成测试； （3）确认测试、系统测试。 2 面向对象测试策略 （1）面向对象的单元测试 最小的可测试单元是封装起来的类和对象。测试面向对象软件时，不能 再孤立地测试单个操作，而应该把操作作为类的一部分来测试。 （2）面向对象的集成测试 ① 策略 a．基于线程的测试； b．基于使用的测试。 ② 集群测试 集群测试是面向对象软件集成测试的一个步骤。在这个测试步骤中，测 试用例力图发现协作错误。（3）面向对象的确认测试 ① 不再考虑类之间相互连接的细节。 ② 集中检查用户可见的动作和用户可识别的输出。 ③ 主要根据动态模型和描述系统行为的脚本来设计确认测试用例。 【注意】面向对象系统的确认测试也是面向黑盒的，基于情景的测试是 面向对象系统确认测试的主要方法。\n四、设计测试用例 1 测试类的方法 （1）随机测试； （2）划分测试； （3）基于故障的测试。 2 集成测试方法 （1）多类测试 ① 随机测试； ② 划分测试。 （2）从动态模型导出测试用例12.2 课后习题— title: 12 复习笔记 一、估算软件规模 软件项目管理先于任何技术活动之前开始，并且贯穿于软件的整个生命 周期之中，而制定计划的基础是工作量估算和完成期限估算。 1 代码行技术 （1）定义 代码行技术依据以往开发类似产品的经验和历史数据，估计实现一个功 能所需要的源程序行数。 （2）方法 ① 每名工程师估计程序的最小规模（a）、最大规模（b）和最可能的规 模（m），分别算出这3种规模的平均值后，再用下式计算程序规模的 估计值： （13.1） ② 程序较小时用的单位是代码行数（LOC）；程序较大时用的单位是千 行代码数（KLOC）。（3）优点 ① 代码是所有软件开发项目都有的“产品”，而且很容易计算代码行数。 ② 有以往开发类似产品的历史数据可参考时，估计出的数值比较准确。 （4）缺点 ① 源程序仅是软件配置的一个成分，用它的规模代表整个软件的规模不 太合理。 ② 用不同语言实现同一个软件所需要的代码行数并不相同。 ③ 不适用于非过程语言。 2 功能点技术 （1）特点 ① 功能点技术依据对软件信息域特性和软件复杂性的评估结果，估算软 件规模。 ② 以功能点（FP）为单位度量软件规模。 （2）信息域特性 ① 输入项数（Inp） ② 输出项数（Out） ③ 查询数（Inq）④ 主文件数（Maf） ⑤ 外部接口数（Inf） （3）估算功能点的步骤 ① 计算未调整的功能点数UFP 需记住公式： UFP＝a1×Inp＋a2×Out＋a3×Inq＋a4×Maf＋a5×Inf 其中，ai（1≤i≤5）是信息域特性系数，由相应特性的复杂级别决定，如 表13-1所示。 表13-1 信息域特性系数值 ② 计算技术复杂性因子TCF 在表13-2中列出了全部技术因素，并用Fi（1≤i≤14）代表这些因素。 表13-2 技术因素a．根据软件的特点，为每个因素分配一个从0到5的值。 b．用下式计算技术因素对软件规模的综合影响程度DI（0～70）： c．技术复杂性因子TCF（0.65～1.35）由下式计算：TCF＝0.65＋ 0.01×DI ③ 计算功能点数FP 用下式计算功能点数FP：FP＝UFP×TCF （4）功能点技术的优缺点 ① 优点：功能点数与所用的编程语言无关，比代码行技术更合理；② 缺点：在判断信息域特性复杂级别和技术因素的影响程度时，功能点 技术存在相当大的主观因素。 二、工作量估算 1 工作量概念 工作量是软件规模的函数，工作量的单位通常是人月（pm）。 2 静态单变量模型 （1）形式 静态单变量模型的总体结构形式如下： E=A+B×(eν)c 其中，A、B和C是由经验数据导出的常数，E是以人月为单位的工作 量，eν是估算变量（KLOC或FP）。 （2）分类 ① 面向KLOC的估算模型 a．Walston_Felix模型：E=5.2×(KLOC)0.91 b．Bailey_Basili模型：E=5.5+0.73×(KLOC)1.16 c．Boehm简单模型：E=3.2×(KLOC)1.05 d．Doty模型（KLOC\u003e9时适用）：E=5.288×(KLOC)1.047② 面向FP的估算模型 a．Albrecht \u0026 Gaffney模型：E=-13.39+0.0545FP b．Maston，Barnett和Mellichamp模型：E=585.7+15.12FP 3 动态多变量模型 ① 特点 动态多变量模型把工作量看作软件规模和开发时间这两个变量的函数。 ② 形式 动态多变量估算模型的形式如下： （13.2） 其中，E是以人月或人年为单位的工作量；t是以月或年为单位的项目持 续时间；B是特殊技术因子。 4 COCOMO2模型（构造性成本模型） （1）3层模型 ① 应用系统组成模型； ② 早期设计模型；③ 体系结构模型。 （2）形式 COCOMO2模型把软件开发工作量表示成代码行数（KLOC）的非线性 函数： （13.3） 其中：E是开发工作量（以人月为单位）；a是模型系数；KLOC是估计 的源代码行数（以千行为单位）；b是模型指数；fi（i＝1～17）是成本 因素。 （3）模型指数 COCOMO2采用了b分级模型，是使用5个分级因素Wi（1≤i≤5），其中 每个因素都划分成从甚低（Wi＝5）到特高（Wi＝0）的6个级别，用下 式计算b（1.01～1.26）的数值： （13.4） （4）COCOMO2的5个分级因素 ① 项目先例性； ② 开发灵活性； ③ 风险排除度；④ 项目组凝聚力； ⑤ 过程成熟度。 三、进度计划 1 相关概念 （1）一个有效的软件过程应该定义一个适用于当前项目的任务集合。 （2）一个任务集合包括一组软件工程工作任务、里程碑和可交付的产 品。 2 估算开发时间 （1）利用成本估算模型估算开发时间 ① Walston_Felix模型：T=2.5E0.35 ② 原始的COCOMO模型：T=2.5E0.38 ③ COCOMO2模型：T=3.0E0.33+0.2×(b-1.01) ④ Putnam模型T=2.4E1/3 其中，E是开发工作量（以人月为单位）；T是开发时间（以月为单 位）。 （2）项目组规模与项目组总生产率的关系 ① 通信路径项目组成员之间的通信路径数，由项目组人数和项目组结构决定。通信 路径数大约在P～P2/2的范围内变化。 ② 平均生产力 某一个组员与其他组员通信的路径数在1～（P-1）的范围内变化。如果 不与任何人通信时个人生产率为L，而且每条通信路径导致生产率减少 1，则组员个人平均生产率为：Lr=L-l(P-1)r，其中，r是对通信路径数的 度量，0","wordCount":"5709","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zcy2875634712.github.io/posts/note/%E6%A0%B8%E5%BF%83%E7%BA%B2%E8%A6%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},"publisher":{"@type":"Organization","name":"ybyb","logo":{"@type":"ImageObject","url":"https://zcy2875634712.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://zcy2875634712.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://zcy2875634712.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://zcy2875634712.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://zcy2875634712.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://github.com/zcy2875634712 title=github><span>github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://zcy2875634712.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://zcy2875634712.github.io/posts/>Posts</a></div><h1 class=post-title>核心纲要读书笔记</h1><div class=post-meta>27 min&nbsp;·&nbsp;5709 words&nbsp;·&nbsp;Me&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/note/%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#1-工具-1-工具1-工具><a href=#1-%E5%B7%A5%E5%85%B7 title="1 工具"></a>1 工具</a></li><li><a href=#2-软件工程文档-2-软件工程文档2-软件工程文档><a href=#2-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%96%87%E6%A1%A3 title="2 软件工程文档"></a>2 软件工程文档</a></li></ul><ul><li><a href=#补充-补充补充><a href=#%E8%A1%A5%E5%85%85 title=补充></a>补充</a></li></ul><ul><li><a href=#补充-1-补充补充><a href=#%E8%A1%A5%E5%85%85-1 title=补充></a>补充</a></li></ul><ul><li><a href=#补充-2-补充补充><a href=#%E8%A1%A5%E5%85%85-2 title=补充></a>补充</a></li></ul><ul><li><ul><li></li></ul></li><li><a href=#title-速查><a href=/tags/#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0 title=学习笔记>学习笔记</a>&mdash;
title: 速查</a></li><li><a href=#树>树</a><ul><li><a href=#树相关定义>树相关定义</a></li></ul></li><li><a href=#叶子度为零的节点>根节点：没有父节点
非根节点：只有一个父节点
节点的度：子树的数目
叶子：度为零的节点</a></li><li><a href=#title-复试问答>title: 复试问答</a></li><li><a href=#title-软件工程导论>title: 软件工程导论</a></li><li><a href=#title-软件工程笔记>title: 软件工程笔记</a><ul><li><a href=#软件危机>软件危机</a></li><li><a href=#软件工程>软件工程</a></li><li><a href=#传统方法学生命周期方法学或结构化范型>传统方法学（生命周期方法学或结构化范型）</a></li><li><a href=#面向对象方法学>面向对象方法学</a></li><li><a href=#软件过程>软件过程</a></li><li><a href=#软件周期>软件周期</a></li></ul></li><li><a href=#可行性研究>可行性研究</a><ul><li><a href=#可行性研究的任务>可行性研究的任务</a></li><li><a href=#系统流程图>系统流程图</a></li><li><a href=#数据流图>数据流图</a></li><li><a href=#数据字典>数据字典</a></li><li><a href=#成本效益分析>成本/效益分析</a></li></ul></li><li><a href=#需求分析>需求分析</a><ul><li><a href=#实体-联系图>实体-联系图</a></li><li><a href=#状态转换图>状态转换图</a></li><li><a href=#其他图形工具>其他图形工具</a></li></ul></li><li><a href=#总体设计>总体设计</a><ul><li><a href=#设计原理>设计原理</a></li><li><a href=#描绘软件结构的图形工具>描绘软件结构的图形工具</a></li><li><a href=#面向数据流的设计方法>面向数据流的设计方法</a></li></ul></li><li><a href=#详细设计>详细设计</a><ul><li><a href=#结构程序设计>结构程序设计</a></li><li><a href=#人机界面设计>人机界面设计</a></li><li><a href=#过程设计>过程设计</a></li><li><a href=#面向数据结构的设计方法>面向数据结构的设计方法</a></li><li><a href=#程序复杂程度的定量度量价值>程序复杂程度的定量度量价值</a></li></ul></li><li><a href=#实现编码单元测试综合测试>实现（编码、单元测试、综合测试）</a><ul><li><a href=#测试>测试</a></li><li><a href=#白盒测试>白盒测试</a></li><li><a href=#黑盒测试>黑盒测试</a></li><li><a href=#集成测试>集成测试</a></li><li><a href=#确认测试>确认测试</a></li></ul></li><li><a href=#面向对象>面向对象</a><ul><li><a href=#设计准则>设计准则</a></li><li><a href=#软件重用>软件重用</a></li><li><a href=#设计优化>设计优化</a></li><li><a href=#程序设计风格>程序设计风格</a></li><li><a href=#设计测试用例>设计测试用例</a></li></ul></li><li><a href=#软件项目管理>软件项目管理</a></li><li><a href=#大纲>大纲</a></li><li><a href=#title-神经网络>title: 神经网络</a><ul><li><a href=#神经元>神经元</a></li></ul></li><li><a href=#title-原来这就是网络>一个神经元的功能是求得输入向量与权向量的内积后加偏置，经一个非线性传递函数得到一个标量结果。&mdash;
title: 原来这就是网络</a></li><li><a href=#家庭网络>家庭网络</a></li><li><a href=#分组由一块用户数据和必要的地址和管理信息组成保证网络能够将数据传递到目标类似于从邮局发送的包裹上注明的地址一样只有提供给网络这些信息网络邮局才能把分组包裹往正确的地址传送><strong>分组</strong>：由一块用户数据和必要的地址和管理信息组成，保证网络能够将数据传递到目标。类似于从邮局发送的包裹上注明的地址一样,只有提供给网络这些信息，网络（邮局）才能把分组（包裹）往正确的地址传送</a></li><li><a href=#title-vim>title: vim</a></li><li><a href=#title-shell>title: shell</a><ul><li><a href=#bash-参数拓展>Bash 参数拓展</a></li><li><a href=#sed>sed</a></li></ul></li><li><a href=#title-linux命令>title: linux命令</a><ul><li><a href=#tar>tar</a></li></ul></li><li><a href=#title-可行性研究>压缩<code>tar -zcvf filename.tar.gz filename</code>&mdash;
title: 可行性研究</a></li><li><a href=#一可行性研究的任务>一、可行性研究的任务</a></li><li><a href=#二可行性研究过程典型的可行性研究过程为>二、可行性研究过程典型的可行性研究过程为：</a></li><li><a href=#三系统流程图>三、系统流程图</a></li><li><a href=#四数据流图>四、数据流图</a></li><li><a href=#五数据字典概念>五、数据字典概念</a></li><li><a href=#六成本效益分析>六、成本/效益分析</a></li><li><a href=#title-详细设计>1 目的
帮助客户组织负责人从经济角度判断是否继续投资于这项工程。2 成本估计的方法
（1）代码行技术；
（2）任务分解技术；
（3）自动估计成本技术。
3 重要公式
（1）计算P元钱在n年后的价值：F=P(1+i)n，其中年利率为i。
（2）n年后能收入F元钱，计算这些钱的现在价值：P=F/(1+i)n。
（3）计算投资回收率：
P=F1/(1+j)+F2/(1+j)2+…+Fn/(1+j)n
其中，P是现在的投资额；Fi是第i年年底的效益（i＝1，2，…，n）；n
是系统的使用寿命；j是投资回收率。&mdash;
title: 详细设计</a></li><li><a href=#一结构程序设计>一、结构程序设计</a></li><li><a href=#三人机界面设计>三、人机界面设计</a></li><li><a href=#四过程设计的工具>四、过程设计的工具</a></li><li><a href=#五面向数据结构的设计方法>五、面向数据结构的设计方法</a></li><li><a href=#六程序复杂程度的定量度量价值>六、程序复杂程度的定量度量价值</a></li><li><a href=#title-软件维护>2 McCabe方法
（1）流图
① 定义
流图实质上是“退化了的”程序流程图，它仅仅描绘程序的控制流程，完
全不表现对数据具体操作以及分支或循环的具体条件。
② 程序流程图映射成流图
图6-10说明了把程序流程图映射成流图的方法。图6-10
把程序流程图映射成流图
a．流图中用圆表示结点，一个圆代表一条或多条语句。程序流程图中
的一个顺序的处理框序列和一个菱形判定框，可以映射成流图中的一个结点。
b．流图中的箭头线称为边，代表控制流。流图中一条边必须终止于一
个结点，即使这个结点并不代表任何语句。
c．由边和结点围成的面积称为区域，计算区域数时应包括图外部未被
围起来的区域。
③ PDL翻译成流图
a．基本情况
图6-11是用PDL表示的处理过程及与之对应的流图。图6-11 由PDL翻译成的流图
b．包含复合条件
复合条件，就是在条件中包含了一个或多个布尔运算符。图6-12是由包
含复合条件的PDL片段翻译成的流图。
图6-12 由包含复合条件的PDL映射成的流图
（2）环形复杂度
① 定义
McCabe方法根据程序控制流的复杂程度定量度量程序的复杂程度，度
量出的结果称为程序的环形复杂度。② 计算方法
环形复杂度定量度量程序的逻辑复杂度，可以用下述3种方法中的任何
一种来计算环形复杂度：
a．流图中线性无关的区域数等于环形复杂度。
b．流图G的环形复杂度V(G)=E-N+2，其中，E是流图中边的条数，N是
结点数。
c．流图G的环形复杂度V(G)=P+1，其中，P是流图中判定结点的数目。
3 Halstead方法
（1）定义
Halstead方法是根据程序中运算符和操作数的总数来度量程序的复杂程
度。
（2）方法
① 程序长度N定义（N1为程序中运算符出现的总次数，N2为操作数出现
的总次数）：N=N1+N2；
② 预测程序长度的公式（使用的不同运算符的个数n1，不同操作数的个
数n2）：H=n1log2n1+n2log2n2；
③ 预测程序中包含错误的个数的公式：E=Nlog2(n1+n2)/3000。6.2 课后习题&mdash;
title: 软件维护</a></li><li><a href=#一软件维护的定义>一、软件维护的定义</a></li><li><a href=#二软件维护的特点>二、软件维护的特点</a></li><li><a href=#三软件维护过程>三、软件维护过程</a></li><li><a href=#四软件的可维护性>四、软件的可维护性</a></li><li><a href=#五预防性维护-定义>五、预防性维护 定义</a></li><li><a href=#六软件再工程过程>六、软件再工程过程</a></li><li><a href=#title-8>1 典型软件再工程模型
典型的软件再工程过程模型如图8-2所示。图8-2
软件再工程过程模型
【注意】在某些情况下这些活动以线性顺序发生，但也并非总是这样。
2 六类活动
（1）库存目录分析；
（2）文档重构；
（3）逆向工程；
（4）代码重构；
（5）数据重构；
（6）正向工程。&mdash;
title: 8</a></li><li><a href=#一面向对象方法学概述>一、面向对象方法学概述</a></li><li><a href=#二面向对象的概念>二、面向对象的概念</a></li><li><a href=#三面向对象建模-模型>三、面向对象建模 模型</a></li><li><a href=#四对象模型>四、对象模型</a></li><li><a href=#五动态模型>五、动态模型</a></li><li><a href=#六功能模型>六、功能模型</a></li><li><a href=#title-9>1 概念
（1）定义
功能模型表示变化的系统的功能性质，它指明了系统应该做什么。
（2）组成
功能模型由一组数据流图组成。
2 用例图在UML中把用用例图建立起来的系统模型称为用例模型。
（1）定义
用例模型描述的是外部行为者所理解的系统功能。用例模型的建立是系
统开发者和用户反复讨论的结果，它描述了开发者和用户对需求规格所
达成的共识。
（2）组成和表示
① 系统，用方框表示。
② 用例，用椭圆表示。
③ 行为者，用线条人表示。
④ 关系，用连线表示。
（3）关系的分类
UML用例之间主要有扩展和使用两种关系，它们是泛化关系的两种不
同形式。
① 扩展关系
向一个用例中添加一些动作后构成了另一个用例，这两个用例之间的关
系就是扩展关系，后者继承前者的一些行为，通常把后者称为扩展用
例。
② 使用关系
一个用例使用另一个用例时，这两个用例之间就构成了使用关系。七、3种模型之间的关系
1 针对每个类建立的动态模型，描述了类实例的生命周期或运行周
期。
2 状态转换驱使行为发生，这些行为在数据流图中被映射成处理，在
用例图中被映射成用例，它们同时与类图中的服务相对应。
3 功能模型中的处理对应于对象模型中的类所提供的服务。
4 数据流图中的数据存储，以及数据的源点/终点，通常是对象模型中
的对象。
5 数据流图中的数据流，往往是对象模型中对象的属性值，也可能是
整个对象。
6 用例图中的行为者，可能是对象模型中的对象。
7 功能模型中的处理可能产生动态模型中的事件。
8 对象模型描述了数据流图中的数据流、数据存储以及数据源点/终点的结构。9.2 课后习题&mdash;
title: 9</a></li><li><a href=#一面向对象分析的基本过程>一、面向对象分析的基本过程</a></li><li><a href=#二需求陈述>二、需求陈述</a></li><li><a href=#三建立对象模型>三、建立对象模型</a></li><li><a href=#四建立动态模型>四、建立动态模型</a></li><li><a href=#五建立功能模型>五、建立功能模型</a></li><li><a href=#title-10>1 画出基本系统模型图
基本的系统模型有下述两部分组成：
（1）数据源点/终点
数据源点输入的数据和输出到数据终点的数据，是系统与外部世界间交
互事件的参数。
（2）处理框
处理框代表了系统加工、变换数据的整体功能。
2 画出功能级数据流图
把基本系统模型中单一的处理框分解成若干个处理框，以描述系统加
工、变换数据的基本功能，就得到功能级数据流图。
3 描述处理框功能
（1）要点着重描述每个处理框所代表的功能，而不是实现功能的具体算法。
（2）描述分类
① 说明性描述（更重要）；
② 过程性描述。
六、定义服务（略）10.2 课后习题&mdash;
title: 10</a></li><li><a href=#一面向对象设计的准则>一、面向对象设计的准则</a></li><li><a href=#二启发规则>二、启发规则</a></li><li><a href=#三软件重用>三、软件重用</a></li><li><a href=#四系统分解>四、系统分解</a></li><li><a href=#五设计问题域子系统>五、设计问题域子系统</a></li><li><a href=#六设计人机交互子系统>六、设计人机交互子系统</a></li><li><a href=#七设计任务管理子系统1-设计的必要性>七、设计任务管理子系统1 设计的必要性</a></li><li><a href=#八设计数据管理子系统>八、设计数据管理子系统</a></li><li><a href=#九设计类中的服务>九、设计类中的服务</a></li><li><a href=#十设计关联>十、设计关联</a></li><li><a href=#十一设计优化>十一、设计优化</a></li><li><a href=#title-编码测试>1 确定优先级
2 提高效率的几项技术
（1）增加冗余关联以提高访问效率。
（2）调整查询次序。
（3）保留派生属性。
3 调整继承关系
（1）继承关系
继承关系能够为一个类族定义一个协议，并能在类之间实现代码共享以
减少冗余。
（2）建立类继承
① 抽象与具体的持续演化；
② 为提高继承程度而修改类定义；
③ 利用委托实现行为共享。11.2 课后习题&mdash;
title: 编码测试</a></li><li><a href=#一编码>一、编码</a></li><li><a href=#二软件测试基础>二、软件测试基础</a></li><li><a href=#三单元测试模块-->三、单元测试（模块 ）</a></li><li><a href=#四集成测试>四、集成测试</a></li><li><a href=#五确认测试>五、确认测试</a></li><li><a href=#六白盒测试技术-逻辑覆盖>六、白盒测试技术 逻辑覆盖</a></li><li><a href=#七黑盒测试技术>七、黑盒测试技术</a></li><li><a href=#八调试>八、调试</a></li><li><a href=#九软件可靠性-基本概念>九、软件可靠性 基本概念</a></li><li><a href=#title-11>（1）软件可靠性
软件可靠性是程序在给定的时间间隔内，按照规格说明书的规定成功地
运行的概率。
（2）软件的可用性
软件可用性是程序在给定的时间点，按照规格说明书的规定，成功地运
行的概率。
（3）MTTF和MTTR
① 概念
a．平均维修时间MTTR
表示修复一个故障平均需要用的时间。
b．平均无故障时间MTTF
表示系统按规格说明书规定成功地运行的平均时间。
② 计算公式
如果在一段时间内，软件系统故障停机时间分别为td1，td2，…，正常运
行时间分别为tu1，tu2，…，则系统的稳态可用性为：
（7.1）其中：
（7.1）式可以变成
（7.2）
2 估算平均无故障时间的方法
（1）符号
① ET：测试之前程序中错误总数；
② IT：程序长度（机器指令总数）；
③ τ：测试（包括调试）时间；
④ Ed(τ)：在0至τ期间发现的错误数；
⑤ Ec(τ)：在0至τ期间改正的错误数。
（2）基本假定
① 单位长度里的错误数ET/IT近似为常数。通常0.5×10-2≤ET/IT≤2×10-2。② 失效率正比于软件中潜藏的错误数，平均无故障时间MTTF与剩余的
错误数成反比。
③ 假设发现的每一个错误都立即正确地改正了，即Ec(τ)=Ed(τ)。
a．剩余的错误数
（7.3）
b．单位长度程序中剩余的错误数
（7.4）
（3）估算平均无故障时间
① 平均无故障时间与单位长度程序中剩余的错误数成反比（K经典值为
200），即
（7.5）
② 估算平均无故障时间的公式，可以评价软件测试进展情况。由
（7.5）式可得：
（7.6）
（4）估计错误总数的方法① 植入错误法
假设人为地植入的错误数为Ns，经过一段时间的测试之后发现ns个植入
的错误，还发现了n个原有的错误。则估计出程序中原有错误的总数
为：
（7.7）
其中 即是错误总数ET的估计值。
② 分别测试法
假定测试员乙发现有标记错误和发现无标记错误的概率相同，则可以估
计出测试前程序中的错误总数为：
（7.8）
其中，测试员甲发现的错误数为B1，测试员乙发现的错误数为B2，两个
测试员发现的相同错误数为bc。7.2 课后习题&mdash;
title: 11</a></li><li><a href=#一程序设计语言>一、程序设计语言</a></li><li><a href=#二程序设计风格>二、程序设计风格</a></li><li><a href=#三测试策略1-经典的测试策略>三、测试策略1 经典的测试策略</a></li><li><a href=#四设计测试用例>四、设计测试用例</a></li><li><a href=#title-12>1 测试类的方法
（1）随机测试；
（2）划分测试；
（3）基于故障的测试。
2 集成测试方法
（1）多类测试
① 随机测试；
② 划分测试。
（2）从动态模型导出测试用例12.2 课后习题&mdash;
title: 12</a></li><li><a href=#title-总体设计>复习笔记
一、估算软件规模
软件项目管理先于任何技术活动之前开始，并且贯穿于软件的整个生命
周期之中，而制定计划的基础是工作量估算和完成期限估算。
1 代码行技术
（1）定义
代码行技术依据以往开发类似产品的经验和历史数据，估计实现一个功
能所需要的源程序行数。
（2）方法
① 每名工程师估计程序的最小规模（a）、最大规模（b）和最可能的规
模（m），分别算出这3种规模的平均值后，再用下式计算程序规模的
估计值：
（13.1）
② 程序较小时用的单位是代码行数（LOC）；程序较大时用的单位是千
行代码数（KLOC）。（3）优点
① 代码是所有软件开发项目都有的“产品”，而且很容易计算代码行数。
② 有以往开发类似产品的历史数据可参考时，估计出的数值比较准确。
（4）缺点
① 源程序仅是软件配置的一个成分，用它的规模代表整个软件的规模不
太合理。
② 用不同语言实现同一个软件所需要的代码行数并不相同。
③ 不适用于非过程语言。
2 功能点技术
（1）特点
① 功能点技术依据对软件信息域特性和软件复杂性的评估结果，估算软
件规模。
② 以功能点（FP）为单位度量软件规模。
（2）信息域特性
① 输入项数（Inp）
② 输出项数（Out）
③ 查询数（Inq）④ 主文件数（Maf）
⑤ 外部接口数（Inf）
（3）估算功能点的步骤
① 计算未调整的功能点数UFP
需记住公式：
UFP＝a1×Inp＋a2×Out＋a3×Inq＋a4×Maf＋a5×Inf
其中，ai（1≤i≤5）是信息域特性系数，由相应特性的复杂级别决定，如
表13-1所示。
表13-1 信息域特性系数值
② 计算技术复杂性因子TCF
在表13-2中列出了全部技术因素，并用Fi（1≤i≤14）代表这些因素。
表13-2 技术因素a．根据软件的特点，为每个因素分配一个从0到5的值。
b．用下式计算技术因素对软件规模的综合影响程度DI（0～70）：
c．技术复杂性因子TCF（0.65～1.35）由下式计算：TCF＝0.65＋
0.01×DI
③ 计算功能点数FP
用下式计算功能点数FP：FP＝UFP×TCF
（4）功能点技术的优缺点
① 优点：功能点数与所用的编程语言无关，比代码行技术更合理；② 缺点：在判断信息域特性复杂级别和技术因素的影响程度时，功能点
技术存在相当大的主观因素。
二、工作量估算
1 工作量概念
工作量是软件规模的函数，工作量的单位通常是人月（pm）。
2 静态单变量模型
（1）形式
静态单变量模型的总体结构形式如下：
E=A+B×(eν)c
其中，A、B和C是由经验数据导出的常数，E是以人月为单位的工作
量，eν是估算变量（KLOC或FP）。
（2）分类
① 面向KLOC的估算模型
a．Walston_Felix模型：E=5.2×(KLOC)0.91
b．Bailey_Basili模型：E=5.5+0.73×(KLOC)1.16
c．Boehm简单模型：E=3.2×(KLOC)1.05
d．Doty模型（KLOC>9时适用）：E=5.288×(KLOC)1.047② 面向FP的估算模型
a．Albrecht & Gaffney模型：E=-13.39+0.0545FP
b．Maston，Barnett和Mellichamp模型：E=585.7+15.12FP
3 动态多变量模型
① 特点
动态多变量模型把工作量看作软件规模和开发时间这两个变量的函数。
② 形式
动态多变量估算模型的形式如下：
（13.2）
其中，E是以人月或人年为单位的工作量；t是以月或年为单位的项目持
续时间；B是特殊技术因子。
4 COCOMO2模型（构造性成本模型）
（1）3层模型
① 应用系统组成模型；
② 早期设计模型；③ 体系结构模型。
（2）形式
COCOMO2模型把软件开发工作量表示成代码行数（KLOC）的非线性
函数：
（13.3）
其中：E是开发工作量（以人月为单位）；a是模型系数；KLOC是估计
的源代码行数（以千行为单位）；b是模型指数；fi（i＝1～17）是成本
因素。
（3）模型指数
COCOMO2采用了b分级模型，是使用5个分级因素Wi（1≤i≤5），其中
每个因素都划分成从甚低（Wi＝5）到特高（Wi＝0）的6个级别，用下
式计算b（1.01～1.26）的数值：
（13.4）
（4）COCOMO2的5个分级因素
① 项目先例性；
② 开发灵活性；
③ 风险排除度；④ 项目组凝聚力；
⑤ 过程成熟度。
三、进度计划
1 相关概念
（1）一个有效的软件过程应该定义一个适用于当前项目的任务集合。
（2）一个任务集合包括一组软件工程工作任务、里程碑和可交付的产
品。
2 估算开发时间
（1）利用成本估算模型估算开发时间
① Walston_Felix模型：T=2.5E0.35
② 原始的COCOMO模型：T=2.5E0.38
③ COCOMO2模型：T=3.0E0.33+0.2×(b-1.01)
④ Putnam模型T=2.4E1/3
其中，E是开发工作量（以人月为单位）；T是开发时间（以月为单
位）。
（2）项目组规模与项目组总生产率的关系
① 通信路径项目组成员之间的通信路径数，由项目组人数和项目组结构决定。通信
路径数大约在P～P2/2的范围内变化。
② 平均生产力
某一个组员与其他组员通信的路径数在1～（P-1）的范围内变化。如果
不与任何人通信时个人生产率为L，而且每条通信路径导致生产率减少
1，则组员个人平均生产率为：Lr=L-l(P-1)r，其中，r是对通信路径数的
度量，0&lt;r≤1。
③ 总生产率
对于一个规模为P的项目组，项目组的总生产率为：Ltot=P(L-l(P-1)r)。
对于给定的一组L，l和r的值，总生产率Ltot是项目组规模P的函数。
3 Gantt图
（1）优点
① 很形象地描绘任务分解情况，以及每个子任务（作业）的开始时间和
结束时间。
② 容易掌握、容易绘制。
（2）缺点
① 不能显式地描绘各项作业彼此间的依赖关系。
② 进度计划的关键部分不明确，难于判定哪些部分应当是主攻和主控的对象。
③ 计划中有潜力的部分及潜力的大小不明确，往往造成潜力的浪费。
4 工程网络
（1）定义
工程网络描绘任务分解情况以及每项作业的开始时间和结束时间，并描
绘了各个作业彼此间的依赖关系。
（2）表示
① 用箭头表示作业；
② 用圆圈表示事件；
③ 用虚线箭头表示虚拟作业。
5 估算工程进度
（1）完善工程网络
① 把每个作业估计需要使用的时间写在表示该项作业的箭头上方。
② 为每个事件计算最早时刻EET和最迟时刻LET，分别写在表示事件的
圆圈的右上角和右下角。
（2）最早时刻EET事件的最早时刻是该事件可以发生的最早时间。
（3）最迟时刻LET
事件的最迟时刻是在不影响工程竣工时间的前提下，该事件最晚可以发
生的时刻。
6 关键路径
（1）定义
由最早时刻和最迟时刻相同的事件定义了关键路径。
（2）特点
① 处于关键路径之外的任务进度拖后，不会影响整个项目的完成时间。
② 处于关键路径之中的任务进度拖后，则整个项目的完成日期就会拖
后。
7 机动时间
一个作业可以有的全部机动时间等于它的结束事件的最迟时刻减去它的
开始事件的最早时刻，再减去这个作业的持续时间：机动时间=(LET)结
束-(EET)开始-持续时间。
四、人员组织
1 必要性（1）项目成功的关键在于合理的组织人员，使他们有效地分工协作共同
完成开发工作。
（2）项目组组织得越好，其生产率越高，而且产品质量也越好。
（3）项目组具有了凝聚力，成功的可能性就大大增加了。
2 典型的组织方式
（1）民主制程序员组
① 优点
a．组员们对发现程序错误持积极的态度，有助于更快速地发现错误，
提高代码质量。
b．组员们享有充分民主，小组凝聚力高、学术空气浓厚，有利于攻克
技术难关。
② 缺点
没有明确的权威指导开发过程，组员间将缺乏必要的协调，最终可能导
致工程失败。
③ 适用性
所要开发的软件的技术难度较高时，采用民主制程序员组是适宜的。
（2）主程序员组
① 定义图13-1
主程序员组的结构
② 优点
a．专业化：该组每名成员仅完成他们擅长的工作。
b．层次性：主程序员指挥组员工作，并对项目全面负责。
③ 缺点
符合主程序员、后备程序员、编辑秘书标准的人才在现实社会中并不容
易雇佣到。
（3）现代程序员组
① 主程序员由两个人共同担任，组织结构如图13-2所示。图13-2
现代程序员组的结构
② 制定针对公共职责范围内的事务的处理方案。
③ 实行分组策略。
④ 分散决定。
五、质量保证
1 软件质量
（1）定义
软件质量是软件与明确地和隐含地定义的需求相一致的程度。
【注意】软件需求是度量软件质量的基础，与需求不一致就是质量不
高。（2）软件质量因素与产品活动
① 软件质量因素
如表13-3所示，列出了软件质量因素的简明定义。
表13-3 软件质量因素的定义
② 产品活动（倾向）分类
可以把产品活动分为产品运行、产品修改和产品转移三类。
③ 软件质量因素和3种产品活动的关系
如图13-3所示。图13-3
软件质量因素与产品活动的关系
【注意】图13-3是考点，记住每一质量因素属于哪一产品活动。
2 软件质量保证措施
（1）措施
① 基于非执行的测试（复审或评审）。
② 基于执行的测试（软件测试）。
③ 程序正确性证明。
（2）技术复审
① 优点
能较早发现软件错误，防止错误被传播到软件过程的后续阶段。② 方法
技术复审包括走查和审查等具体方法。
（3）程序正确性证明的方法
① 人工证明。
② 研究能证明程序正确性的自动系统。
六、软件配置管理
1 相关概念
（1）定义
软件配置管理是在软件的整个生命期内管理变化的一组活动。
（2）目的
① 标识变化；
② 控制变化；
③ 确保适当地实现了变化；
④ 向需要知道这类信息的人报告变化。
（3）与维护的区别
① 维护是在软件交付给用户使用后才发生的。
② 配置管理是在软件项目启动时就开始，并且一直持续到软件退役后才终止的一组跟踪和控制活动。
2 软件配置
（1）软件配置项
① 计算机程序（源代码和可执行程序）。
② 描述计算机程序的文档（供技术人员或用户使用）。
③ 数据（程序内包含的或在程序外的）。
（2）基线
① 定义
基线就是通过了正式复审的软件配置项。
② 作用
基线有助于人们在不严重妨碍合理变化的前提下来控制变化。
3 软件配置管理过程
（1）标识软件配置中的对象；
（2）版本控制；
（3）变化控制；
（4）配置审计；（5）状态报告。
七、能力成熟度模型
1 能力成熟度模型（CMM）
（1）定义
能力成熟度模型（CMM）是用于评价软件机构的软件过程能力成熟度
的模型。
（2）目的
① 为大型软件项目的招投标活动提供一种全面而客观的评审依据。
② 应用于许多软件机构内部的过程改进活动中。
（3）基本思想
由于问题是由人们管理软件过程的方法不当引起的，所以新软件技术的
运用并不会自动提高软件的生产率和质量。
（4）作用
① 有助于软件开发机构建立一个有规律的、成熟的软件过程。
② 改进后的软件过程将开发出质量更好的软件，避免时间延误和费用超
支。
（5）对能力成熟度划分的原因
① 对软件过程的改进，是在完成一个又一个小的改进步骤基础上不断进行的渐进过程。
② 这5个成熟度等级定义了一个有序的尺度，用以测量软件机构的软件
过程成熟度和评价其软件过程能力。
③ 成熟度等级帮助软件机构把应做的改进工作排出优先次序。
④ 成熟度等级是妥善定义的向成熟软件机构前进途中的平台，每个成熟
度等级都为软件过程的继续改进提供了一个台阶。
2 能力成熟度的5个等级
（1）初始级（1级）
（2）可重复级（2级）
（3）已定义级（3级）
（4）已管理级（4级）
（5）优化级（5级）13.2 课后习题&mdash;
title: 总体设计</a></li><li><a href=#一设计过程>一、设计过程</a></li><li><a href=#二设计原理>二、设计原理</a></li><li><a href=#三启发规则>三、启发规则</a></li><li><a href=#四描绘软件结构的图形工具>四、描绘软件结构的图形工具</a></li><li><a href=#五面向数据流的设计方法>五、面向数据流的设计方法</a></li><li><a href=#title-3>1 信息流的类型
（1）变换流（顺序）
变换流具有如下特征：
① 信息沿输入通路进入系统，同时由外部形式变换成内部形式；
② 进入系统的信息通过变换中心，经加工处理后沿输出通路变成外部形
式离开软件系。
（2）事务流(选择)
事务流是“以事务为中心”的数据流，即数据沿输入通路到达一个处理
T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执
行。
2 设计过程
图5-3说明了使用面向数据流方法逐步设计的过程。图5-3
面向数据流方法的设计过程
【注意】任何设计过程都不是机械的一成不变的。
3 变换分析
（1）适用性
一般说来，如果数据流不具有显著的事务特点，最好使用变换分析。
（2）设计步骤① 复查基本系统模型；
② 复查并精化数据流图；
③ 确定数据流图具有变换特性还是事务特性；
④ 确定输入流和输出流的边界，从而孤立出变换中心；
⑤ 第一级分解；
⑥ 第二级分解；
⑦ 使用设计度量和启发式规则对第一次分割得到的软件结构进一步精
化。
4 事务分析
（1）适用性
在数据流具有明显的事务特点时，即有一个明显的事务中心时，采用事
务分析方法为宜。
（2）设计
事务分析的映射方法如图5-4所示。图5-4
事务分析的映射方法
5 设计优化
（1）设计优化时应遵循的原则。
① 应该开发能够满足所有功能和性能要求，而且按照设计原理和启发式
设计规则衡量是值得接收的软件。
② 应该在设计的早期阶段尽量对软件结构进行精化。
③ 结构简单通常既表示设计风格优雅，又表明效率高。
④ 对于时间是决定性因素的应用场合，可能需要在详细设计阶段或在编写程序的过程中进行优化。
（2）可以采用以下几种方法对时间起决定性作用的软件进行优化。
① 在不考虑时间因素的前提下开发并精化软件结构。
② 在详细设计阶段选出最耗费时间的那些模块，仔细地设计它们的处理
过程（算法），以求提高效率。
③ 使用高级程序设计语言编写程序。
④ 在软件中孤立出那些大量占用处理机资源的模块。
⑤ 必要时重新设计或用依赖于机器的语言重写上述大量占用资源的模块
的代码，以求提高效率。5.2 课后习题&mdash;
title: 3</a></li><li><a href=#title-软件工程>复习笔记
一、概述
1 非形式化方法的缺点
（1）矛盾；
（2）二义性；
（3）含糊性；
（4）不完整性；
（5）抽象层次混乱。
【注意】用自然语言描述需求规格说明，是典型的非形式化方法。
2 形式化方法的优点
（1）能保证规格说明中尽可能没有矛盾、二义性、含糊性和不完整性。
（2）可以在不同的软件工程活动之间平滑地过渡。
（3）提供了高层确认的手段。3 形式化方法的缺点
（1）难于表示问题的时序、控制和行为等方面的需求。
（2）相比欠形式化方法，它更难学习，培训的投资过大。
【注意】如果一种方法有坚实的数学基础，那么它就是形式化的。
4 应用形式化方法的准则
（1）应该选用适当的表示方法。
（2）应该形式化，但不要过分形式化。
（3）应该估算成本。
（4）应该有形式化方法顾问随时提供咨询。
（5）不应该放弃传统的开发方法。
（6）应该建立详尽的文档。
（7）不应该放弃质量标准。
（8）不应该盲目依赖形式化方法。
（9）应该测试、测试再测试。
（10）应该重用。
二、有穷状态机1 概念
（1）定义
有穷状态机是表达规格说明的一种形式化方法。
（2）构成
一个有穷状态机包括下述5个部分：状态集J、输入集K、由当前状态和
当前输入确定下一个状态（次态）的转换函数T、初始态S和终态集F。
一个有穷状态机可以表示为一个5元组（J，K，T，S，F）。其中：J是
一个有穷的非空状态集；K是一个有穷的非空输入集；T是一个从(J-
F)×K到J的转换函数；S∈J，是一个初始状态；F⊆J，是终态集。
（3）状态转换形式
当前状态[菜单]＋事件[所选择的项]⇒下个状态
（4）谓词集P
① 谓词集P把有穷状态机扩展为一个6元组，其中每个谓词都是系统全
局状态Y的函数。
② 加入谓词集后转换规则形式为：当前状态[菜单]＋事件[所选择的项]
＋谓词⇒下个状态。
2 评价
（1）优点
① 采用易于书写、易于验证的格式来描述规格说明，能容易地把规格说明转变成设计或程序代码。
② 比数据流图技术更精确且易于理解。
（2）缺点
① 在开发一个大系统时，三元组（即状态、事件、谓词）的数量会迅速
增长。
② 形式化的有穷状态机方法没有处理定时需求。
三、Petri网
1 概念
（1）构成
① 一般构成
Petri网包含4种元素：一组位置P、一组转换T、输入函数I，以及输出函
数O。如图4-1为Petri网的实例。
图4-1
Petri网的组成a．一组位置P为{P1，P2，P3，P4}，在图中用圆圈代表位置。
b．一组转换T为{T1，T2}，在图中用短直线表示转换。
c．两个用于转换的输入函数，用由位置指向转换的箭头表示，它们
是：
I(t1)={P2，P4}
I(t2)={P2}
d．两个用于转换的输出函数，用由转换指向位置的箭头表示，它们
是：
O(t1)={P1}
O(t2)={P3，P3}
【注意】输出函数O(t1)中有两个P3，是因为有两个箭头由t2指向P3。
② 形式化的Petri网
更形式化的Petri网结构是一个四元组：
C=(P，T，I，O)
其中：
a．P={P1，…，Pn}是一个有穷位置集，n≥0。
b．T={t1，…，tm}是一个有穷转换集，m≥0，且T和P不相交。
c．I：T→P∞为输入函数，是由转换到位置无序单位组（bags）的映射。
d．O：T→P∞为输出函数，是由转换到位置无序单位组的映射。
（2）作用
用于确定系统中隐含的定时问题，可以有效地描述并发活动。
四、Z语言
1 组成部分
（1）给定的集合；
（2）状态定义；
（3）初始状态；
（4）操作。
2 优点
（1）可以比较容易地发现用Z写的规格说明的错误；
（2）使用Z写规格说明时对精确性要求高，减少了模糊性、不一致性和
遗漏；
（3）可以降低软件开发费用；
（4）用Z写规格说明，更加清楚和正确。4.2 课后习题&mdash;
title: 软件工程</a></li><li><a href=#一软件危机>一、软件危机</a><ul><li><a href=#1-软件危机的介绍>1 软件危机的介绍</a></li><li><a href=#2-产生软件危机的原因>2 产生软件危机的原因</a></li><li><a href=#3-消除软件危机的途径>3 消除软件危机的途径</a></li></ul></li><li><a href=#二软件工程>二、软件工程</a><ul><li><a href=#1-软件工程的介绍>1 软件工程的介绍</a></li><li><a href=#2-软件工程的基本原理>2 软件工程的基本原理</a></li><li><a href=#3-软件工程方法学>3 软件工程方法学</a></li></ul></li><li><a href=#三软件生命周期>三、软件生命周期</a></li><li><a href=#四软件过程>四、软件过程</a><ul><li><a href=#1-概念>1 概念</a></li><li><a href=#2-典型软件过程模型>2 典型软件过程模型</a></li></ul></li><li><a href=#title-需求分析>【注意】考生要着重掌握瀑布模型、快速原型模型、螺旋模型、增量模
型、喷泉模型。
（1）瀑布模型
① 开发流程
实际的瀑布模型是带“反馈环”的，如图1-1所示（图中实线箭头表示开
发过程，虚线箭头表示维护过程）。图1-1
实际的瀑布模型
【注意】传统的瀑布模型没有图中的反馈环。
② 特点
第一，阶段间具有顺序性和依赖性；
第二，推迟实现的观点；第三，质量保证的观点。
③ 瀑布模型的优缺点
a．优点
第一，可强迫开发人员采用规范的方法；
第二，严格地规定了每个阶段必须提交的文档；
第三，要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验
证；
第四，对文档的约束，使软件维护变得容易一些，且能降低软件预算。
b．缺点
第一：瀑布模型是由文档驱动的。
第二：缺乏对于需求变更和项目变化的适应性。
（2）快速原型模型
① 开发流程
如图1-2所示（图中实线箭头表示开发过程，虚线箭头表示维护过
程）。图1-2
快速原型模型
② 优点
快速原型模型是不带反馈环的。
【注意】快速原型模型弥补了瀑布模型不适用于需求动态变更的缺点，
其本质是“快速”。
（3）增量模型
① 开发步骤增量模型也称为渐增模型，如图1-3所示。
图1-3
增量模型
② 原理
把软件产品作为多个增量构件来设计、编码、集成、测试，开发人员一
个构件接一个构件地向用户提交产品。
③ 优点
a．能在较短时间内向用户提交可完成部分工作的产品。
b．逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品。
④ 技术难点
a．要求软件体系结构必须是开放的。
b．增量模型本身是自相矛盾的。c．增量模型的灵活性很容易退化为边做边改模型，从而使软件过程的
控制失去整体性。
⑤ 风险更大的增量模型
图1-4是一种风险更大的增量模型。
图1-4
风险更大的增量模型
【注意】每个增量构件的开发采用瀑布模型。
（4）螺旋模型
① 基本思想
可以把它看作在每个阶段之前都增加了风险分析过程的快速原型模型，
如图1-5所示。图1-5
② 原理
完整的螺旋模型如图1-6所示。
简化的螺旋模型图1-6
完整的螺旋模型
③ 应用
螺旋模型主要适用于内部开发的大规模软件项目。
④ 优点
a．有利于已有软件的重用，有助于把软件质量作为软件开发的一个重要目标；
b．减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的
风险；
c．在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没
有本质区别。
⑤ 缺点
螺旋模型是风险驱动的。要求软件开发人员具有丰富的风险评估经验和
这方面的专门知识。
（5）喷泉模型
① 开发流程
图1-7所示的喷泉模型，是典型的面向对象的软件过程模型之一。图1-7
喷泉模型
② 特点
a．喷泉模型是一种以用户需求为动力，以对象为驱动的模型，主要用
于描述面向对象的软件开发过程。
b．体现了面向对象软件开发过程迭代和无缝的特性。
（6）Rational统一过程（RUP）
① RUP软件开发生命周期RUP软件开发生命周期是一个二维的面向对象的生命周期模型，如图1-
8所示。图中纵轴代表核心工作流，横轴代表时间。
图1-8 RUP软件开发生命周期
② 核心工作流
如上图纵轴所示，由上至下有九个核心工作流，前六个为核心过程工作
流程，后三个为核心支持工作流程。
③ 工作阶段a．初始阶段。
b．精化阶段。
c．构建阶段。
d．移交阶段。
④ 特点
a．采用迭代和渐增的方式开发软件。
b．具有多功能性和广泛适用性。
（7）敏捷过程
敏捷过程能够较好地适应商业竞争环境下对小型项目提出的有限资源和
有限开发时间的约束。敏捷过程中最重要的是极限编程。
（8）极限编程
① 极限编程的整体开发过程
图1-9描述了极限编程的整体开发过程。图1-9 XP项目的整体开发过程
② 极限编程的迭代过程
图1-10描述了极限编程的迭代开发过程。图1-10 XP迭代开发过程
③ 特点
a．以极限编程为代表的敏捷过程，具有对变化和不确定性的更快速、
更敏捷的反应特性；
b．在快速的同时仍然能够保持可持续的开发速度。
（9）微软过程
① 微软软件生命周期
微软过程把软件生命周期划分成五个阶段，图1-11描绘了生命周期的阶
段及每个阶段的主要里程碑。
图1-11
② 微软过程模型
a．定义
微软软件生命周期阶段划分和主要里程碑图1-12描绘了微软过程的生命周期模型。
图1-12
微软过程的生命周期模型
b．特点
第一，适用于商业环境下具有有限资源和有限开发时间约束的项目；
第二，微软过程也有某些不足之处，例如，对方法、工具和产品等方面
的论述不如RUP和敏捷过程全面，人们对它的某些准则本身也有不同意
见。&mdash;
title: 需求分析</a></li><li><a href=#一需求分析的任务>一、需求分析的任务</a></li><li><a href=#二与用户沟通获取需求的方法>二、与用户沟通获取需求的方法</a></li><li><a href=#三分析建模与规格说明>三、分析建模与规格说明</a></li><li><a href=#四实体-联系图>四、实体-联系图</a></li><li><a href=#五数据规范化>五、数据规范化</a></li><li><a href=#六状态转换图>六、状态转换图</a></li><li><a href=#七其他图形工具>七、其他图形工具</a></li><li><a href=#title-速查-1>1 层次方框图层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构。
2 Warnier图
Warnier图有以下三种基本符号：
① 花括号：用来区分数据结构的层次，在一个花括号内的所有名字都属
于同一类信息。
② 异或符号：表明一类信息或一个数据元素在一定条件下才出现。
③ 圆括号中的数字：指明了这个名字代表的信息类在这个数据结构中重
复出现的次数。
3 IPO图
（1）定义
IPO图是输入、处理、输出图的简称，能够方便地描绘输入数据、对数
据的处理和输出数据之间的关系。
（2）基本形式和用法
① 左边的框中列出有关的输入数据；
② 中间的框内列出主要的处理；
③ 右边的框内列出产生的输出数据；
④ 粗大箭头指出数据通信的情况。处理框中列出处理的次序暗示了执行的顺序。
（3）改进的IPO图
改进的IPO图（IPO表）中包含某些附加的信息。如图3-2所示，改进的
IPO图中包含的附加信息主要有系统名称、图的作者，完成的日期，本
图描述的模块的名字，模块在层次图中的编号，调用本模块的模块清
单，本模块调用的模块的清单，注释，以及本模块使用的局部数据元素
等。
图3-2
改进的IPO图的形式
【注意】考生要区分并牢记给定图形工具可用于软件生命周期的哪一阶
段，此为常考题。本节三种图形工具均可用于需求分析阶段。八、验证软件需求
1 验证软件需求的正确性
（1）验证需求正确性的目的
为了提高软件质量，确保软件开发成功，降低软件开发成本。
（2）进行验证的四个方面
① 一致性；
② 完整性；
③ 现实性；
④ 有效性。
2 验证软件需求的方法
（1）验证需求的一致性；
（2）验证需求的现实性；
（3）验证需求的完整性和有效性。
3 用于需求分析的软件工具——PSL/PSA系统
① 定义PSL是用来描述系统的形式语言，PSA是处理PSL描述的分析程序。
② 功能
a．描述任何应用领域的信息系统；
b．创建一个数据库保存对该信息系统的描述符；
c．对描述符施加增加、删除和更改等操作；
d．产生格式化的文档和关于规格说明书的各种分析报告。
③ 优点
a．改进了文档质量，能保证文档具有完整性、一致性和无二义性，从
而可以减少管理和维护的费用；
b．数据存放在数据库中，便于增加、删除和更改。3.2 课后习题&mdash;
title: 速查</a></li><li><a href=#基本语法>基本语法</a></li><li><a href=#字符串>字符串</a></li><li><a href=#列表>列表</a></li><li><a href=#字典>字典</a></li><li><a href=#函数>函数</a></li><li><a href=#文件>文件</a></li><li><a href=#常用模块>常用模块</a></li><li><a href=#数据库>数据库</a><ul><li><a href=#orm>ORM</a></li><li><a href=#初始化>初始化</a></li><li><a href=#模型类>模型类</a></li><li><a href=#crud>CRUD</a></li></ul></li></ul></nav></div></details></div><div class=post-content><blockquote><p>mo x本文由 <a href=http://ksria.com/simpread/>简悦 SimpRead</a> 转码， 原文地址 <a href=https://marlous.github.io/2018/11/04/%E3%80%8A%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AF%BC%E8%AE%BA%E3%80%8B%E5%BC%A0%E6%B5%B7%E6%BD%98%E7%89%88%E6%A0%B8%E5%BF%83%E7%BA%B2%E8%A6%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/>marlous.github.io</a></p></blockquote><blockquote><p>Mo&rsquo;s Blog at GitHub</p></blockquote><blockquote><p>参考：<br>1、 《软件工程导论》张海潘版<br>2、 <a href=https://blog.csdn.net/a11112244444/article/details/52461786>软件工程——思维导图</a><br>3、 <a href="https://wenku.baidu.com/view/efda689d51e2524de518964bcf84b9d529ea2c5d.html?rec_flag=default&amp;sxts=1549958866931">软件工程导论张海潘 (第六版) 第 1-13 章总结</a><br>4、 <a href="https://wenku.baidu.com/view/57db6f7331b765ce050814d1.html?from=search">软件工程的基本概念</a><br>5、 <a href="https://wenku.baidu.com/view/917f8f78cf84b9d528ea7a9f.html?rec_flag=default&amp;sxts=1549958765459">软件工程期末考试重点</a><br>6、 <a href="https://wenku.baidu.com/view/d7de31cf763231126edb11d2.html?from=search">软件工程考试重点内容</a><br>7、 <a href="https://wenku.baidu.com/view/edd9e61e10a6f524ccbf853f.html?from=search">软件工程期末考试复习题及答案</a></p></blockquote><h1 id=软件工程-软件工程软件工程><a href=#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B title=软件工程></a>软件工程<a hidden class=anchor aria-hidden=true href=#软件工程-软件工程软件工程>#</a></h1><blockquote><p>来源见水印。</p></blockquote><p><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be0.PNG alt></p><h2 id=1-工具-1-工具1-工具><a href=#1-%E5%B7%A5%E5%85%B7 title="1 工具"></a>1 工具<a hidden class=anchor aria-hidden=true href=#1-工具-1-工具1-工具>#</a></h2><blockquote><p>参考博文 《DevOps 与 CI/CD 的概念》。</p></blockquote><ol><li>项目管理：</li></ol><ul><li>任务跟踪：禅道、Trello、Teambition 等。</li><li>项目计划：禅道、Trello、Teambition 等。</li><li>团队沟通：Slack、Teambition 等。</li></ul><ol start=2><li>需求分析：</li></ol><ul><li>需求跟踪：禅道、Teambition、Trello 等。</li><li>原型制作：Adobe XD CC、Axure、Sketch 等，<a href=https://www.jianshu.com/p/4ead159e23df>参考：16 种原型制作工具及使用介绍</a>。</li></ul><ol start=3><li>设计：</li></ol><ul><li>UML 建模：Violet UM、ProcessOn、StarUML、Visio 等。（类图、对象图；用例图、状态图、活动图、序列图。<a href=https://zhuanlan.zhihu.com/p/44518805>参考：UML 各种图总结精华</a>、<a href=https://www.cnblogs.com/bluestorm/archive/2012/05/03/2480556.html>各种图含义作用</a> ）</li><li>图表制作：Excel、亿图等。</li></ul><ol start=4><li>开发：</li></ol><ul><li>源代码管理：GitHub、GitLab、SubVersion 等（Git、SVN）。</li><li>持续集成：Jenkins、CireleCI、AppCenter、Travis CI、flow.ci 等。</li></ul><ol start=5><li>测试：</li></ol><ul><li>Bug 跟踪：禅道、Teambition、Trello、The Bug Genie 等。</li><li>测试管理平台：TestLink、Redmine、禅道、TestCenter 等。</li><li>自动化测试：常用的：QPT、LR。/ 开源功能自动化测试工具：Watir、Selenium、MaxQ、WebInject。/ 开源性能自动化测试工具：Jmeter、OpenSTA、DBMonster、TPTEST、Web Application Load Simulator。</li><li>补充，自动化构建和测试: Apache Ant、Maven 、Selenium、PyUnit、QUnit、JMeter、Gradle、PHPUnit。</li></ul><ol start=6><li>运行维护：</li></ol><ul><li>自动化部署：Jenkins、ElectricFlow、DeployBot、CireleCI、AppCenter、Travis CI 等。</li><li>日志分析：Logstash、CollectD、StatsD 等。</li><li>线上监控：Nagios、Ganglia、Sensu、zabbix、ICINGA、Graphite、Kibana 等。</li></ul><h2 id=2-软件工程文档-2-软件工程文档2-软件工程文档><a href=#2-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%96%87%E6%A1%A3 title="2 软件工程文档"></a>2 软件工程文档<a hidden class=anchor aria-hidden=true href=#2-软件工程文档-2-软件工程文档2-软件工程文档>#</a></h2><ol><li>需要文档的几个方面：</li></ol><ul><li>立项文档</li><li>需求分析文档</li><li>概要设计和架构设计</li><li>详细设计</li><li>源代码</li><li>配置文档</li><li>单元测试文档</li><li>集成测试文档</li><li>验收文档</li><li>维护文档</li><li>用户操作手册</li><li>项目管理文档</li></ul><ol start=2><li>具体文档：</li></ol><ul><li><p>项目管理文档：<br>《软件项目计划》、《项目进度报告》、《项目开发总结报告》</p></li><li><p>管理控制文档：<br>《配置文档》、《维护文档》</p></li><li><p>软件开发文档：<br>《需求规格说明》、《概要设计说明》、《详细设计说明》、《软件源码文档》、《测试计划》、《软件测试分析报告》</p></li><li><p>产品文档：<br>《用户操作手册》、《演示文件》</p></li></ul><h1 id=一-软件工程学概述-一-软件工程学概述一-软件工程学概述><a href=#%E4%B8%80-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E6%A6%82%E8%BF%B0 title="一 软件工程学概述"></a>一 软件工程学概述<a hidden class=anchor aria-hidden=true href=#一-软件工程学概述-一-软件工程学概述一-软件工程学概述>#</a></h1><ol><li>软件工程方法学：</li></ol><ul><li>软件工程包括：技术、管理。</li><li>软件工程方法学三要素：过程（步骤）、方法（如何做）、工具（支持环境）。</li><li>传统方法学：强调自顶向下。面向对象方法学：强调主动多次反复迭代。（四个要点：对象、类、继承、消息。）</li></ul><ol start=2><li><p>软件周期（三个时期，八个阶段）：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be1.PNG alt></p></li><li><p>软件过程：</p></li></ol><ul><li><p>瀑布模型：规范、文档驱动；最终产品可能不是用户真正需求；难以按模型进行，开发过程逆转代价大。</p></li><li><p>快速原型模型：快速构建可在计算机上运行的原型系统，让用户反馈，开发周期短；客户与开发者对原型的理解不同，准确的设计原型困难。</p></li><li><p>螺旋模型：可看作增加了风险分析过程的快速原型模型；风险驱动，适用内部大型项目的开发。</p></li><li><p>增量模型：短期提交可完成部分，逐步增加功能；软件需具备开放性会导致失去整体结构，也可能有无法集成的问题。</p></li><li><p>喷泉模型：体现了面向对象软件开发过程无缝迭代特性。</p></li><li><p>补充，敏捷开发：是一套价值观和原则，大项目由各个可独立运行的小项目组成，此期间软件一直处于可使用状态。迭代式开发与增量交付。<a href=https://www.bilibili.com/video/av16212736>敏捷开发视频课程</a>，<a href=https://www.bilibili.com/video/av21945150>敏捷开发之 Scrum 视频课程</a>。</p></li><li><p>敏捷开发之 Scrum：计划、构建、测试、回顾。不断重复这四步来做增量式发布，最后形成一个可发布的版本。/ 三个角色：产品经理、Scrum 负责人、Scrum 团队（开发、测试、文案等人员）。/ 产品经理需求、用户视角需求。/ 三个会议：计划会议（产品经理与负责人）、每日例会（团队工作进度）、回顾会议（展示和改进）。<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be1-0.PNG alt></p></li><li><p>敏捷开发之极限编程：<br>一种近螺旋式的开发方法，它将复杂的开发过程分解为一个个相对比较简单的小周期；通过积极的交流、反馈以及其它一系列的方法，开发人员和客户可以非常清楚开发进度、变化、待解决的问题和潜在的困难等，并根据实际情况及时地调整开发过程。/<br>计划在极限编程中被视为临时工件；高质量的代码在极限编程项目中是必不可少的；良好的单元测试和验收测试是极限编程项目的标志。<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be1-0-1.PNG alt></p></li><li><p>小结：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be1-1.PNG alt></p></li></ul><ol start=4><li>各阶段具体任务：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be1-2.PNG alt></li></ol><h1 id=二-可行性研究-二-可行性研究二-可行性研究><a href=#%E4%BA%8C-%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6 title="二 可行性研究"></a>二 可行性研究<a hidden class=anchor aria-hidden=true href=#二-可行性研究-二-可行性研究二-可行性研究>#</a></h1><ol><li><p>目的：<br>确定问题是否值得去解决。</p></li><li><p>实质：<br>在较高层次去用抽象的方法进行系统分析、设计的过程。</p></li><li><p>内容：<br>进一步分析定义问题，导出逻辑模型，探索若干种可供选择的解决方法。</p></li><li><p>从几个方面研究可行性：<br>技术、经济、操作可行性、运行可行性、法律等。</p></li><li><p>可行性研究的步骤：</p></li></ol><ul><li>具体步骤：<br>复查系统规模和目标 -> 研究目前正在使用的系统 -> 导出新系统的高层逻辑模型 -> 进一步定义问题 -> 导出和评价供选择的解法 -> 推荐行动方针 -> 草拟开发计划 -> 书写文档提交审查</li><li>小结：<br>对问题正确定义的基础上，分析问题，导出试探性的解，（复查修正定义，再次分析问题，改进解）最终提出逻辑模型，根据逻辑模型设想可能的系统模型，并从多角度研究可行性，提交用户客户组织负责人审查批准。</li></ul><ol start=6><li><p>系统流程图（物理）：<br>概括描述物理系统的传统工具。<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be1-3.PNG alt><br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be1-4.PNG alt></p></li><li><p>数据流图（逻辑）：<br>只描述数据在软件中流动和被处理的逻辑过程。</p></li><li><p>数据字典（逻辑）：</p></li></ol><ul><li>概念：关于数据的信息集合（作为分析阶段工具，开发数据库的第一步）。数据字典和数据流图共同构成逻辑模型。</li><li>数据字典的实现，例：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be2.PNG alt></li><li>符号：<code>= 定义为</code>，<code>+ 连接两个分量</code>，<code>[ ] 其中有若干个，分量用 | 表示</code>，<code>{ } 重复，左边写下限，右边写上限</code>，<code>( ) 可选，其中的分量可有可无</code>。</li><li>举例：<code>标识符 = 字母字符 + 字母数字串</code>，<code>字母数字串 = 0{字母或数字}7</code>，<code>字母或数字 = [字母字符 | 数字字符]</code>。</li></ul><ol start=9><li>成本效益分析：</li></ol><ul><li>货币时间价值：P 为现在价值、F 为未来价值、i 为年利率、n 为年数，F=P(1+i)^n，同理 P=F/((1+i)^n)。</li><li>投资回报率：P 为现在投资额、Fi 为第 i 年底的效益（i=1、2、…）、n 为系统使用寿命、j 为投资回报率。P=Fi/((1+j)^n) ，i 从 1 到 n，累加。</li></ul><h2 id=补充-补充补充><a href=#%E8%A1%A5%E5%85%85 title=补充></a>补充<a hidden class=anchor aria-hidden=true href=#补充-补充补充>#</a></h2><ol><li>项目计划：<br>它是软件开发工作的第一步。 项目计划的目标是为项目负责人提供一个框架，使之能合理地估算软件项目开发所需的资源 、经费和开发进度，并控制软件项目开发过程按此计划进行。 在做计划时，必须就需要的人力、项目持续时间及成本作出估算。这种估算大多是参考 以前的花费作出的。软件项目计划包括二个任务：研究和估算。即通过研究确定该软件 项目的主要功能、性能和系统界面。</li></ol><ul><li>范围：项目目标、主要功能、性能限制、系统接口、特殊要求、开发概述。</li><li>资源：人员资源、硬件资源、软件资源、其他。</li><li>进度安排：工程网络图、Gantt 图、任务资源表、成本估算、培训计划。</li></ul><ol start=2><li><p>流程规范：<br>软件工程方法（怎样做）。</p></li><li><p>风险管理：</p></li></ol><ul><li>风险识别：头脑风暴法、面谈、Delphi 法、核对表、SWOT 技术。</li><li>风险量化：风险因子计算、PERT 估计、决策树分析、风险模拟。</li><li>风险应对计划制定：回避、转移、缓和、接受。</li><li>风险监控：核对表、定期项目评估、挣值分析。</li></ul><ol start=4><li>配置管理：<br>软件配置管理，贯穿于整个软件生命周期，它为软件研发提供了一套管理办法和活动原则。软件配置管理无论是对于软件企业管理人员还是研发人员都有着重要的意义。/ 关键活动包括：配置项、工作空间管理、版本控制、变更控制、状态报告、配置审计等。/ 软件配置管理可以提炼为三个方面的内容：</li></ol><ul><li>VersionControl 版本控制</li><li>ChangeControl 变更控制</li><li>ProcessSupport 过程支持</li></ul><ol start=5><li>配置管理的目的：</li></ol><ul><li>配置识别：识别配置、配置项目和基准。</li><li>配置控管：导入变更控管流程。该流程通常由变更控制委员会来运行，其主要的职责是核准或拒绝有悖任何基准的所有变更请求。</li><li>配置状态报告：记录和呈报与开发过程状态相关的所有必要信息。</li><li>配置审核：确保这些配置包含所有预期内容，且备有完整的规定文件（包括要求、结构规范和用户手册）。</li><li>建构管理：管理用于建构的流程和工具。</li><li>流程管理：确保遵循企业组织的开发流程。</li><li>环境管理：管理承载系统的软硬件。</li><li>团队合作：促进流程中团队彼此间的交互。</li><li>缺陷追踪：确保可溯及每个缺陷的源头。</li></ul><h1 id=三-需求分析-三-需求分析三-需求分析><a href=#%E4%B8%89-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90 title="三 需求分析"></a>三 需求分析<a hidden class=anchor aria-hidden=true href=#三-需求分析-三-需求分析三-需求分析>#</a></h1><ol><li>概念：</li></ol><ul><li>定义：确定系统必须完成哪些工作。写出软件需求规格说明书，以书面形式准确描述软件需求。</li><li>需求内容：功能需求、性能需求、可靠性需求、出错需求、接口需求、逆向需求、将来可能提出的需求。</li></ul><ol start=2><li>系统分析的数据要求：</li></ol><ul><li>建立数据模型（E-R 图）</li><li>描绘数据结构（层次方框图、Warnier 图）</li><li>数据结构规范化</li></ul><ol start=3><li>需求分析中的三种模型：</li></ol><ul><li>数据模型（E-R 图）。</li><li>功能模型（数据流图）。</li><li>行为模型（状态转换图）。<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be2-1.PNG alt></li></ul><ol start=4><li>三种模型对应的三种图：</li></ol><ul><li><p>E-R 图：由数据对象（矩形）、属性（圆角矩形）、关系（菱形）组成。<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be3.PNG alt></p></li><li><p>数据流图：由起点 / 终点（矩形）、数据处理（标号圆角矩形）、数据存储（标号不封闭矩形）、数据流（箭头）组成。<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be4.PNG alt></p></li><li><p>状态转换图：由状态、事件组成。<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be5.PNG alt></p></li></ul><ol start=5><li>补充：</li></ol><ul><li><p>结构化分析方法：<br>传统软件方法学使用结构化分析技术。实质上是一种建模活动，在需求分析阶段通常建立数据模型（E-R 图）、功能模型（数据流图）、行为模型（状态转换图）。</p></li><li><p>书写需求分析文档：<br>通常从需求的一致性、完整性、现实性、有效性 4 个方面复审软件需求规格说明书。通过严格评审和用户确认后，作为此阶段的最终成果。</p></li><li><p>需求分析与可行性研究间的关系：<br>软件需求分析就是把软件计划期间建立的软件可行性分析求精和细化，分析各种可能的解法，并且分配给各个软件元素。</p></li><li><p>数据字典的作用：<br>数据字典描述在数据模型、功能模型、行为模型中出现的数据对象、控制信息的特性，给出它们的准确定义。数据字典成为把 3 种分析模型粘合在一起的 “粘合剂”。</p></li></ul><h2 id=补充-1-补充补充><a href=#%E8%A1%A5%E5%85%85-1 title=补充></a>补充<a hidden class=anchor aria-hidden=true href=#补充-1-补充补充>#</a></h2><ol><li><p>需求分析：<br>见上。</p></li><li><p>变更管理：</p><blockquote><p>参考：<br>1、 <a href=https://jingyan.baidu.com/article/fd8044fa1c6a015031137ae2.html>百度经验：如何理解变更管理</a></p></blockquote></li></ol><p>需要确保变更在可控的方式下被记录、评估、授权、确定优先级、计划、测试、实施、备案以及回顾。</p><h1 id=四-形式化说明技术略-四-形式化说明技术略四-形式化说明技术略><a href=#%E5%9B%9B-%E5%BD%A2%E5%BC%8F%E5%8C%96%E8%AF%B4%E6%98%8E%E6%8A%80%E6%9C%AF%EF%BC%88%E7%95%A5%EF%BC%89 title="四 形式化说明技术（略）"></a>四 形式化说明技术（略）<a hidden class=anchor aria-hidden=true href=#四-形式化说明技术略-四-形式化说明技术略四-形式化说明技术略>#</a></h1><p><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be5-0.PNG alt></p><h1 id=五-总体设计系统设计-五-总体设计系统设计五-总体设计系统设计><a href=#%E4%BA%94-%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%89 title="五 总体设计（系统设计）"></a>五 总体设计（系统设计）<a hidden class=anchor aria-hidden=true href=#五-总体设计系统设计-五-总体设计系统设计五-总体设计系统设计>#</a></h1><ol><li><p>设计原理：<br>模块化、模块独立、抽象、逐步求精、信息隐藏、局部化。</p></li><li><p>设计任务与过程：</p></li></ol><ul><li>总体设计任务：用抽象概括的方式确定系统如何完成预定的任务，并确定组成系统的每个程序的结构。</li><li>总体设计过程：系统设计（全局。数据流图触发确定系统的具体实现物理方案）；结构设计（局部。确定软件结构。软件由哪些模块组成，及其动态调用过程。/ 功能分解、设计软件结构、设计数据库、制定测试文档）。</li></ul><ol start=3><li>模块化、模块独立概念：</li></ol><ul><li>模块化：把程序划分为独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体。</li><li>模块独立：是抽象、模块化（低耦合）、信息隐藏、局部化（高内聚）概念的直接结果。</li></ul><ol start=4><li>模块独立程度的定性度量标准（低耦合与高内聚）：</li></ol><ul><li>概念：耦合：模块间互连程度。/ 内聚：一个模块内各个元素彼此结合的紧密程度。</li><li>六种耦合：无直接耦合、数据耦合、标记耦合、控制耦合、公共环境耦合、内容耦合。</li><li>六种内聚：功能内聚、顺序内聚，通信内聚、过程内聚，时间内聚、逻辑内聚、偶然内聚。</li></ul><ol start=5><li>描述软件结构的图形工具：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be5-1.PNG alt></li></ol><ul><li>层次方框图：<br>层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构。</li></ul><p>a) 层次图、HIPO 图：（层次图无 HIPO 图中的标号）。<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be6.PNG alt></p><p>b) 结构图：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be7.PNG alt></p><ul><li><p>Warnier 图:<br>和层次方框图类似，Warnier 图也用树形结构描绘信息，但是这种图形工具比层次方框图提供了更丰富的描绘手段。<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be7-1.PNG alt></p></li><li><p>IPO 图：<br>IPO 图是输入、处理、输出图的简称，能够方便地描绘输入数据、对数据的处理和输出数据之间的关系。<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be7-2.PNG alt></p></li></ul><ol start=6><li>数据字典、数据流图、数据库间的关系：</li></ol><ul><li>数据字典是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合。</li><li>数据字典、数据流图共同构成逻辑模型。</li><li>从数据字典、数据流图出发，首先得到的是数据库的概念结构。</li><li>小结：（数据字典 -> 数据流图）可行性研究的逻辑模型 -> 数据库的概念模型</li></ul><ol start=7><li><p>启发式规则：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be7-3.PNG alt></p></li><li><p>面向数据流的设计方法（结构化设计方法）：</p></li></ol><ul><li>概念：把数据流图变成软件结构。</li><li>方法（变换分析设计）：数据流图求精 -> 独立出变化中心 -> 各个控制模块 -> 映射成软件中适当的模块<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be7-4.PNG alt></li></ul><ol start=9><li>变换流与事物流：</li></ol><ul><li>数据流图（DFD）一般可分为 “变换流”，“事物流” 两种。这是信息流的两种类型。</li><li>“变换流”：由输入、处理、输出三部分组成，是一顺序结构。</li><li>“事物流”：它的某个加工，分离成许多分散的数据流，形成许多加工路径，并且根据输入值选择其中一个路径来执行。</li></ul><ol start=10><li>从数据流导出软件的层次结构：</li></ol><ul><li>数据流图反应的是数据的系统逻辑模型，是信息流在系统中的流动反应，结构图是系统的物理模型，他反应的是系统的层次结构和功能关系。</li><li>在系统设计阶段，可以根据 DFD 图，分别通过变换分析和事务分析方法，先设计结构图的顶端主模块，然后自顶向下逐步细化，从 DFD 图导出满足数据流图要求的、标准形式的系统结构图。</li></ul><ol start=11><li>总体设计与需求分析间的关系：<br>总体设计需求分析的结果，需求分析是系统设计的依据。/ 补充：将逻辑模型（分析模型）转换为物理模型（设计模型）。</li></ol><h2 id=补充-2-补充补充><a href=#%E8%A1%A5%E5%85%85-2 title=补充></a>补充<a hidden class=anchor aria-hidden=true href=#补充-2-补充补充>#</a></h2><ol><li>架构设计：</li></ol><ul><li><p>它是一个软件系统从整体到部分的最高层次的划分。/ 一个系统通常是由元件组成的，而这些元件如何形成、相互之间如何发生作用，则是关于这个系统本身结构的重要信息。</p></li><li><p>架构设计详细地说，就是要包括架构元件（Architecture Component）、联结器（Connector）、任务流（TASk-flow）。所谓架构元素，也就是组成系统的核心” 砖瓦”，而联结器则描述这些元件之间通讯的路径、通讯的机制、通讯的预期结果，任务流则描述系统如何使用这些元件和联结器完成某一项需求。</p></li><li><p>三个方面：<br>逻辑架构、物理架构、系统架构。</p></li></ul><ol start=2><li>技术选型：</li></ol><ul><li>参考：<a href=https://blog.csdn.net/andrewniu/article/details/78688371>架构设计和技术选型的思路总结</a></li></ul><ol start=3><li>重构：</li></ol><ul><li><p>概念：<br>重构（Refactoring）就是通过调整程序代码改善软件的质量、性能，使其程序的设计模式和架构更趋合理，提高软件的扩展性和维护性。</p></li><li><p>重构的时机：<br>在添加新功能时进行重构、在修改 bug 时进行重构、在代码复审时进行重构、到了最后的交付期限不进行重构。</p></li><li><p>重构难题：<br>（a 关系数据库与面向对象编程的问题——在对象模型和数据库模型之间插入一个分隔层，这就可以隔离两个模型各自的变化，升级某一模型时只需同时升级上述的分隔层即可，这样的分隔层会增加系统复杂度，但是能增加灵活度。/ （b<br>修改接口的问题——修改已发布的接口，因为已发布的接口会供外部人员（其它公司）使用，因此修改接口会导致引用接口的其它程序不修改程序就无法运行。修改接口的最好的办法是增加一个新的接口，让旧接口调用新接口，这样原来的程序就不用修改了。对于接口的另一个建议是尽量不要发布接口。</p></li></ul><h1 id=六-详细设计模块设计-六-详细设计模块设计六-详细设计模块设计><a href=#%E5%85%AD-%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%EF%BC%88%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%EF%BC%89 title="六 详细设计（模块设计）"></a>六 详细设计（模块设计）<a hidden class=anchor aria-hidden=true href=#六-详细设计模块设计-六-详细设计模块设计六-详细设计模块设计>#</a></h1><ol><li>结构程序设计概念：<br>是进行以模块功能和处理过程设计为主的详细设计的基本原则。结构化程序设计是过程式程序设计的一个子集，它对写入的程序使用逻辑结构，使得理解和修改更有效更容易。</li></ol><ul><li>经典的结构程序设计：三种基本控制结构。</li><li>扩展的结构程序设计：允许使用 do-case、do-until 循环结构。</li><li>修正的结构程序设计：允许加上 break 结构。</li></ul><ol start=2><li>过程设计工具：<br>用图形、表格、语言。</li></ol><ul><li>程序流程图：不易表示数据结构。</li><li>盒图（N-S 图）：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be8.PNG alt></li><li>PAD 图（问题分析图）：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be9.PNG alt></li><li>判定树。<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be10.PNG alt></li><li>判定表。<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be11.PNG alt></li><li>过程设计语言（PDL 伪码）。</li></ul><ol start=3><li><p>Jackson 程序设计方法：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be12.PNG alt><br>从目标系统的输入、输出数据结构入手，导出程序框架结构，再补充其它细节，就可得到完整的程序结构图。这一方法对输入、输出数据结构明确的中小型系统特别有效，如商业应用中的文件表格处理。该方法也可与其它方法结合，用于模块的详细设计。</p></li><li><p>Warnier 程序设计方法：<br>Warnier 提出的软件开发方法与 Jackson 方法类似。差别有三点：一是它们使用的图形工具不同，分别使用 Warnier 图和 Jackson 图；另一个差别是使用的伪码不同；最主要的差别是在构造程序框架时，Warnier 方法仅考虑输入数据结构，而 Jackson 方法不仅考虑输入数据结构，而且还考虑输出数据结构。</p></li><li><p>程序复杂结构的定量度量：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be13.PNG alt><br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be14.PNG alt></p></li></ol><h1 id=七-实现编码单元测试综合测试-七-实现编码单元测试综合测试七-实现编码单元测试综合测试><a href=#%E4%B8%83-%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%BC%96%E7%A0%81%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E7%BB%BC%E5%90%88%E6%B5%8B%E8%AF%95%EF%BC%89 title="七 实现（编码、单元测试、综合测试）"></a>七 实现（编码、单元测试、综合测试）<a hidden class=anchor aria-hidden=true href=#七-实现编码单元测试综合测试-七-实现编码单元测试综合测试七-实现编码单元测试综合测试>#</a></h1><ol><li><p>编码：<br>选择程序设计语言、编码风格。</p></li><li><p>测试等见最后的总结。</p></li><li><p>黑盒测试之等价划分方法：</p></li></ol><ul><li>有 / 无效等价类</li><li>测试用例<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be15.PNG alt></li></ul><ol start=4><li><p>黑盒测试之边界值分析方法：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be16.PNG alt></p></li><li><p>白盒测试之逻辑覆盖：<br><a href=https://blog.csdn.net/cyjs1988/article/details/80341415>参考：白盒测试：语句覆盖、条件覆盖、判定覆盖、条件 - 判定覆盖、组合覆盖、路径覆盖</a><br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be17.PNG alt><br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be18.PNG alt></p></li></ol><h1 id=八-维护-八-维护八-维护><a href=#%E5%85%AB-%E7%BB%B4%E6%8A%A4 title="八 维护"></a>八 维护<a hidden class=anchor aria-hidden=true href=#八-维护-八-维护八-维护>#</a></h1><ol><li><p>四项活动：<br>改正性维护、适应性维护、完善性维护、预防性维护。</p></li><li><p>决定软件可维护性因素：<br>可理解性、可测试性、可修改性、可靠性、可移植性、可使用性。</p></li></ol><h1 id=九十-面向对象方法学引论与面向对象分析-九十-面向对象方法学引论与面向对象分析九十-面向对象方法学引论与面向对象分析><a href=#%E4%B9%9D%E3%80%81%E5%8D%81-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%AD%A6%E5%BC%95%E8%AE%BA%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90 title="九、十 面向对象方法学引论与面向对象分析"></a>九、十 面向对象方法学引论与面向对象分析<a hidden class=anchor aria-hidden=true href=#九十-面向对象方法学引论与面向对象分析-九十-面向对象方法学引论与面向对象分析九十-面向对象方法学引论与面向对象分析>#</a></h1><ol start=2><li><p>面向对象开发方法：</p></li><li><p>概念：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be19.PNG alt><br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be20.PNG alt></p></li><li><p>面向对象三大特性：<br>封装、继承、多态。</p></li><li><p>面向对象建模：</p></li></ol><ul><li>定义类：类名、属性、服务。</li></ul><ol start=5><li>面向对象分析之建模的三个模型：</li></ol><ul><li>对象模型：静态结构。定义了做事情的实体。</li><li>功能模型：功能。系统应该做什么。</li><li>动态模型：交互次序。规定了什么时候做。</li></ul><ol start=6><li><p>面向对象分析之五个层次：<br>主题层、类与对象、结构层、属性层、服务层。</p></li><li><p>UML：<br><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be21.PNG alt></p></li></ol><h1 id=十一-面向对象设计-十一-面向对象设计十一-面向对象设计><a href=#%E5%8D%81%E4%B8%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1 title="十一 面向对象设计"></a>十一 面向对象设计<a hidden class=anchor aria-hidden=true href=#十一-面向对象设计-十一-面向对象设计十一-面向对象设计>#</a></h1><ol><li>概念：<br>模块化、低耦合高内聚、抽象、信息隐藏。</li></ol><h1 id=十二第十二章略-十二第十二章略十二第十二章略><a href=#%E5%8D%81%E4%BA%8C%EF%BC%88%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E7%95%A5%EF%BC%89 title=十二（第十二章略）></a>十二（第十二章略）<a hidden class=anchor aria-hidden=true href=#十二第十二章略-十二第十二章略十二第十二章略>#</a></h1><h1 id=十三-软件项目管理-十三-软件项目管理十三-软件项目管理><a href=#%E5%8D%81%E4%B8%89-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86 title="十三 软件项目管理"></a>十三 软件项目管理<a hidden class=anchor aria-hidden=true href=#十三-软件项目管理-十三-软件项目管理十三-软件项目管理>#</a></h1><p><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%bex.PNG alt></p><h1 id=十四-总结知识框架-十四-总结知识框架十四-总结知识框架><a href=#%E5%8D%81%E5%9B%9B-%E6%80%BB%E7%BB%93%EF%BC%88%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%EF%BC%89 title="十四 总结（知识框架）"></a>十四 总结（知识框架）<a hidden class=anchor aria-hidden=true href=#十四-总结知识框架-十四-总结知识框架十四-总结知识框架>#</a></h1><blockquote><p>仅针对本书。</p></blockquote><p><img loading=lazy src=https://marlous.github.io/2018/11/04/%e3%80%8a%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e5%af%bc%e8%ae%ba%e3%80%8b%e5%bc%a0%e6%b5%b7%e6%bd%98%e7%89%88%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0/%e5%9b%be22.PNG alt></p><hr><ul><li><a href=/2018/11/06/UX-UI-%E4%B8%80%E7%AB%99%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%B9%B3%E5%8F%B0%EF%BC%9AAdobe-XD-%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/>← Previous Post</a></li><li><a href=/2018/11/02/%E6%BA%90%E4%BB%A3%E7%A0%81%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-Source-Insight-%E4%BD%BF%E7%94%A8%EF%BC%88%E4%BB%A5-Nginx-%E6%BA%90%E7%A0%81%E4%B8%BA%E4%BE%8B%EF%BC%89/>Next Post →</a></li></ul><ol><li><a href=#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B>软件工程</a><ol><li><a href=#1-%E5%B7%A5%E5%85%B7>1 工具</a></li><li><a href=#2-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%96%87%E6%A1%A3>2 软件工程文档</a></li></ol></li><li><a href=#%E4%B8%80-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%AD%A6%E6%A6%82%E8%BF%B0>一 软件工程学概述</a></li><li><a href=#%E4%BA%8C-%E5%8F%AF%E8%A1%8C%E6%80%A7%E7%A0%94%E7%A9%B6>二 可行性研究</a><ol><li><a href=#%E8%A1%A5%E5%85%85>补充</a></li></ol></li><li><a href=#%E4%B8%89-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90>三 需求分析</a><ol><li><a href=#%E8%A1%A5%E5%85%85-1>补充</a></li></ol></li><li><a href=#%E5%9B%9B-%E5%BD%A2%E5%BC%8F%E5%8C%96%E8%AF%B4%E6%98%8E%E6%8A%80%E6%9C%AF%EF%BC%88%E7%95%A5%EF%BC%89>四 形式化说明技术（略）</a></li><li><a href=#%E4%BA%94-%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1%EF%BC%88%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%EF%BC%89>五 总体设计（系统设计）</a><ol><li><a href=#%E8%A1%A5%E5%85%85-2>补充</a></li></ol></li><li><a href=#%E5%85%AD-%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%EF%BC%88%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%EF%BC%89>六 详细设计（模块设计）</a></li><li><a href=#%E4%B8%83-%E5%AE%9E%E7%8E%B0%EF%BC%88%E7%BC%96%E7%A0%81%E3%80%81%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E7%BB%BC%E5%90%88%E6%B5%8B%E8%AF%95%EF%BC%89>七 实现（编码、单元测试、综合测试）</a></li><li><a href=#%E5%85%AB-%E7%BB%B4%E6%8A%A4>八 维护</a></li><li><a href=#%E4%B9%9D%E3%80%81%E5%8D%81-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E5%AD%A6%E5%BC%95%E8%AE%BA%E4%B8%8E%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90>九、十 面向对象方法学引论与面向对象分析</a></li><li><a href=#%E5%8D%81%E4%B8%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1>十一 面向对象设计</a></li><li><a href=#%E5%8D%81%E4%BA%8C%EF%BC%88%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E7%95%A5%EF%BC%89>十二（第十二章略）</a></li><li><a href=#%E5%8D%81%E4%B8%89-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86>十三 软件项目管理</a></li><li><a href=#%E5%8D%81%E5%9B%9B-%E6%80%BB%E7%BB%93%EF%BC%88%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%EF%BC%89>十四 总结（知识框架）</a></li></ol><h5 id=featured-tagstags><a href=/tags/>FEATURED TAGS</a><a hidden class=anchor aria-hidden=true href=#featured-tagstags>#</a></h5><h2 id=title-速查><a href=/tags/#%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0 title=学习笔记>学习笔记</a>&mdash;
title: 速查</h2><p><strong>Variables:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>goCopy</span> <span class=nx>codevar</span> <span class=nx>name</span> <span class=kt>string</span> <span class=p>=</span> <span class=s>&#34;John&#34;</span>
</span></span><span class=line><span class=cl><span class=nx>age</span> <span class=o>:=</span> <span class=mi>30</span> <span class=c1>// type inferred as int
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>city</span> <span class=kt>string</span> <span class=p>=</span> <span class=s>&#34;New York&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>zipCode</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>10001</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p><strong>Data Types:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>goCopy</span> <span class=nx>codebool</span>
</span></span><span class=line><span class=cl><span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=p>,</span> <span class=kt>int8</span><span class=p>,</span> <span class=kt>int16</span><span class=p>,</span> <span class=kt>int32</span><span class=p>,</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl><span class=kt>uint</span><span class=p>,</span> <span class=kt>uint8</span><span class=p>,</span> <span class=kt>uint16</span><span class=p>,</span> <span class=kt>uint32</span><span class=p>,</span> <span class=kt>uint64</span><span class=p>,</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl><span class=kt>byte</span> <span class=p>(</span><span class=nx>alias</span> <span class=k>for</span> <span class=kt>uint8</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kt>rune</span> <span class=p>(</span><span class=nx>alias</span> <span class=k>for</span> <span class=kt>int32</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kt>float32</span><span class=p>,</span> <span class=kt>float64</span>
</span></span><span class=line><span class=cl><span class=kt>complex64</span><span class=p>,</span> <span class=kt>complex128</span>
</span></span></code></pre></div><p><strong>Constants:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>goCopy</span> <span class=nx>codeconst</span> <span class=nx>pi</span> <span class=p>=</span> <span class=mf>3.14</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>monday</span> <span class=p>=</span> <span class=s>&#34;Monday&#34;</span>
</span></span><span class=line><span class=cl>    <span class=nx>tuesday</span> <span class=p>=</span> <span class=s>&#34;Tuesday&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p><strong>Control Structures:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>goCopy</span> <span class=nx>codeif</span> <span class=nx>age</span> <span class=o>&gt;=</span> <span class=mi>18</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;You are an adult&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;You are not an adult&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>5</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>switch</span> <span class=nx>day</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=s>&#34;Monday&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Today is Monday&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=s>&#34;Tuesday&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Today is Tuesday&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Unknown day&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><strong>Arrays and Slices:</strong></p><pre tabindex=0><code>goCopy codevar names [3]string
names[0] = &#34;John&#34;
names[1] = &#34;Jane&#34;
names[2] = &#34;Bob&#34;

scores := []int{10, 20, 30}
scores = append(scores, 40)
</code></pre><p><strong>Maps:</strong></p><pre tabindex=0><code>goCopy codeages := map[string]int{
    &#34;John&#34;: 30,
    &#34;Jane&#34;: 25,
    &#34;Bob&#34;: 35,
}

fmt.Println(ages[&#34;John&#34;]) // Output: 30

delete(ages, &#34;Bob&#34;)
</code></pre><p><strong>Functions:</strong></p><pre tabindex=0><code>goCopy codefunc sayHello(name string) {
    fmt.Println(&#34;Hello,&#34;, name)
}

func add(x int, y int) int {
    return x + y
}

func calculate(x, y int) (int, int) {
    sum := x + y
    diff := x - y
    return sum, diff
}
```---
title: 数据结构
---
---
title: 数据结构
---

### 单向链表

```c
//插入节点
newNode-&gt;next = curNode-&gt;next;
curNode-&gt;next = newNode;

//遍历节点
for (p = head-&gt;next; p != NULL; p = p-&gt;next)

//删除节点
preNode-&gt;next = curNode-&gt;next;
free(curNode);
</code></pre><h2 id=树>树<a hidden class=anchor aria-hidden=true href=#树>#</a></h2><h3 id=树相关定义>树相关定义<a hidden class=anchor aria-hidden=true href=#树相关定义>#</a></h3><h2 id=叶子度为零的节点>根节点：没有父节点
非根节点：只有一个父节点
节点的度：子树的数目
叶子：度为零的节点</h2><h2 id=title-复试问答>title: 复试问答<a hidden class=anchor aria-hidden=true href=#title-复试问答>#</a></h2><hr><hr><p>你为什么选择跨专业考研？</p><pre tabindex=0><code></code></pre><p>自我介绍</p><pre tabindex=0><code>各位老师上午好，我是xxx，非常荣幸能够进入林科大软件工程的复试。我本科就读于中南林业科技大学的食品质量与安全专业，在林科大的四年里，优越的人文环境，浓厚的学习氛围时刻熏陶着我，专业成绩良好。
我选择跨考软件工程这一专业，最重要的原因就是热爱，对编程的兴趣起源于高中信息技术教材上的VB语言，从简单的打字测速程序到复杂的管理系统让我感受到了编程的强大力量。其次是因为一直以来我的理想就是成为一名程序员，我在高考后de暑假自学了C语言，本科期间自学了python和数据结构。
不忘初心，方得始终，希望有机会能够继续跟随学校优秀的老师们学习软件工程相关知识，相信凭借自己的勤奋和踏实，能在计算机领域提升自己的专业素养和实践能力，谢谢老师，我的自我介绍完毕。
</code></pre><pre tabindex=0><code>Hello teachers, good morning. I am xxx, and it is my great honor to have the opportunity to participate in the software engineering interview at Central South University of Forestry and Technology. I majored in Food Quality and Safety at Central South University of Forestry and Technology for my undergraduate studies. During my four years at Central South University of Forestry and Technology, I have been influenced by the excellent humanistic environment and strong academic atmosphere, and my academic performance was outstanding.

I chose to switch to software engineering because of my passion for programming. My interest in programming started from the VB language in the information technology textbook in high school. From simple typing speed measurement programs to complex management systems, I felt the power of programming. Moreover, my ideal has always been to become a programmer. After the college entrance examination, I self-studied C language during the summer vacation, and during my undergraduate studies, I self-studied Python and data structures.

I will not forget my original intention and will always stick to it. I hope to have the opportunity to continue to learn software engineering-related knowledge from the excellent teachers at the university. I believe that with my diligence and hard work, I can improve my professional skills and practical abilities in the field of computer science. Thank you, teachers. That concludes my self-introduction.
</code></pre><hr><h2 id=title-软件工程导论>title: 软件工程导论<a hidden class=anchor aria-hidden=true href=#title-软件工程导论>#</a></h2><hr><h2 id=title-软件工程笔记>title: 软件工程笔记<a hidden class=anchor aria-hidden=true href=#title-软件工程笔记>#</a></h2><h3 id=软件危机>软件危机<a hidden class=anchor aria-hidden=true href=#软件危机>#</a></h3><pre tabindex=0><code>定义：软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题
原因：
    （1）客观原因
    ① 软件是计算机系统中的逻辑部件，缺乏“可见性”，因此管理和控制软
    件开发过程相当困难
    ② 软件维护通常意味着改正或修改原来的设计，因此软件较难维护
    ③ 软件规模庞大，而程序复杂性将随着程序规模的增加而呈指数上升
    （2）主观原因
    ① 存在与软件开发和维护有关的许多错误认识和做法
    ② 对用户要求没有完整准确的认识就匆忙着手编写程序
    ③ 开发人员只重视程序而忽视软件配置的其余成分（文档和数据等）
    ④ 软件开发人员轻视维护
</code></pre><h3 id=软件工程>软件工程<a hidden class=anchor aria-hidden=true href=#软件工程>#</a></h3><p>采用<strong>工程</strong>的概念、原理、技术和方法来开发与维护软件，把经过时间考
验而证明正确的<strong>管理技术</strong>和当前能够得到的最好的<strong>技术方法</strong>结合起来，
以经济地开发出高质量的软件并有效地维护它</p><pre tabindex=0><code>
软件工程七条基本原理
    1.用分阶段的生命周期计划严格管理
    2.坚持进行阶段评审
    3.实行严格的产品控制
    4.采用现代程序设计技术
    5.结果应能清楚地审查
    6.开发小组的人员应该少而精
    7.承认不断改进软件工程实践的必要性
软件工程方法学
    技术方法的集合称为方法学（范型）。分为传统方法学和面向对象方法学
    软件工程方法学包括3个要素：方法、工具和过程
</code></pre><h3 id=传统方法学生命周期方法学或结构化范型>传统方法学（生命周期方法学或结构化范型）<a hidden class=anchor aria-hidden=true href=#传统方法学生命周期方法学或结构化范型>#</a></h3><p><strong>优点</strong>
把软件生命周期划分成若干相对独立、简单的<strong>阶段</strong>，便于不同人员分工<strong>协作</strong>，降低开发的困难程度
开发过程中采用科学的<strong>管理技术</strong>和良好的<strong>技术方法</strong>，且在每个阶段结束之前都进行严格的<strong>审查</strong>，保证了软件的质量，提高了软件的可维护性
大大提高了软件开发的成功率和生产率
<strong>缺点</strong>
不适用于软件<strong>规模</strong>庞大、或者对软件的<strong>需求</strong>是模糊的或会随时间变化而变化的情况
结构化范型技术把<strong>数据和操</strong>作人为地分离成两个独立的部分，增加了软件开发与维护的难度</p><h3 id=面向对象方法学>面向对象方法学<a hidden class=anchor aria-hidden=true href=#面向对象方法学>#</a></h3><p>与传统方法学的对比
a．传统方法学强调自顶向下、逐层分解、顺序开发
b．面向对象方法学强调主动地多次反复迭代地开发，保证了在各项开发活动之间的平滑过渡
优点
a．降低了软件产品的复杂性
b．提高了软件的可理解性
c．简化了软件的开发和维护工作
d．提高了软件的可重用性</p><h3 id=软件过程>软件过程<a hidden class=anchor aria-hidden=true href=#软件过程>#</a></h3><pre tabindex=0><code>定义：获得高质量软件所需要完成的一系列任务的框架
表示：生命周期模型
瀑布模型的特点: 1.阶段间具有顺序性和依赖性。 2.推迟实
现的观点。3.质量保证的观点。

快速原型 是快速建立起来的可以在计算机上运行的程序，它
所能完成的功能往往是最终产品能完成功能的一个子集。

增量模型: 它分批地逐步向用户提交产品，整个软件产品被分
解成许多个增量构件，开发人员一个构件一个构件地向用户
提交产品。

螺旋模型; 基本思想是使用原型及其他方法来尽量降低风险。
理解这种模型的一个简单方法，是把它看作在每个阶段之前
都增加了风险分析过程的快速原型模型。 (使用于内部开发
的大规模软件项目 )

喷泉模型: 强调的是“迭代”和“无缝“的特性 是典型的面
向对象的软件过程模型之一.
</code></pre><h3 id=软件周期>软件周期<a hidden class=anchor aria-hidden=true href=#软件周期>#</a></h3><pre tabindex=0><code>1.问题定义: 必须回答的关键问题是， “要解决的问题是什么? ”。
2.可行性研究: 阶段回答的关键问题是: “对于上一个阶段所确定的问题有行得通的解决办法吗? ”
3.需求分析: “目标系统必须做什么”，确定目标系统必须具备哪些功能。
4.总体设计: 必须回答的关键问题是: “概括地说，应该怎样实现目标系统? ”总体设计又称为概要设计。
5.详细设计: 关键问题是: “应该怎样具体地实现这个系统呢? ”
6.编码和单元测试: 关键任务是写出正确的容易理解、容易维护的程序模块。
7.综合测试: 关键任务是通过各种类型的测试使软件达到预定的要求。
8.软件维护: 通过各种必要的维护活动使系统持久地满足用户的需要。
</code></pre><hr><h2 id=可行性研究>可行性研究<a hidden class=anchor aria-hidden=true href=#可行性研究>#</a></h2><h3 id=可行性研究的任务>可行性研究的任务<a hidden class=anchor aria-hidden=true href=#可行性研究的任务>#</a></h3><pre tabindex=0><code>
可行性研究方面
    1.技术可行性
    2.经济可行性
    3.操作可行性
可行性研究过程
    1.复查系统规模和目标；
    2.研究目前正在使用的系统；
    3.导出新系统的高层逻辑模型；
    4.进一步定义问题；
    5.导出并评价供选择的解法；
    6.推荐行动方针；
    7.草拟开发计划；
    8书写文档提交审查。
</code></pre><h3 id=系统流程图>系统流程图<a hidden class=anchor aria-hidden=true href=#系统流程图>#</a></h3><pre tabindex=0><code>描绘物理系统，表达的是数据在系统各部件之间流动的情况
</code></pre><h3 id=数据流图>数据流图<a hidden class=anchor aria-hidden=true href=#数据流图>#</a></h3><pre tabindex=0><code>描绘数据在软件中流动和被处理的逻辑过程，表示系统逻辑模型，是功能模型
矩形：数据的源点/终点
圆角：数据处理
开口：数据存储
箭头：数据流
</code></pre><h3 id=数据字典>数据字典<a hidden class=anchor aria-hidden=true href=#数据字典>#</a></h3><pre tabindex=0><code>标识符 = 字母字符 + 字母数字串
字母数字串 = 0{字母或数字}7
字母或数字 = [字母字符 | 数字字符]
</code></pre><h3 id=成本效益分析>成本/效益分析<a hidden class=anchor aria-hidden=true href=#成本效益分析>#</a></h3><pre tabindex=0><code>目的：帮助客户组织负责人从经济角度判断是否继续投资于这项工程。
方法：
    代码行技术；
    任务分解技术
    自动估计成本技术
</code></pre><hr><h2 id=需求分析>需求分析<a hidden class=anchor aria-hidden=true href=#需求分析>#</a></h2><pre tabindex=0><code>需求分析中的三种模型：
    数据模型（E-R 图）
    功能模型（数据流图）
    行为模型（状态转换图）
</code></pre><h3 id=实体-联系图>实体-联系图<a hidden class=anchor aria-hidden=true href=#实体-联系图>#</a></h3><pre tabindex=0><code>包括实体（数据对象）、关系和属性3种基本成分
矩形-&gt;实体 菱形-&gt;关系 圆角-&gt;属性
</code></pre><h3 id=状态转换图>状态转换图<a hidden class=anchor aria-hidden=true href=#状态转换图>#</a></h3><pre tabindex=0><code>初态-&gt;实心圆 终态-&gt;空心包实心圆 中间-&gt;圆角
</code></pre><h3 id=其他图形工具>其他图形工具<a hidden class=anchor aria-hidden=true href=#其他图形工具>#</a></h3><pre tabindex=0><code>1.层次方框图（数据层次结构）
2.Warnier图
3.IPO图
</code></pre><hr><h2 id=总体设计>总体设计<a hidden class=anchor aria-hidden=true href=#总体设计>#</a></h2><h3 id=设计原理>设计原理<a hidden class=anchor aria-hidden=true href=#设计原理>#</a></h3><pre tabindex=0><code>模块化
模块独立（低耦合与高内聚）
抽象
逐步求精
信息隐藏和局部化
</code></pre><h3 id=描绘软件结构的图形工具>描绘软件结构的图形工具<a hidden class=anchor aria-hidden=true href=#描绘软件结构的图形工具>#</a></h3><pre tabindex=0><code>1.层次图
2.HIPO图
3.结构图
</code></pre><h3 id=面向数据流的设计方法>面向数据流的设计方法<a hidden class=anchor aria-hidden=true href=#面向数据流的设计方法>#</a></h3><pre tabindex=0><code>1.变换流
2.事务流
</code></pre><hr><h2 id=详细设计>详细设计<a hidden class=anchor aria-hidden=true href=#详细设计>#</a></h2><h3 id=结构程序设计>结构程序设计<a hidden class=anchor aria-hidden=true href=#结构程序设计>#</a></h3><pre tabindex=0><code>结构化程序：仅顺序、选择和循环，且单入单出的程序
</code></pre><h3 id=人机界面设计>人机界面设计<a hidden class=anchor aria-hidden=true href=#人机界面设计>#</a></h3><pre tabindex=0><code></code></pre><h3 id=过程设计>过程设计<a hidden class=anchor aria-hidden=true href=#过程设计>#</a></h3><pre tabindex=0><code>1.程序流程图（程序框图）
2.盒图（N-S图）
3.PAD图（问题分析图）
4.判定表
5.判断树
6.过程设计语言（PDL，伪码）
</code></pre><p>PAD图</p><p><img loading=lazy src=https://raw.githubusercontent.com/zcy2875634712/blogImg/master/dfc4789688644722856588bee556f0f0tplv-mlhdmxsy5m-q7500.jpeg alt=dfc4789688644722856588bee556f0f0tplv-mlhdmxsy5m-q7500></p><h3 id=面向数据结构的设计方法>面向数据结构的设计方法<a hidden class=anchor aria-hidden=true href=#面向数据结构的设计方法>#</a></h3><pre tabindex=0><code></code></pre><h3 id=程序复杂程度的定量度量价值>程序复杂程度的定量度量价值<a hidden class=anchor aria-hidden=true href=#程序复杂程度的定量度量价值>#</a></h3><pre tabindex=0><code>环形复杂度（McCabe方法）：
    V(G)=区域数
    V(G)=E-N+2（E:edge N:node）
    V(G)=P+1（P是判断节点数）
</code></pre><hr><h2 id=实现编码单元测试综合测试>实现（编码、单元测试、综合测试）<a hidden class=anchor aria-hidden=true href=#实现编码单元测试综合测试>#</a></h2><h3 id=测试>测试<a hidden class=anchor aria-hidden=true href=#测试>#</a></h3><pre tabindex=0><code>软件测试的定义
    测试是为了发现程序中的错误而执行程序的过程。
软件测试的目标
    好的测试方案是尽可能发现迄今为止尚未发现的错误的测试方案
    成功的测试是发现了至今为止尚未发现的错误的测试
    根本目标是尽可能多地发现并排除软件中潜藏的错误，最终把一个高质量的软件系统交给用户使用

测试方法：白盒测试和黑盒测试
测试步骤：
    单元测试（模块测试）：测试模块，发现编码和详细设计的错误
    子系统测试：测试模块接口
    系统测试：发现软件设计中和需求说明中的错误
    验收测试（确认测试）：发现系统需求说明书中的错误
</code></pre><h3 id=白盒测试>白盒测试<a hidden class=anchor aria-hidden=true href=#白盒测试>#</a></h3><pre tabindex=0><code>1.语句覆盖：一个if要一个测试用例
2.判断覆盖：一个if要两个测试用例
3.条件覆盖：每个条件取值至少出现一次
4.判断/条件覆盖：
5.条件组合覆盖：每个判定表达式中条件的各种可能组合都至少出现一次.

6.路径覆盖：所有节点路径数的乘积
</code></pre><h3 id=黑盒测试>黑盒测试<a hidden class=anchor aria-hidden=true href=#黑盒测试>#</a></h3><pre tabindex=0><code>1.等价划分
2.边界值分析
3.错误推测
</code></pre><h3 id=集成测试>集成测试<a hidden class=anchor aria-hidden=true href=#集成测试>#</a></h3><pre tabindex=0><code>底驱顶根：自顶向下需要存根程序，自底向上需要驱动程序
</code></pre><h3 id=确认测试>确认测试<a hidden class=anchor aria-hidden=true href=#确认测试>#</a></h3><pre tabindex=0><code>Alpha测试：开发者场所，受控
Beta测试：客户场所，不受控
</code></pre><hr><h2 id=面向对象>面向对象<a hidden class=anchor aria-hidden=true href=#面向对象>#</a></h2><p>面向对象建模</p><pre tabindex=0><code>对象模型：
动态模型：
功能模型：
在UML图中：
    对象模型：类图
    动态模型：状态图和事件追踪图
    功能模型：用例图
</code></pre><p>类图</p><pre tabindex=0><code>泛化（继承）：空心三角和实线
聚合：空心菱形
组合：实心菱形
</code></pre><h3 id=设计准则>设计准则<a hidden class=anchor aria-hidden=true href=#设计准则>#</a></h3><h3 id=软件重用>软件重用<a hidden class=anchor aria-hidden=true href=#软件重用>#</a></h3><pre tabindex=0><code>重用也称为再用或复用，是指同一事物不经修改或稍加改动就多次重复使用
重用级别：
    代码重用
    设计结果重用
    分析结果重用
类构件的重用方式：
    实例重用
    继承重用
    多态重用
</code></pre><h3 id=设计优化>设计优化<a hidden class=anchor aria-hidden=true href=#设计优化>#</a></h3><pre tabindex=0><code>确认优先级
提高效率的几项技术
    增加冗余关联以提高访问效率
    调整查询次序
    保留派生属性
调整继承关系
    设计类继承的方法
    为提高继承程度而修改类定义
    利用委托实现操作共享
</code></pre><h3 id=程序设计风格>程序设计风格<a hidden class=anchor aria-hidden=true href=#程序设计风格>#</a></h3><pre tabindex=0><code>1.提高可重用性
    （1）提高方法的内聚
    （2）减小方法的规模
    （3）保持方法的一致性
    （4）把策略与实现分开
    （5）全面覆盖输入条件的各种可能组合
    （6）尽量不使用全局信息
    （7）充分利用继承机制
2.提高可扩充性
提高可重用性的准则同样也能提高程序的可扩充性
    （1）封装类的实现细节
    （2）不要用一个方法遍历多条关联链。
    （3）避免使用多分支语句
    （4）精心选择和定义公有方法
3.提高健壮性
    （1）预防用户的错误操作
    （2）检查参数的合法性
    （3）不要预先设定数据结构的限制条件
    （4）先测试后优化
</code></pre><h3 id=设计测试用例>设计测试用例<a hidden class=anchor aria-hidden=true href=#设计测试用例>#</a></h3><pre tabindex=0><code>测试类
    随机测试
    划分测试
    基于故障测试
集成测试
    多类测试：随机测试和划分测试
    从动态模型导出测试用例
</code></pre><hr><h2 id=软件项目管理>软件项目管理<a hidden class=anchor aria-hidden=true href=#软件项目管理>#</a></h2><p>软件项目管理就是通过<strong>计划、组织和控制</strong>等一系列活动，合理地配置
和使用各种资源，以达到既定目标的过程。</p><p>计划：估计软件规模，工作量估算，进度计划
组织：民主制程序员组，主程序员组，现代程序员组
控制：质量保证，配置管理</p><h2 id=大纲>大纲<a hidden class=anchor aria-hidden=true href=#大纲>#</a></h2><pre tabindex=0><code>一、软件工程概述
软件生命周期、软件过程
二、需求分析
需求分析的任务、建模和规格说明、UML（类图、状态
图、顺序图、活动图)
三、总体设计
设计原理、启发规则、面向数据流的设计方法、
四、详细设计和实现
过程设计工具、面向数据结构的设计方法、程序复杂度的度量、编码、软件测试基础、单元测试、集成测试、白盒测试、黑盒测试
五、面向对象分析、設計和实现
面向对象分析过程、对象模型、动态模型、功能模型
面向对象设计准则、软件重用、设计优化、程序设计风格、设计测试用例
六、软件项目管理
工作量估算、进度计划、质量保证、软件配置
</code></pre><hr><h2 id=title-神经网络>title: 神经网络<a hidden class=anchor aria-hidden=true href=#title-神经网络>#</a></h2><h3 id=神经元>神经元<a hidden class=anchor aria-hidden=true href=#神经元>#</a></h3><h2 id=title-原来这就是网络>一个神经元的功能是求得输入向量与权向量的内积后加偏置，经一个非线性传递函数得到一个标量结果。&mdash;
title: 原来这就是网络</h2><p>原文：https://www.cnblogs.com/flashsun/p/14266148.html</p><h2 id=家庭网络>家庭网络<a hidden class=anchor aria-hidden=true href=#家庭网络>#</a></h2><p><img loading=lazy src=https://raw.githubusercontent.com/zcy2875634712/blogImg/master/%E7%AC%AC2%E5%B8%A7.png alt=第2帧></p><p>分组交换：在通信过程中，通信双方以<strong>分组</strong>为单位、使用<strong>存储-转发</strong>机制实现数据交互的通信方式</p><h2 id=分组由一块用户数据和必要的地址和管理信息组成保证网络能够将数据传递到目标类似于从邮局发送的包裹上注明的地址一样只有提供给网络这些信息网络邮局才能把分组包裹往正确的地址传送><strong>分组</strong>：由一块用户数据和必要的地址和管理信息组成，保证网络能够将数据传递到目标。类似于从邮局发送的包裹上注明的地址一样,只有提供给网络这些信息，网络（邮局）才能把分组（包裹）往正确的地址传送<a hidden class=anchor aria-hidden=true href=#分组由一块用户数据和必要的地址和管理信息组成保证网络能够将数据传递到目标类似于从邮局发送的包裹上注明的地址一样只有提供给网络这些信息网络邮局才能把分组包裹往正确的地址传送>#</a></h2><h2 id=title-vim>title: vim<a hidden class=anchor aria-hidden=true href=#title-vim>#</a></h2><p>动词</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>d  <span class=c1># 表示删除delete</span>
</span></span><span class=line><span class=cl>r  <span class=c1># 表示替换replace</span>
</span></span><span class=line><span class=cl>c  <span class=c1># 表示修改change</span>
</span></span><span class=line><span class=cl>y  <span class=c1># 表示复制yank</span>
</span></span><span class=line><span class=cl>v  <span class=c1># 表示选取visual select</span>
</span></span></code></pre></div><p>名词</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>w  <span class=c1># 表示一个单词word</span>
</span></span><span class=line><span class=cl>s  <span class=c1># 表示一个句子sentence</span>
</span></span><span class=line><span class=cl>p  <span class=c1># 表示一个段落paragraph</span>
</span></span><span class=line><span class=cl>t  <span class=c1># 表示一个 HTML 标签tag</span>
</span></span></code></pre></div><p>介词</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>i  <span class=c1># 表示在...之内 inside</span>
</span></span><span class=line><span class=cl>a  <span class=c1># 表示环绕... around</span>
</span></span><span class=line><span class=cl>t  <span class=c1># 表示到...位置前 to</span>
</span></span><span class=line><span class=cl>f  <span class=c1># 表示到...位置上 forward</span>
</span></span></code></pre></div><p>动词+介词+名词</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>diw
</span></span><span class=line><span class=cl>di<span class=o>{</span>
</span></span></code></pre></div><hr><h2 id=title-shell>title: shell<a hidden class=anchor aria-hidden=true href=#title-shell>#</a></h2><h3 id=bash-参数拓展>Bash 参数拓展<a hidden class=anchor aria-hidden=true href=#bash-参数拓展>#</a></h3><ul><li><p>删除前缀后缀</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nb>echo</span> <span class=nv>$str</span>		<span class=c1># a.b.c.d</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>str</span><span class=p>%.*</span><span class=si>}</span>	<span class=c1># a.b.c</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>str</span><span class=p>%%.*</span><span class=si>}</span>	<span class=c1># a</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>str</span><span class=p>#*.</span><span class=si>}</span>	<span class=c1>#b.c.d</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=si>${</span><span class=nv>str</span><span class=p>##*.</span><span class=si>}</span>	<span class=c1>#d</span>
</span></span></code></pre></div></li></ul><h3 id=sed>sed<a hidden class=anchor aria-hidden=true href=#sed>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1>#删除</span>
</span></span><span class=line><span class=cl>sed <span class=s1>&#39;/^$/d&#39;</span> &lt;file&gt;
</span></span></code></pre></div><hr><h2 id=title-linux命令>title: linux命令<a hidden class=anchor aria-hidden=true href=#title-linux命令>#</a></h2><h3 id=tar>tar<a hidden class=anchor aria-hidden=true href=#tar>#</a></h3><p>解压<code>tar -xvf filename</code></p><h2 id=title-可行性研究>压缩<code>tar -zcvf filename.tar.gz filename</code>&mdash;
title: 可行性研究</h2><p>复习笔记</p><h2 id=一可行性研究的任务>一、可行性研究的任务<a hidden class=anchor aria-hidden=true href=#一可行性研究的任务>#</a></h2><p>1 可行性研究的目的
用最小的代价在尽可能短的时间内确定问题是否能够解决。
2 可行性研究的任务
（1）对以后的行动方针提出建议。
（2）分析几种主要的候选解法的利弊，研究其可行性。
3 可行性研究的3个方面
（1）技术可行性；
（2）经济可行性；
（3）操作可行性。</p><h2 id=二可行性研究过程典型的可行性研究过程为>二、可行性研究过程典型的可行性研究过程为：<a hidden class=anchor aria-hidden=true href=#二可行性研究过程典型的可行性研究过程为>#</a></h2><p>1．复查系统规模和目标；
2．研究目前正在使用的系统；
3．导出新系统的高层逻辑模型；
4．进一步定义问题；
5．导出并评价供选择的解法；
6．推荐行动方针；
7．草拟开发计划；
8．书写文档提交审查。</p><h2 id=三系统流程图>三、系统流程图<a hidden class=anchor aria-hidden=true href=#三系统流程图>#</a></h2><p>1 定义
系统流程图是概括地描绘物理系统的传统工具。
2 基本思想
用图形符号以黑盒子形式描绘组成系统的每个部件（程序、文档、数据
库、人工过程等）。
【注意】系统流程图表达的是数据在系统各部件之间流动的情况，而不
是对数据进行加工处理的控制过程。3 符号
（1）以概括的方式抽象地描绘实际系统时，使用图2-1中列出的基本符
号就足够了。
图2-1
基本符号
【注意】这5种基本符号是常考点。
（2）需要更具体地描绘一个物理系统时，还需要使用图2-2中列出的系
统符号。图2-2
系统符号
【注意】系统流程图的习惯画法是使信息在图中从顶向下或从左向右流
动。</p><h2 id=四数据流图>四、数据流图<a hidden class=anchor aria-hidden=true href=#四数据流图>#</a></h2><p>1 概念
（1）定义
数据流图（DFD）是一种图形化技术。它描绘信息流和数据从输入移动到输出的过程中所经受的变换。
（2）特点
① 数据流图中没有具体的物理部件，只是描绘数据在软件中流动和被处
理的逻辑过程。
② 数据流图是系统逻辑功能的图形表示，是分析员与用户之间极好的通
信工具。
③ 设计时只需考虑系统必须完成的基本逻辑功能，不考虑怎样具体地实
现这些功能。
2 符号
如图2-3（a）所示，数据流图有4种基本符号；图2-3（b）给出了附加符
号的含义。其中星号（*）表示数据流之间是“与”关系；加号（＋）表
示“或”关系；⊕号表示只能从中选一个（互斥的关系）。图2-3
数据流图的符号
【注意】数据流中用箭头表示数据流，第5章的程序流程图中用箭头表示
的控制流。</p><h2 id=五数据字典概念>五、数据字典概念<a hidden class=anchor aria-hidden=true href=#五数据字典概念>#</a></h2><p>（1）定义
数据字典是关于数据的信息的集合，是对数据流图中包含的所有元素的
定义的集合。
（2）意义
数据流图和数据字典共同构成系统的逻辑模型。
2 组成元素
① 数据流；
② 数据流分量，即数据元素；
③ 数据存储；
④ 处理。
3 数据字典的用途
（1）作为分析阶段的工具（最重要）。
（2）数据字典中包含的每个数据元素的控制信息是很有价值的。
（3）数据字典是开发数据库的第一步，而且是很有价值的一步。4 数据字典的实现
（1）开发大型软件系统时建议使用数据字典处理程序。
（2）在开发小型软件系统时建议采用卡片形式书写数据字典
数据字典卡片</p><h2 id=六成本效益分析>六、成本/效益分析<a hidden class=anchor aria-hidden=true href=#六成本效益分析>#</a></h2><h2 id=title-详细设计>1 目的
帮助客户组织负责人从经济角度判断是否继续投资于这项工程。2 成本估计的方法
（1）代码行技术；
（2）任务分解技术；
（3）自动估计成本技术。
3 重要公式
（1）计算P元钱在n年后的价值：F=P(1+i)n，其中年利率为i。
（2）n年后能收入F元钱，计算这些钱的现在价值：P=F/(1+i)n。
（3）计算投资回收率：
P=F1/(1+j)+F2/(1+j)2+…+Fn/(1+j)n
其中，P是现在的投资额；Fi是第i年年底的效益（i＝1，2，…，n）；n
是系统的使用寿命；j是投资回收率。&mdash;
title: 详细设计</h2><p>复习笔记</p><h2 id=一结构程序设计>一、结构程序设计<a hidden class=anchor aria-hidden=true href=#一结构程序设计>#</a></h2><p>详细设计不仅仅是逻辑上正确地实现每个模块的功能，更重要的是设计
出的处理过程应该尽可能简明易懂。结构程序设计技术是实现详细设计
目标的关键技术，也是详细设计的逻辑基础。
1．经典定义
如果一个程序的代码块仅仅通过顺序、选择和循环这3种基本控制结构
进行连接，并且每个代码块只有一个入口和一个出口，则称这个程序是
结构化的。
2．控制结构
（1）基本控制结构
三种基本的控制结构是“顺序”“选择”和“循环”，它们的流程图分别为图
6-1（a），6-1（b）和6-1（c）。图6-1
三种基本的控制结构
【注意】牢记三种基本控制结构，此为常考内容。
（2）扩展的控制结构
DO UNTIL和DO CASE的流程图分别是图6-2（a）和图6-2（b）。
图6-2
其他常用的控制结构</p><h2 id=三人机界面设计>三、人机界面设计<a hidden class=anchor aria-hidden=true href=#三人机界面设计>#</a></h2><p>1 重要性
（1）对于交互式系统来说，人机界面设计和数据设计、体系结构设计及
过程设计一样重要。
（2）人机界面的质量直接影响用户对软件产品的接受程度。
2 设计问题
（1）系统响应时间；
（2）用户帮助设施；
（3）出错信息处理；
（4）命令交互。
3 设计过程
用户界面设计是一个迭代的过程，也就是说，通常先创建设计模型，再
用原型实现这个设计模型，并由用户试用和评估，然后根据用户意见进
行修改。</p><h2 id=四过程设计的工具>四、过程设计的工具<a hidden class=anchor aria-hidden=true href=#四过程设计的工具>#</a></h2><p>1 程序流程图（程序框图）（1）符号表示
程序流程图中使用的符号表示如图6-3所示。
图6-3
程序流程图中使用的符号
符号含义：（a）选择（分支）；（b）注释；（c）预先定义的处理；
（d）多分支；（e）开始或停止；（f）准备；
（g）循环上界限；（h）循环下界限；（i）虚线；（j）省略符；（k）
并行方式；（l）处理；（m）输入输出；（n）连接；（o）换页连接；
（p）控制流。
（2）优点
对控制流程的描绘很直观，便于初学者掌握。
（3）缺点
① 没遵循逐步求精的原则，它诱使程序员过早地考虑程序的控制流程，
而不去考虑程序的全局结构。② 程序流程图中用箭头代表控制流，因此程序员不受任何约束，可以随
意转移控制。
③ 程序流程图不易表示数据结构。
2 盒图（N-S图）
（1）特点
① 功能域明确；
② 不可能任意转移控制；
③ 很容易确定局部和全程数据的作用域；
④ 很容易表示嵌套关系，也可以表示模块的层次结构。
（2）表示
图6-4给出了结构化控制结构的盒图表示，也给出了调用子程序的盒图
表示方法。图6-4
盒图的基本符号
符号含义：（a）顺序结构；（b）IF_THEN_ELSE型分支；（c）CASE
型多分支；（d）循环结构；（e）调用子程序A。
（3）优点
① 盒图没有箭头，因此不允许随意转移控制。
② 盒图可以使程序员逐步养成用结构化的方式思考问题和解决问题的习
惯。
3 PAD图（问题分析图）
（1）符号表示
PAD图用二维树形结构的图来表示程序的控制流，图6-5给出PAD图的
基本符号。图6-5
PAD图的基本符号
符号含义：（a）顺序（先执行P1后执行P2）；（b）选择（IF C THEN
Pl ELSE P2）；（c）CASE型多分支；（d）WHILE型循环（WHILE C
DO P）；（e）UNTIL型循环（REPEAT P UNTIL C）；（f）语句标
号；（g）定义。
（2）优点
① 使用PAD符号所设计出来的程序必然是结构化程序。
② PAD图所描绘的程序结构十分清晰。
③ 用PAD图表现程序逻辑，易读、易懂、易记。
④ 容易使用软件工具将PAD图自动转换成高级语言源程序，提高了软件可靠性和软件生产率。
⑤ 即可用于表示程序逻辑，也可用于描绘数据结构。
⑥ PAD图的符号支持自顶向下、逐步求精方法的使用。
【注意】PAD图中竖线的总条数就是程序的层次数。
4 判定表
（1）适用性
算法中包含多重嵌套的条件选择时使用判定表。
（2）组成
① 左上部列出所有条件；
② 左下部是所有可能做的动作；
③ 右上部是表示各种条件组合的一个矩阵；
④ 右下部是和每种条件组合相对应的动作。
【注意】判定表右半部的每一列实质上是一条规则，规定了与特定的条
件组合相对应的动作。
5 过程设计语言
（1）定义过程设计语言（PDL），即伪码，它是用正文形式表示数据和处理过程
的设计工具。
（2）优点
① 可作为注释直接插在源程序中，有助于保持文档和程序的一致性，提
高文档的质量。
② 可以使用普通的正文编辑程序或文字处理系统，很方便地完成PDL的
书写和编辑工作。
③ 已经有自动处理PDL的程序存在，且可以自动由PDL生成程序代码。
（3）缺点
不如图形工具形象直观，不如判定表清晰简单。</p><h2 id=五面向数据结构的设计方法>五、面向数据结构的设计方法<a hidden class=anchor aria-hidden=true href=#五面向数据结构的设计方法>#</a></h2><p>1 Jackson图
（1）分类
Jackson图根据程序中数据元素彼此间的逻辑关系可分为顺序结构、选择
结构和重复结构3类，具体如下：
① 顺序结构
图6-6是表示顺序结构的Jackson图的一个例子。图6-6 A由B、C、D3个元素顺序组成
【注意】图中每个元素只出现一次，出现的次序依次是B、C和D。
② 选择结构
图6-7是表示3个中选1个结构的Jackson图。
图6-7 根据条件A是B或C或D中的某一个
【注意】在B、C和D的右上角有小圆圈做标记。
③ 重复结构
图6-8是表示重复结构的Jackson图。
图6-8
A由B出现N次（N≥0）组成【注意】在B的右上角有星号标记。
（2）优点
① 便于表示层次结构，而且是对结构进行自顶向下分解的有力工具。
② 形象直观可读性好。
③ 既能表示数据结构也能表示程序结构。
（3）缺点
① 图中无法表示选择条件或循环结束条件，影响了图的表达能力，也不
易直接把图翻译成程序。
② 框间连线为斜线，不易在行式打印机上输出。
2 改进的Jackson图
（1）表示
图6-9中给出了改进的Jackson图。图6-9
改进的Jackson图
（a）顺序结构：B、C、D中任一个都不能是选择出现或重复出现的数据
元素。
（b）选择结构：S右面括号中的数字i是分支条件的编号。
（c）可选结构：A或者是元素B或者不出现。
（d）重复结构：循环结束条件的编号为i。
（2）与层次图的比较
① 层次图中的一个方框代表一个模块；而Jackson图中一个方框并不代
表一个模块。
② 层次图表现的是调用关系；而Jackson图表现的是组成关系。</p><h2 id=六程序复杂程度的定量度量价值>六、程序复杂程度的定量度量价值<a hidden class=anchor aria-hidden=true href=#六程序复杂程度的定量度量价值>#</a></h2><h2 id=title-软件维护>2 McCabe方法
（1）流图
① 定义
流图实质上是“退化了的”程序流程图，它仅仅描绘程序的控制流程，完
全不表现对数据具体操作以及分支或循环的具体条件。
② 程序流程图映射成流图
图6-10说明了把程序流程图映射成流图的方法。图6-10
把程序流程图映射成流图
a．流图中用圆表示结点，一个圆代表一条或多条语句。程序流程图中
的一个顺序的处理框序列和一个菱形判定框，可以映射成流图中的一个结点。
b．流图中的箭头线称为边，代表控制流。流图中一条边必须终止于一
个结点，即使这个结点并不代表任何语句。
c．由边和结点围成的面积称为区域，计算区域数时应包括图外部未被
围起来的区域。
③ PDL翻译成流图
a．基本情况
图6-11是用PDL表示的处理过程及与之对应的流图。图6-11 由PDL翻译成的流图
b．包含复合条件
复合条件，就是在条件中包含了一个或多个布尔运算符。图6-12是由包
含复合条件的PDL片段翻译成的流图。
图6-12 由包含复合条件的PDL映射成的流图
（2）环形复杂度
① 定义
McCabe方法根据程序控制流的复杂程度定量度量程序的复杂程度，度
量出的结果称为程序的环形复杂度。② 计算方法
环形复杂度定量度量程序的逻辑复杂度，可以用下述3种方法中的任何
一种来计算环形复杂度：
a．流图中线性无关的区域数等于环形复杂度。
b．流图G的环形复杂度V(G)=E-N+2，其中，E是流图中边的条数，N是
结点数。
c．流图G的环形复杂度V(G)=P+1，其中，P是流图中判定结点的数目。
3 Halstead方法
（1）定义
Halstead方法是根据程序中运算符和操作数的总数来度量程序的复杂程
度。
（2）方法
① 程序长度N定义（N1为程序中运算符出现的总次数，N2为操作数出现
的总次数）：N=N1+N2；
② 预测程序长度的公式（使用的不同运算符的个数n1，不同操作数的个
数n2）：H=n1log2n1+n2log2n2；
③ 预测程序中包含错误的个数的公式：E=Nlog2(n1+n2)/3000。6.2 课后习题&mdash;
title: 软件维护</h2><p>复习笔记</p><h2 id=一软件维护的定义>一、软件维护的定义<a hidden class=anchor aria-hidden=true href=#一软件维护的定义>#</a></h2><p>软件工程的主要目的就是要提高软件的可维护性，减少软件维护所需要
的工作量，降低软件系统的总成本。
1．定义
软件维护是在软件已经交付使用后，为了改正错误或满足新的需要而修
改软件的过程。
2．分类
（1）改正性维护；
（2）适应性维护；
（3）完善性维护；
（4）预防性维护。</p><h2 id=二软件维护的特点>二、软件维护的特点<a hidden class=anchor aria-hidden=true href=#二软件维护的特点>#</a></h2><p>1 结构化维护与非结构化维护差别巨大2 维护的代价高昂
软件维护中无形的代价有：
（1）软件维护的费用高昂。
（2）因为可用的资源必须供维护任务使用，以致耽误甚至丧失了开发的
良机。
（3）生产率的大幅度下降。
3 维护的问题
（1）理解别人写的程序非常困难，而且困难程度随着软件配置成分的减
少而迅速增加。
（2）需要维护的软件往往没有合格的文档，或者文档资料显著不足。
（3）当要求对软件进行维护时，不能指望由开发人员给人们仔细说明软
件。
（4）绝大多数软件在设计时没有考虑将来的修改。
（5）软件维护不是一项吸引人的工作。</p><h2 id=三软件维护过程>三、软件维护过程<a hidden class=anchor aria-hidden=true href=#三软件维护过程>#</a></h2><p>1 定义
维护过程本质上是修改和压缩了的软件定义和开发过程。2 具体过程
（1）维护组织；
（2）维护报告；
（3）维护的事件流；
图8-1
（4）保存维护记录；
（5）评价维护活动。</p><h2 id=四软件的可维护性>四、软件的可维护性<a hidden class=anchor aria-hidden=true href=#四软件的可维护性>#</a></h2><p>维护阶段的事件流1 定义
可维护性指的是维护人员理解、改正、改动或改进这个软件的难易程
度。
2 决定软件可维护性的因素
（1）可理解性；
（2）可测试性；
（3）可修改性；
（4）可移植性；
（5）可重用性。
3 文档
（1）重要性
文档是影响软件可维护性的决定因素，文档比程序代码更重要。
（2）分类
软件系统的文档可以分为用户文档和系统文档两类。</p><h2 id=五预防性维护-定义>五、预防性维护 定义<a hidden class=anchor aria-hidden=true href=#五预防性维护-定义>#</a></h2><p>预防性维护指的是把今天的方法学应用到昨天的系统上，以支持明天的
需求。
2 实质
预防性维护实质上是软件再工程。</p><h2 id=六软件再工程过程>六、软件再工程过程<a hidden class=anchor aria-hidden=true href=#六软件再工程过程>#</a></h2><h2 id=title-8>1 典型软件再工程模型
典型的软件再工程过程模型如图8-2所示。图8-2
软件再工程过程模型
【注意】在某些情况下这些活动以线性顺序发生，但也并非总是这样。
2 六类活动
（1）库存目录分析；
（2）文档重构；
（3）逆向工程；
（4）代码重构；
（5）数据重构；
（6）正向工程。&mdash;
title: 8</h2><p>复习笔记</p><h2 id=一面向对象方法学概述>一、面向对象方法学概述<a hidden class=anchor aria-hidden=true href=#一面向对象方法学概述>#</a></h2><p>1 要点
（1）定义
面向对象方法是一种以数据或信息为主线，把数据和处理相结合的方
法。
（2）要点
① 对象；
② 类；
③ 继承性；
④ 封装性。
【注意】考生需理解四个要点各自的含义。
2 面向对象方法学的优点
（1）与人类习惯的思维方法一致；（2）稳定性好；
（3）可重用性好；
（4）较易开发大型软件产品；
（5）可维护性好。</p><h2 id=二面向对象的概念>二、面向对象的概念<a hidden class=anchor aria-hidden=true href=#二面向对象的概念>#</a></h2><p>1 对象
（1）对象的定义
① 面向对象程序设计的角度：对象是具有相同状态的一组操作的集合。
② 结构化的角度：对象是封装了数据结构及可以施加在这些数据结构上
的操作的封装体。
（2）对象的特点
① 以数据为中心；
② 对象是主动的；
③ 实现了数据封装；
④ 具有并行性；
⑤ 模块独立性好。2 其他概念
（1）类
类是对具有相同数据和相同操作的一组相似对象的定义。
（2）实例
实例就是由某个特定的类所描述的一个具体的对象。
【注意】类是对象的抽象，对象是类的实例。
（3）消息
① 定义：消息就是要求某个对象执行在定义它的那个类中所定义的某个
操作的规格说明。
② 组成：一个消息由接收消息的对象、消息选择符、零个或多个变元组
成。
（4）方法
方法就是对象所能执行的操作，也就是类中所定义的服务。
（5）属性
属性就是类中所定义的数据，它是对客观世界实体所具有的性质的抽
象。
（6）封装
封装是把数据和实现操作的代码集中起来放在对象内部。（7）继承
① 定义
继承是子类自动地共享基类中定义的数据和方法的机制。
② 特点
a．继承具有传递性；
b．低层的性质将屏蔽高层的同名性质。
③ 分类
a．单继承：一个类只允许有一个父类，即类等级为树形结构。
b．多重继承：允许一个类有多个父类。
（8）多态性
① 定义
多态性指在类等级的不同层次中可以共享一个方法的名字，不同层次中
的每个类各自按自己的需要来实现这个行为。
【注意】在C++中，多态性是通过虚函数来实现的。
② 动态联编
在运行时刻根据接收消息的对象所属于的类，决定执行哪个特定版本的
函数，这称为动态联编（滞后联编）。
③ 优点a．增加了面向对象软件系统的灵活性，进一步减少了信息冗余。
b．显著提高了软件的可重用性和可扩充性。
（9）重载
① 分类
a．函数重载
在同一作用域内的若干个参数特征不同的函数可以使用相同的函数名
字。
【注意】常考点：重载函数的形式参数（指参数的个数或者类型或者顺
序）必须不同，而与函数返回值类型无关。
b．运算符重载
同一个运算符可以施加于不同类型的操作数上面。
② 实现
a．函数重载是通过静态联编（先前联编）实现的。
b．运算符重载是在编译时根据被操作数的类型，决定使用该算符的哪
种语义。
③ 优点
进一步提高了面向对象系统的灵活性和可读性。</p><h2 id=三面向对象建模-模型>三、面向对象建模 模型<a hidden class=anchor aria-hidden=true href=#三面向对象建模-模型>#</a></h2><p>（1）定义
模型是为了理解事物而对事物作出的一种抽象，是对事物的一种无歧义
的书面描述。
（2）作用
① 是一种思考工具，利用这种工具可以把知识规范地表示出来。
② 可以帮助人们思考问题、定义术语、在选择术语时作出适当的假设，
并且有助于保持定义和假设的一致性。
2 模型分类
（1）对象模型：描述系统数据结构。
（2）动态模型：描述系统控制结构。
（3）功能模型：描述系统功能。</p><h2 id=四对象模型>四、对象模型<a hidden class=anchor aria-hidden=true href=#四对象模型>#</a></h2><p>1 概念
（1）定义
它是对模拟客观世界实体的对象以及对象彼此间的关系的映射，描述了
系统的静态结构。【注意】对象模型表示静态的、结构化的系统的数据性质。
（2）工具
使用UML提供的类图来建立对象模型。
2 类图的基本符号
类图描述类及类与类之间的静态关系。类图是一种静态模型，它是创建
其他UML图的基础。
（1）类
UML中类的图形符号为长方形，用两条横线把长方形分为上、中、下3
个区域，3个区域分别放类的名字、属性和服务，如图9-1所示。
图9-1
表示类的图形符号
【注意】类名应该是富于描述性的、简洁的而且无二义性的。
（2）属性
① UML描述属性的语法格式为：
可见性
属性名：类型名＝初值{性质串}
② 属性的可见性分为公有的（＋）、私有的（－）和保护的（#），没
有默认的可见性。（3）服务
① 服务也就是操作，UML描述操作的语法格式为：
可见性
操作名（参数表）：返回值类型{性质串}
② 操作的可见性分为公有的（＋）、私有的（－）和保护的（#），没
有默认的可见性。
③ 参数表中描述一个参数的语法为：参数名：类型名＝默认值
3 表示关系的符号
类与类之间通常有关联、泛化（继承）、依赖和细化4种关系。
（1）关联
① 定义
关联表示两个类的对象之间存在某种语义上的联系。
② 普通关联
a．定义
只要在类与类之间存在连接关系就可以用普通关联表示。
b．表示
第一，普通关联的图示符号是连接两个类之间的直线。
第二，关联是双向的，可为关联起一个名字。在名字前面（或后面）加一个表示关联方向的黑三角。
第三，在表示关联的直线两端可以写上重数。
③ 限定关联
a．定义
限定关联用在一对多或多对多的关联关系中，可以把重数从一对多变成
一对一，或从多对多简化成多对一。
b．表示
在类图中把限定词放在关联关系末端的一个小方框内。
④ 关联类
a．定义
为了说明关联的性质，可能需要一些附加信息。关联类可以用来记录相
关信息。
b．表示
关联中的每个连接与关联类的一个对象相联系。关联类通过一条虚线与
关联连接。
（2）聚集
聚集（聚合）是关联的特例。表示类与类之间的关系是整体与部分的关
系。
① 共享聚集a．定义
如果在聚集关系中处于部分方的对象可同时参与多个处于整体方对象的
构成，则该聚集称为共享聚集。
b．表示
在表示关联关系的直线末端紧挨着整体类的地方画一个空心菱形。
② 组合聚集
a．定义
如果部分类完全隶属于整体类，部分与整体共存，整体不存在了部分也
会随之消失，则该聚集称为组合聚集。
b．表示
在表示关联关系的直线末端紧挨着整体类的地方画一个实心菱形。
（3）泛化
① 定义
UML中的泛化关系就是继承关系，它是通用元素和具体元素之间的一
种分类关系。
② 表示
在UML中，用一端为空心三角形的连线表示泛化关系，三角形的顶角
紧挨着通用元素。③ 分类
泛化关系包括普通泛化和受限泛化。
④ 约束
预定义的约束有4种：多重、不相交、完全和不完全。
⑤ 继承分类
分为多重继承、不相交继承、完全继承、不完全继承四类。
（4）依赖和细化
① 依赖关系
a．定义
依赖关系描述两个模型元素之间的语义连接关系：其中一个模型元素是
独立的，另一个模型元素不是独立的，它依赖于独立的模型元素，如果
独立的模型元素改变了，将影响依赖于它的模型元素。
b．表示
在UML类图中用带箭头的虚线连接有依赖关系的两个类，箭头指向独
立的类。
② 细化关系
a．定义
对同一个事物在不同抽象层次上描述时，这些描述之间具有细化关系。b．表示
细化的图示符号为由元素B指向元素A的一端为空心三角形的虚线。</p><h2 id=五动态模型>五、动态模型<a hidden class=anchor aria-hidden=true href=#五动态模型>#</a></h2><p>1 概念
动态模型表示瞬时的、行为化的系统的控制性质，它规定了对象模型中
的对象的合法变化序列。
2 建模
每个类的动态行为用一张状态图来描绘，各个类的状态图通过共享事件
合并起来，从而构成系统的动态模型。</p><h2 id=六功能模型>六、功能模型<a hidden class=anchor aria-hidden=true href=#六功能模型>#</a></h2><h2 id=title-9>1 概念
（1）定义
功能模型表示变化的系统的功能性质，它指明了系统应该做什么。
（2）组成
功能模型由一组数据流图组成。
2 用例图在UML中把用用例图建立起来的系统模型称为用例模型。
（1）定义
用例模型描述的是外部行为者所理解的系统功能。用例模型的建立是系
统开发者和用户反复讨论的结果，它描述了开发者和用户对需求规格所
达成的共识。
（2）组成和表示
① 系统，用方框表示。
② 用例，用椭圆表示。
③ 行为者，用线条人表示。
④ 关系，用连线表示。
（3）关系的分类
UML用例之间主要有扩展和使用两种关系，它们是泛化关系的两种不
同形式。
① 扩展关系
向一个用例中添加一些动作后构成了另一个用例，这两个用例之间的关
系就是扩展关系，后者继承前者的一些行为，通常把后者称为扩展用
例。
② 使用关系
一个用例使用另一个用例时，这两个用例之间就构成了使用关系。七、3种模型之间的关系
1 针对每个类建立的动态模型，描述了类实例的生命周期或运行周
期。
2 状态转换驱使行为发生，这些行为在数据流图中被映射成处理，在
用例图中被映射成用例，它们同时与类图中的服务相对应。
3 功能模型中的处理对应于对象模型中的类所提供的服务。
4 数据流图中的数据存储，以及数据的源点/终点，通常是对象模型中
的对象。
5 数据流图中的数据流，往往是对象模型中对象的属性值，也可能是
整个对象。
6 用例图中的行为者，可能是对象模型中的对象。
7 功能模型中的处理可能产生动态模型中的事件。
8 对象模型描述了数据流图中的数据流、数据存储以及数据源点/终点的结构。9.2 课后习题&mdash;
title: 9</h2><p>复习笔记</p><h2 id=一面向对象分析的基本过程>一、面向对象分析的基本过程<a hidden class=anchor aria-hidden=true href=#一面向对象分析的基本过程>#</a></h2><p>1 概述
（1）定义
面向对象分析，就是抽取和整理用户需求并建立问题域精确模型的过
程。
（2）过程
① 分析陈述用户需求的文件；
② 深入理解用户需求，抽象出目标系统的本质属性；
③ 用模型准确地表示。
（3）目的
全面深入地理解问题域和用户的真实需求，建立问题域的精确模型。
2 3个子模型与5个层次
（1）3个模型面向对象建模得到的模型包含系统的三个要素，即
① 静态结构（对象模型）；
② 交互次序（动态模型）；
③ 数据变换（功能模型）。
【注意】3种模型中，对象模型是最基本、最重要、最核心的。
（2）5个层次
复杂问题的对象模型由5个层次组成，如图10-1所示。
图10-1
复杂问题的对象模型的5个层次</p><h2 id=二需求陈述>二、需求陈述<a hidden class=anchor aria-hidden=true href=#二需求陈述>#</a></h2><p>1 内容
（1）阐明“做什么”而不是“怎样做”。
（2）描述用户的需求而不是提出解决问题的方法。
（3）指出哪些是系统必要的性质，哪些是任选的性质。
（4）避免对设计策略施加过多的约束，不描述系统的内部结构。2 书写要点
（1）做到语法正确，慎重选用名词、动词、形容词和同义词。
（2）必须把需求与实现策略区分开。
（3）需求陈述可简可繁。
（4）避免出现具有二义性的、不完整的、不一致的内容。</p><h2 id=三建立对象模型>三、建立对象模型<a hidden class=anchor aria-hidden=true href=#三建立对象模型>#</a></h2><p>1 先建立对象模型的原因
（1）静态数据结构对应用细节依赖较少，比较容易确定。
（2）当用户的需求变化时，静态数据结构相对来说比较稳定。
2 信息来源
需求陈述、应用领域的专业知识、客观世界的常识是建立对象模型时的
主要信息来源。
3 建立对象模型的步骤
（1）确定类与对象。
① 找出候选的类与对象；② 筛选出正确的类与对象。
（2）确定关联。
【注意】在分析确定关联的过程中，不必花过多的精力去区分关联和聚
集，聚集是一种特殊的关联。
（3）划分主题。
（4）确定属性。
（5）识别继承关系。
（6）反复修改。</p><h2 id=四建立动态模型>四、建立动态模型<a hidden class=anchor aria-hidden=true href=#四建立动态模型>#</a></h2><p>1 概念
（1）适用性
① 对于仅存储静态数据的系统来说，动态模型并没有什么意义。
② 在开发交互式系统时，动态模型起着很重要的作用。
③ 应用系统的主要工作是收集输入信息时，建立正确的动态模型是至关
重要的。
（2）步骤
① 编写典型交互行为的脚本。② 从脚本中提取出事件，确定触发每个事件的动作对象以及接受事件的
目标对象。
③ 排列事件发生的次序，确定每个对象的状态及状态间的转换关系，用
状态图描绘。
④ 比较各个对象的状态图，确保事件之间的匹配。
2 编写脚本
（1）定义
脚本是指系统在某一执行期间内出现的一系列事件。
（2）目的
编写脚本的目的是保证不遗漏重要的交互步骤，有助于确保交互过程的
正确性、清晰性。
3 设想用户界面
（1）重要性
用户界面的好坏往往对用户是否喜欢、是否接受一个系统起很重要的作
用。
（2）目的
确保能够完成全部必要的信息交换，而不会丢失重要的信息。【注意】当前阶段重要的是在界面下的信息交换方式，而不是用户界面
的细节。
4 画事件跟踪图
（1）一条竖线代表一个对象；
（2）每个事件用一条水平的箭头线表示；
（3）箭头方向从事件的发送对象指向接受对象；
（4）时间从上向下递增；
（5）用箭头线在垂直方向上的相对位置表示事件发生的先后，不表示事
件间的时间差。
5 画状态图
（1）定义
状态图描绘事件与对象状态的关系，它确定了由事件序列引出的状态序
列。
（2）方法
① 仅考虑事件跟踪图中指向某条竖线的那些箭头线。把这些事件作为状
态图中的有向边，边上标以事件名。
② 给每个状态取个有意义的名字。③ 根据一张事件跟踪图画出状态图后，再把其他脚本的事件跟踪图合并
到该图中。
④ 考虑完正常事件后再考虑边界情况和特殊情况，包括在不适当时候发
生的事件。</p><h2 id=五建立功能模型>五、建立功能模型<a hidden class=anchor aria-hidden=true href=#五建立功能模型>#</a></h2><h2 id=title-10>1 画出基本系统模型图
基本的系统模型有下述两部分组成：
（1）数据源点/终点
数据源点输入的数据和输出到数据终点的数据，是系统与外部世界间交
互事件的参数。
（2）处理框
处理框代表了系统加工、变换数据的整体功能。
2 画出功能级数据流图
把基本系统模型中单一的处理框分解成若干个处理框，以描述系统加
工、变换数据的基本功能，就得到功能级数据流图。
3 描述处理框功能
（1）要点着重描述每个处理框所代表的功能，而不是实现功能的具体算法。
（2）描述分类
① 说明性描述（更重要）；
② 过程性描述。
六、定义服务（略）10.2 课后习题&mdash;
title: 10</h2><p>复习笔记</p><h2 id=一面向对象设计的准则>一、面向对象设计的准则<a hidden class=anchor aria-hidden=true href=#一面向对象设计的准则>#</a></h2><p>1 模块化
2 抽象
3 信息隐藏
在面向对象的软件中，信息隐藏通过对象的封装来实现，即类结构分离
了接口与实现，从而支持了信息隐藏。
4 弱耦合
一般而言，对象之间的耦合可分为两大类：
（1）交互耦合
对象间的耦合通过消息连接来实现，则这种耦合是交互耦合。要使交互
耦合尽可能松散。
（2）继承耦合继承耦合的模块彼此之间应该结合得越紧密越好。
5 强内聚
在面向对象设计中存在下述3种内聚：
（1）服务内聚；
（2）类内聚；
（3）一般-特殊内聚。
6 可重用
重用有两方面的含义：
① 尽量使用已有的类。
② 如果需要创建新类，则在设计这些新类的协议时应该考虑将来的可重
复使用性。</p><h2 id=二启发规则>二、启发规则<a hidden class=anchor aria-hidden=true href=#二启发规则>#</a></h2><p>1 设计结果应该清晰易懂
2 一般-特殊结构的深度应适当3 设计简单的类
4 使用简单的协议
5 使用简单的服务
6 把设计变动减至最小
图11-1
理想的设计变动情况
理想的设计变动曲线如图11-1所示。即在设计的早期阶段，变动较大，
随着时间推移，设计方案日趋成熟，改动也越来越小了。</p><h2 id=三软件重用>三、软件重用<a hidden class=anchor aria-hidden=true href=#三软件重用>#</a></h2><p>1 概述（1）重用
重用也叫再用或复用，是指同一事物不作修改或稍加改动就多次重复使
用。软件重用可分为以下3个层次：
① 知识重用；
② 方法和标准的重用；
③ 软件成分的重用。
（2）软件成分的重用级别
① 代码重用；
② 设计结果重用；
③ 分析结果重用。
（3）典型的可重用软件成分
① 项目计划；
② 成本估计；
③ 体系结构；
④ 需求模型和规格说明；
⑤ 设计；
⑥ 源代码；⑦ 用户文档和技术文档；
⑧ 用户界面；
⑨ 数据；
⑩ 测试用例。
2 类构件
（1）可重用软构件的特点
① 模块独立性强；
② 具有高度可塑性；
③ 接口清晰、简明、可靠。
（2）类构件的重用方式
① 实例重用；
② 继承重用；
③ 多态重用。
3 软件重用的效益
（1）重用给软件产品的质量和可靠性带来实质性的提高。
（2）使生产率得到了提高。（3）节省了成本。
软件重用带来的净成本节省可以用下式估算：C＝Cs－Cr－Cd。其中，
Cs是项目从头开发时所需要的成本；Cr是与重用相关联的成本；Cd是交
付给客户的软件的实际成本。</p><h2 id=四系统分解>四、系统分解<a hidden class=anchor aria-hidden=true href=#四系统分解>#</a></h2><p>1 分解的思想
在设计比较复杂的应用系统时，先把系统分解成若干个较小部分，然后
分别设计每个部分。这样做有利于降低设计的难度，有利于分工协作，
也有利于维护人员对系统理解和维护。
2 子系统
（1）定义
系统的主要组成部分称为子系统，通常根据所提供的功能来划分子系
统。
（2）划分原则
① 根据所提供的功能来划分子系统，子系统数目应该与系统规模基本匹
配。
② 各个子系统之间应该具有尽可能简单、明确的接口。
③ 应该尽量减少子系统彼此间的依赖性。3 分解面向对象设计模型
（1）表示
图11-2
典型的面向对象设计模型
典型的面向对象设计模型，如图11-2所示。
① 面向对象设计模型由主题、类与对象、结构、属性、服务5个层次组
成。
② 面向对象设计模型在逻辑上都由4大部分组成，分别对应于组成目标
系统的4个子系统，即问题域子系统、人机交互子系统、任务管理子系
统和数据管理子系统。
（2）子系统间交互方式
① 客户-供应商关系（较好）；
② 平等伙伴关系。
【注意】单项交互比双向交互更容易理解，也更容易设计和修改，因此
应该尽量使用客户-供应商关系。
（3）组织系统的方案① （水平）层次组织；
② （垂直）块状组织；
③ 层次和块的组合；
④ 设计系统的拓扑结构。
典型的拓扑结构有管道形、树形、星形等。</p><h2 id=五设计问题域子系统>五、设计问题域子系统<a hidden class=anchor aria-hidden=true href=#五设计问题域子系统>#</a></h2><p>1 概念
（1）面向对象分析所得出的问题域精确模型，为设计问题域子系统建立
了完整的框架。
（2）保持面向对象分析所建立的问题域结构。
（3）面向对象设计仅需从实现角度对问题域模型做一些补充或修改。
（4）问题域子系统过分复杂庞大时，应该把它进一步分解成若干个更小
的子系统。
2 对问题域模型进行的处理
（1）调整需求；
（2）重用已有的类；
（3）把问题域类组合在一起；（4）增添一般化类以建立协议；
（5）调整继承层次。</p><h2 id=六设计人机交互子系统>六、设计人机交互子系统<a hidden class=anchor aria-hidden=true href=#六设计人机交互子系统>#</a></h2><p>1 概念
（1）主要内容
设计人机交互子系统包括指定窗口和报表的形式、设计命令层次等内
容。
（2）重要性
人机界面设计得好，则会吸引用户，激发用户的创造力，提高工作效
率；人机界面设计得不好，使用户感到不方便、不习惯，甚至会产生厌
烦和恼怒的情绪。
2 设计策略
（1）分类用户；
（2）描述用户；
（3）设计命令层次；
（4）设计人机交互类。</p><h2 id=七设计任务管理子系统1-设计的必要性>七、设计任务管理子系统1 设计的必要性<a hidden class=anchor aria-hidden=true href=#七设计任务管理子系统1-设计的必要性>#</a></h2><p>（1）许多对象之间往往存在相互依赖关系。
（2）在实际使用的硬件中，可能仅由一个处理器支持多个对象。
2 设计步骤
（1）分析并发性。
（2）设计任务管理子系统。
① 确定事件驱动型任务；
② 确定时钟驱动型任务；
③ 确定优先任务；
④ 确定关键任务；
⑤ 确定协调任务；
⑥ 尽量减少任务数；
⑦ 确定资源需求。</p><h2 id=八设计数据管理子系统>八、设计数据管理子系统<a hidden class=anchor aria-hidden=true href=#八设计数据管理子系统>#</a></h2><p>1 概念
数据管理子系统是系统存储或检索对象的基本设施。2 选择数据存储管理模式
（1）文件管理系统
① 优点
具有成本低和简单的优点。
② 缺点
文件操作的级别低，为提供适当的抽象级别必须编写额外的代码，不同
操作系统的文件管理系统有明显差异。
（2）关系数据库管理系统
① 理论基础
关系数据库管理系统的理论基础是关系代数。
② 优点
a．理论基础坚实。
b．提供了各种最基本的数据管理功能，例如中断恢复，多用户共享，
多应用共享，完整性，事务支持等。
c．为多种应用提供了一致的接口。
d．标准化的语言。
③ 缺点a．运行开销大。
b．不能满足高级应用的需求。
c．与程序设计语言的连接不自然。
（3）面向对象数据库管理系统
面向对象数据库管理系统主要有两种设计途径：
① 扩展的关系数据库管理系统；
② 扩展的面向对象程序设计语言。
3 设计数据管理子系统
（1）设计数据格式；
（2）设计相应的服务。</p><h2 id=九设计类中的服务>九、设计类中的服务<a hidden class=anchor aria-hidden=true href=#九设计类中的服务>#</a></h2><p>1 确定类中应有的服务
（1）确定服务的总体思想；
（2）确定操作目标对象的启发规则；
（3）确定处理归属的启发规则。2 设计实现服务的方法
（1）设计实现服务的算法；
（2）选择数据结构；
（3）算法与数据结构的关系；
（4）定义内部类和内部操作。</p><h2 id=十设计关联>十、设计关联<a hidden class=anchor aria-hidden=true href=#十设计关联>#</a></h2><p>1 确定实现关联的策略
（1）选定一个全局性的策略统一实现所有关联。
（2）分别为每个关联选择具体的实现策略，以与它在应用系统中的使用
方式相适应。
2 使用关联的方式
（1）关联的遍历
① 单向遍历；
② 双向遍历。
（2）实现单向关联图11-3用指针实现单向关联
图11-4用指针实现双向关联
① 关联的重数是一元的（如图11-3所示），则实现关联的指针是一个简
单指针。
② 重数是多元的，则需要用一个指针集合实现关联（如图11-4所示）。
（3）实现双向关联图11-5
用对象实现关联
① 只用属性实现一个方向的关联。
② 两个方向的关联都用属性实现，如图11-4所示。
③ 用独立的关联对象实现双向关联，如图11-5所示。
（4）关联对象的实现
① 定义
用一个关联类来保存描述关联性质的信息，关联中的每个连接对应关联
类的一个对象。
② 方法
a．对于一对一的关联，关联对象可以与参与关联的任一个对象合并。
b．对于一对多的关联，关联对象可以与多端对象合并。
c．对于多对多的关联，关联链的性质不可能只与一个参与关联的对象有关。</p><h2 id=十一设计优化>十一、设计优化<a hidden class=anchor aria-hidden=true href=#十一设计优化>#</a></h2><h2 id=title-编码测试>1 确定优先级
2 提高效率的几项技术
（1）增加冗余关联以提高访问效率。
（2）调整查询次序。
（3）保留派生属性。
3 调整继承关系
（1）继承关系
继承关系能够为一个类族定义一个协议，并能在类之间实现代码共享以
减少冗余。
（2）建立类继承
① 抽象与具体的持续演化；
② 为提高继承程度而修改类定义；
③ 利用委托实现行为共享。11.2 课后习题&mdash;
title: 编码测试</h2><p>复习笔记</p><h2 id=一编码>一、编码<a hidden class=anchor aria-hidden=true href=#一编码>#</a></h2><p>一般将编码和测试统称为实现。
1．编码的定义
编码是把软件设计结果翻译成用程序设计语言书写的程序。
2．效率
效率主要指处理机时间和存储器容量两个方面。</p><h2 id=二软件测试基础>二、软件测试基础<a hidden class=anchor aria-hidden=true href=#二软件测试基础>#</a></h2><p>1 软件测试的定义
测试是为了发现程序中的错误而执行程序的过程。
2 软件测试的目标
（1）好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案。
（2）成功的测试是发现了至今为止尚未发现的错误的测试。（3）根本目标是尽可能多地发现并排除软件中潜藏的错误，最终把一个
高质量的软件系统交给用户使用。
【注意】测试只能查找出程序中的错误，不能证明程序中没有错误。测
试的目标是发现错误，调试的任务是在测试的基础上去改正错误。
3 测试方法
（1）白盒测试
① 白盒测试（结构测试）把程序看成装在一个透明的白盒子里，测试者
完全知道程序的结构和处理算法。
② 按照程序内部的逻辑测试程序，检测程序中的主要执行通路是否都能
按预定要求正确工作。
（2）黑盒测试
① 黑盒测试（功能测试）把程序看作一个黑盒子，完全不考虑程序的内
部结构和处理过程。
② 黑盒测试是在程序接口进行的测试，只检查程序功能是否能按照规格
说明书的规定正常使用。
4 测试步骤
（1）单元测试（模块测试）
① 定义：单元测试把每个模块作为一个单独的实体来测试，检验其正确性。
② 目的：保证每个模块作为一个单元能正确运行。
【注意】单元测试发现的是编码和详细设计的错误。
（2）子系统测试
① 定义：子系统测试把经过单元测试的模块放在一起形成一个子系统来
测试。
② 目的：着重测试模块的接口。
（3）系统测试
① 定义：系统测试是把经过测试的子系统装配成一个完整的系统来测
试。
② 目的：发现设计和编码的错误，并验证系统确实能提供需求说明书中
指定的功能。
【注意】子系统测试和系统测试都属于集成测试。
（4）验收测试（确认测试）
① 定义：在用户的参与下，把软件系统作为单一的实体，使用实际数据
进行测试。
② 目的：验证系统确实能够满足用户的需要。
【注意】验收测试发现的是系统需求说明书中的错误。</p><h2 id=三单元测试模块-->三、单元测试（模块 ）<a hidden class=anchor aria-hidden=true href=#三单元测试模块-->#</a></h2><p>单元测试主要使用白盒测试技术。
1．测试重点
（1）模块接口；
（2）局部数据结构；
（3）重要的执行通路；
（4）出错处理通路；
（5）边界条件。
2．测试方法
（1）代码审查；
（2）计算机测试。
【注意】必须要为每个单元测试开发驱动软件和（或）存根软件。</p><h2 id=四集成测试>四、集成测试<a hidden class=anchor aria-hidden=true href=#四集成测试>#</a></h2><p>1 概念
（1）方法分类
① 非渐增式测试。② 渐增式测试。
（2）非渐增式测试的缺点
① 把所有模块放在一起，测试者面对的情况十分复杂。
② 在庞大的程序中诊断定位一个错误非常困难。
③ 一旦改正一个错误之后，又会遇到新的错误，没有穷尽。
（3）渐增式测试的优点
① 把程序划分成小段来构造和测试，比较容易定位和改正错误。
② 对接口可以进行更彻底的测试。
③ 可以使用系统化的测试方法。
2 渐增式测试的策略
（1）自顶向下集成
包含深度优先和宽度优先两种结合策略。
（2）自底向上集成
3 两种集成策略的比较
（1）自顶向下集成
① 优点a．不需要测试驱动程序。
b．能够在测试阶段的早期实现并验证系统的主要功能。
c．能在早期发现上层模块的接口错误。
② 缺点
a．需要存根程序，可能遇到与此相联系的测试困难。
b．低层关键模块中的错误发现较晚。
c．在早期不能充分展开人力。
（2）自底向上集成
① 优点
a．不需要存根程序，不会遇到与存根程序相联系的测试困难。
b．能较早的发现低层关键模块的错误。
c．能在早期充分展开人力。
② 缺点
a．需要测试驱动程序。
b．不能在测试阶段早期实现并验证系统的主要功能。
c．在早期不能发现上层模块的接口错误。4 其他集成测试策略
（1）改进的自顶向下测试方法；
（2）混合法。
5 回归测试
（1）定义
回归测试是指重新执行已经做过的测试的某个子集，以保证上述这些变
化没有带来非预期的副作用。
（2）目的
保证由于调试或其他原因引起的变化，不会导致非预期的软件行为或额
外错误的测试活动。</p><h2 id=五确认测试>五、确认测试<a hidden class=anchor aria-hidden=true href=#五确认测试>#</a></h2><p>1 确认测试通常使用黑盒测试法。
2 验收测试由最终用户而不是系统的开发者进行。
3 分为Alpha测试和Beta测试。</p><h2 id=六白盒测试技术-逻辑覆盖>六、白盒测试技术 逻辑覆盖<a hidden class=anchor aria-hidden=true href=#六白盒测试技术-逻辑覆盖>#</a></h2><p>① 语句覆盖
语句覆盖的含义是选择足够多的测试数据，使被测程序中每个语句至少
执行一次。
② 判定覆盖（分支覆盖）
判定覆盖的含义是不仅每个语句必须至少执行一次，而且每个判定的每
种可能的结果都应该至少执行一次。
③ 条件覆盖
条件覆盖的含义是不仅每个语句至少执行一次，而且使判定表达式中的
每个条件都取到各种可能的结果。
④ 判定/条件覆盖
判定/条件覆盖的含义是不仅使得判定表达式中的每个条件都取到各种
可能的值，而且每个判定表达式也都取到各种可能的结果。它同时满足
判定覆盖和条件覆盖。
⑤ 条件组合覆盖
条件组合覆盖要求选取足够多的测试数据，使得每个判定表达式中条件
的各种可能组合都至少出现一次。满足条件组合覆盖，也一定满足判定
覆盖、条件覆盖和判定/条件覆盖标准。
⑥ 点覆盖
要求选取足够多的测试数据，使得程序执行路径至少经过流图的每个结点一次。
【注意】点覆盖标准和语句覆盖标准是相同的。
⑦ 边覆盖
要求选取足够多测试数据，使程序执行路径至少经过流图中每条边一
次。
【注意】边覆盖与判定覆盖是相同的。
⑧ 路径覆盖
路径覆盖含义是选取足够多测试数据，使程序的每条可能路径都至少执
行一次，如果程序图中有环，则要求每个环至少经过一次。
2 控制结构测试
（1）基本路径测试
【注意】某些独立路径不能以独立的方式测试，即程序的正常流程不能
形成独立执行该路径所需要的数据组合。
（2）条件测试
（3）循环测试
在结构化的程序中通常只有3种循环，即简单循环、串接循环和嵌套循
环。</p><h2 id=七黑盒测试技术>七、黑盒测试技术<a hidden class=anchor aria-hidden=true href=#七黑盒测试技术>#</a></h2><p>1 等价划分
把程序的输入域划分成若干个数据类，选取每个等价类中的一个典型值或任意值作为测试数据。
2 边界值分析
确定边界情况，选取刚好等于、稍小于和稍大于等价类边界值的数据作为测试数据。
3 错误推测
利用判定表或判定树为工具，列出输入数据各种组合与程序应做的动作之间的对应关系，然后为判定表的每一列至少设计一个测试用例。</p><h2 id=八调试>八、调试<a hidden class=anchor aria-hidden=true href=#八调试>#</a></h2><p>1 定义
调试是在测试发现错误之后排除错误的过程。
2 调试途径
（1）蛮干法。
（2）回溯法。
（3）原因排除法。
① 对分查找法；
② 归纳法；
③ 演绎法。
【注意】考生务必注意测试和调试的区别。改错是调试的任务，测试的任务是发现错误。</p><h2 id=九软件可靠性-基本概念>九、软件可靠性 基本概念<a hidden class=anchor aria-hidden=true href=#九软件可靠性-基本概念>#</a></h2><h2 id=title-11>（1）软件可靠性
软件可靠性是程序在给定的时间间隔内，按照规格说明书的规定成功地
运行的概率。
（2）软件的可用性
软件可用性是程序在给定的时间点，按照规格说明书的规定，成功地运
行的概率。
（3）MTTF和MTTR
① 概念
a．平均维修时间MTTR
表示修复一个故障平均需要用的时间。
b．平均无故障时间MTTF
表示系统按规格说明书规定成功地运行的平均时间。
② 计算公式
如果在一段时间内，软件系统故障停机时间分别为td1，td2，…，正常运
行时间分别为tu1，tu2，…，则系统的稳态可用性为：
（7.1）其中：
（7.1）式可以变成
（7.2）
2 估算平均无故障时间的方法
（1）符号
① ET：测试之前程序中错误总数；
② IT：程序长度（机器指令总数）；
③ τ：测试（包括调试）时间；
④ Ed(τ)：在0至τ期间发现的错误数；
⑤ Ec(τ)：在0至τ期间改正的错误数。
（2）基本假定
① 单位长度里的错误数ET/IT近似为常数。通常0.5×10-2≤ET/IT≤2×10-2。② 失效率正比于软件中潜藏的错误数，平均无故障时间MTTF与剩余的
错误数成反比。
③ 假设发现的每一个错误都立即正确地改正了，即Ec(τ)=Ed(τ)。
a．剩余的错误数
（7.3）
b．单位长度程序中剩余的错误数
（7.4）
（3）估算平均无故障时间
① 平均无故障时间与单位长度程序中剩余的错误数成反比（K经典值为
200），即
（7.5）
② 估算平均无故障时间的公式，可以评价软件测试进展情况。由
（7.5）式可得：
（7.6）
（4）估计错误总数的方法① 植入错误法
假设人为地植入的错误数为Ns，经过一段时间的测试之后发现ns个植入
的错误，还发现了n个原有的错误。则估计出程序中原有错误的总数
为：
（7.7）
其中 即是错误总数ET的估计值。
② 分别测试法
假定测试员乙发现有标记错误和发现无标记错误的概率相同，则可以估
计出测试前程序中的错误总数为：
（7.8）
其中，测试员甲发现的错误数为B1，测试员乙发现的错误数为B2，两个
测试员发现的相同错误数为bc。7.2 课后习题&mdash;
title: 11</h2><p>复习笔记</p><h2 id=一程序设计语言>一、程序设计语言<a hidden class=anchor aria-hidden=true href=#一程序设计语言>#</a></h2><p>面向对象实现需要把面向对象设计结果翻译成用某种程序语言书写的面
向对象程序，并对其测试和调试。
1 面向对象语言的优点
（1）一致的表示方法；
（2）可重用性好；
（3）可维护性好。
2 面向对象语言的技术特点
（1）支持类与对象概念的机制。
【注意】自动管理内存必须采用先进的垃圾收集算法才能减少开销。
（2）实现聚集结构的机制。
（3）实现泛化结构的机制。（4）实现属性和服务的机制。
（5）类型检查。
（6）提供类库。
（7）效率高。
（8）持久保存对象。
（9）参数化类。
（10）有良好的软件工具和软件工程环境。
3 选择面向对象语言的标准
（1）将来能否占主导地位。
（2）可重用性。
（3）类库和开发环境。
【注意】语言、开发环境和类库这3个因素综合起来，共同决定了可重用
性。
（4）其他因素。
① 对用户学习面向对象分析、设计和编码技术所能提供的培训服务；
② 在使用这个面向对象语言期间能提供的技术支持；
③ 能提供给开发人员使用的开发工具、开发平台、发行平台；④ 对机器性能和内存的需求；
⑤ 集成已有软件的容易程度等。</p><h2 id=二程序设计风格>二、程序设计风格<a hidden class=anchor aria-hidden=true href=#二程序设计风格>#</a></h2><p>1 概念
（1）良好的程序设计风格的重要性
① 能明显减少维护或扩充的开销。
② 有助于在新项目中重用已有的程序代码。
（2）良好的面向对象程序设计风格的内容
① 传统的程序设计风格准则。
② 为适应面向对象方法所特有的概念而必须遵循的一些新准则。
2 提高可重用性
（1）代码重用
① 内部重用，即本项目内的代码重用。
② 外部重用，即新项目重用旧项目的代码。
（2）实现代码重用的主要准则
① 提高方法的内聚。② 减小方法的规模。
③ 保持方法的一致性。
④ 把策略与实现分开。
⑤ 全面覆盖。
⑥ 尽量不使用全局信息。
⑦ 利用继承机制。
a．调用子过程：
图12-1
通过调用公用方法实现代码重用
b．分解因子：
图12-2
c．使用委托；
d．把代码封装在类中。
通过因子分解实现代码重用3 提高可扩充性
提高可扩充行的主要准则为：
（1）封装实现策略；
（2）不要用一个方法遍历多条关联链；
（3）避免使用多分支语句；
（4）精心确定公有方法。
4 提高健壮性
（1）健壮性定义
健壮性是在硬件故障、输入的数据无效或操作错误等意外环境下，系统
能做出适当响应的程度。
（2）提高健壮性的主要准则
① 预防用户的操作错误；
② 检查参数的合法性；
③ 不要预先确定限制条件；
④ 先测试后优化。</p><h2 id=三测试策略1-经典的测试策略>三、测试策略1 经典的测试策略<a hidden class=anchor aria-hidden=true href=#三测试策略1-经典的测试策略>#</a></h2><p>测试软件的经典策略是，从“小型测试”开始，逐步过渡到“大型测试”。
可以分为以下三步：
（1）单元测试；
（2）集成测试；
（3）确认测试、系统测试。
2 面向对象测试策略
（1）面向对象的单元测试
最小的可测试单元是封装起来的类和对象。测试面向对象软件时，不能
再孤立地测试单个操作，而应该把操作作为类的一部分来测试。
（2）面向对象的集成测试
① 策略
a．基于线程的测试；
b．基于使用的测试。
② 集群测试
集群测试是面向对象软件集成测试的一个步骤。在这个测试步骤中，测
试用例力图发现协作错误。（3）面向对象的确认测试
① 不再考虑类之间相互连接的细节。
② 集中检查用户可见的动作和用户可识别的输出。
③ 主要根据动态模型和描述系统行为的脚本来设计确认测试用例。
【注意】面向对象系统的确认测试也是面向黑盒的，基于情景的测试是
面向对象系统确认测试的主要方法。</p><h2 id=四设计测试用例>四、设计测试用例<a hidden class=anchor aria-hidden=true href=#四设计测试用例>#</a></h2><h2 id=title-12>1 测试类的方法
（1）随机测试；
（2）划分测试；
（3）基于故障的测试。
2 集成测试方法
（1）多类测试
① 随机测试；
② 划分测试。
（2）从动态模型导出测试用例12.2 课后习题&mdash;
title: 12</h2><h2 id=title-总体设计>复习笔记
一、估算软件规模
软件项目管理先于任何技术活动之前开始，并且贯穿于软件的整个生命
周期之中，而制定计划的基础是工作量估算和完成期限估算。
1 代码行技术
（1）定义
代码行技术依据以往开发类似产品的经验和历史数据，估计实现一个功
能所需要的源程序行数。
（2）方法
① 每名工程师估计程序的最小规模（a）、最大规模（b）和最可能的规
模（m），分别算出这3种规模的平均值后，再用下式计算程序规模的
估计值：
（13.1）
② 程序较小时用的单位是代码行数（LOC）；程序较大时用的单位是千
行代码数（KLOC）。（3）优点
① 代码是所有软件开发项目都有的“产品”，而且很容易计算代码行数。
② 有以往开发类似产品的历史数据可参考时，估计出的数值比较准确。
（4）缺点
① 源程序仅是软件配置的一个成分，用它的规模代表整个软件的规模不
太合理。
② 用不同语言实现同一个软件所需要的代码行数并不相同。
③ 不适用于非过程语言。
2 功能点技术
（1）特点
① 功能点技术依据对软件信息域特性和软件复杂性的评估结果，估算软
件规模。
② 以功能点（FP）为单位度量软件规模。
（2）信息域特性
① 输入项数（Inp）
② 输出项数（Out）
③ 查询数（Inq）④ 主文件数（Maf）
⑤ 外部接口数（Inf）
（3）估算功能点的步骤
① 计算未调整的功能点数UFP
需记住公式：
UFP＝a1×Inp＋a2×Out＋a3×Inq＋a4×Maf＋a5×Inf
其中，ai（1≤i≤5）是信息域特性系数，由相应特性的复杂级别决定，如
表13-1所示。
表13-1 信息域特性系数值
② 计算技术复杂性因子TCF
在表13-2中列出了全部技术因素，并用Fi（1≤i≤14）代表这些因素。
表13-2 技术因素a．根据软件的特点，为每个因素分配一个从0到5的值。
b．用下式计算技术因素对软件规模的综合影响程度DI（0～70）：
c．技术复杂性因子TCF（0.65～1.35）由下式计算：TCF＝0.65＋
0.01×DI
③ 计算功能点数FP
用下式计算功能点数FP：FP＝UFP×TCF
（4）功能点技术的优缺点
① 优点：功能点数与所用的编程语言无关，比代码行技术更合理；② 缺点：在判断信息域特性复杂级别和技术因素的影响程度时，功能点
技术存在相当大的主观因素。
二、工作量估算
1 工作量概念
工作量是软件规模的函数，工作量的单位通常是人月（pm）。
2 静态单变量模型
（1）形式
静态单变量模型的总体结构形式如下：
E=A+B×(eν)c
其中，A、B和C是由经验数据导出的常数，E是以人月为单位的工作
量，eν是估算变量（KLOC或FP）。
（2）分类
① 面向KLOC的估算模型
a．Walston_Felix模型：E=5.2×(KLOC)0.91
b．Bailey_Basili模型：E=5.5+0.73×(KLOC)1.16
c．Boehm简单模型：E=3.2×(KLOC)1.05
d．Doty模型（KLOC>9时适用）：E=5.288×(KLOC)1.047② 面向FP的估算模型
a．Albrecht & Gaffney模型：E=-13.39+0.0545FP
b．Maston，Barnett和Mellichamp模型：E=585.7+15.12FP
3 动态多变量模型
① 特点
动态多变量模型把工作量看作软件规模和开发时间这两个变量的函数。
② 形式
动态多变量估算模型的形式如下：
（13.2）
其中，E是以人月或人年为单位的工作量；t是以月或年为单位的项目持
续时间；B是特殊技术因子。
4 COCOMO2模型（构造性成本模型）
（1）3层模型
① 应用系统组成模型；
② 早期设计模型；③ 体系结构模型。
（2）形式
COCOMO2模型把软件开发工作量表示成代码行数（KLOC）的非线性
函数：
（13.3）
其中：E是开发工作量（以人月为单位）；a是模型系数；KLOC是估计
的源代码行数（以千行为单位）；b是模型指数；fi（i＝1～17）是成本
因素。
（3）模型指数
COCOMO2采用了b分级模型，是使用5个分级因素Wi（1≤i≤5），其中
每个因素都划分成从甚低（Wi＝5）到特高（Wi＝0）的6个级别，用下
式计算b（1.01～1.26）的数值：
（13.4）
（4）COCOMO2的5个分级因素
① 项目先例性；
② 开发灵活性；
③ 风险排除度；④ 项目组凝聚力；
⑤ 过程成熟度。
三、进度计划
1 相关概念
（1）一个有效的软件过程应该定义一个适用于当前项目的任务集合。
（2）一个任务集合包括一组软件工程工作任务、里程碑和可交付的产
品。
2 估算开发时间
（1）利用成本估算模型估算开发时间
① Walston_Felix模型：T=2.5E0.35
② 原始的COCOMO模型：T=2.5E0.38
③ COCOMO2模型：T=3.0E0.33+0.2×(b-1.01)
④ Putnam模型T=2.4E1/3
其中，E是开发工作量（以人月为单位）；T是开发时间（以月为单
位）。
（2）项目组规模与项目组总生产率的关系
① 通信路径项目组成员之间的通信路径数，由项目组人数和项目组结构决定。通信
路径数大约在P～P2/2的范围内变化。
② 平均生产力
某一个组员与其他组员通信的路径数在1～（P-1）的范围内变化。如果
不与任何人通信时个人生产率为L，而且每条通信路径导致生产率减少
1，则组员个人平均生产率为：Lr=L-l(P-1)r，其中，r是对通信路径数的
度量，0&lt;r≤1。
③ 总生产率
对于一个规模为P的项目组，项目组的总生产率为：Ltot=P(L-l(P-1)r)。
对于给定的一组L，l和r的值，总生产率Ltot是项目组规模P的函数。
3 Gantt图
（1）优点
① 很形象地描绘任务分解情况，以及每个子任务（作业）的开始时间和
结束时间。
② 容易掌握、容易绘制。
（2）缺点
① 不能显式地描绘各项作业彼此间的依赖关系。
② 进度计划的关键部分不明确，难于判定哪些部分应当是主攻和主控的对象。
③ 计划中有潜力的部分及潜力的大小不明确，往往造成潜力的浪费。
4 工程网络
（1）定义
工程网络描绘任务分解情况以及每项作业的开始时间和结束时间，并描
绘了各个作业彼此间的依赖关系。
（2）表示
① 用箭头表示作业；
② 用圆圈表示事件；
③ 用虚线箭头表示虚拟作业。
5 估算工程进度
（1）完善工程网络
① 把每个作业估计需要使用的时间写在表示该项作业的箭头上方。
② 为每个事件计算最早时刻EET和最迟时刻LET，分别写在表示事件的
圆圈的右上角和右下角。
（2）最早时刻EET事件的最早时刻是该事件可以发生的最早时间。
（3）最迟时刻LET
事件的最迟时刻是在不影响工程竣工时间的前提下，该事件最晚可以发
生的时刻。
6 关键路径
（1）定义
由最早时刻和最迟时刻相同的事件定义了关键路径。
（2）特点
① 处于关键路径之外的任务进度拖后，不会影响整个项目的完成时间。
② 处于关键路径之中的任务进度拖后，则整个项目的完成日期就会拖
后。
7 机动时间
一个作业可以有的全部机动时间等于它的结束事件的最迟时刻减去它的
开始事件的最早时刻，再减去这个作业的持续时间：机动时间=(LET)结
束-(EET)开始-持续时间。
四、人员组织
1 必要性（1）项目成功的关键在于合理的组织人员，使他们有效地分工协作共同
完成开发工作。
（2）项目组组织得越好，其生产率越高，而且产品质量也越好。
（3）项目组具有了凝聚力，成功的可能性就大大增加了。
2 典型的组织方式
（1）民主制程序员组
① 优点
a．组员们对发现程序错误持积极的态度，有助于更快速地发现错误，
提高代码质量。
b．组员们享有充分民主，小组凝聚力高、学术空气浓厚，有利于攻克
技术难关。
② 缺点
没有明确的权威指导开发过程，组员间将缺乏必要的协调，最终可能导
致工程失败。
③ 适用性
所要开发的软件的技术难度较高时，采用民主制程序员组是适宜的。
（2）主程序员组
① 定义图13-1
主程序员组的结构
② 优点
a．专业化：该组每名成员仅完成他们擅长的工作。
b．层次性：主程序员指挥组员工作，并对项目全面负责。
③ 缺点
符合主程序员、后备程序员、编辑秘书标准的人才在现实社会中并不容
易雇佣到。
（3）现代程序员组
① 主程序员由两个人共同担任，组织结构如图13-2所示。图13-2
现代程序员组的结构
② 制定针对公共职责范围内的事务的处理方案。
③ 实行分组策略。
④ 分散决定。
五、质量保证
1 软件质量
（1）定义
软件质量是软件与明确地和隐含地定义的需求相一致的程度。
【注意】软件需求是度量软件质量的基础，与需求不一致就是质量不
高。（2）软件质量因素与产品活动
① 软件质量因素
如表13-3所示，列出了软件质量因素的简明定义。
表13-3 软件质量因素的定义
② 产品活动（倾向）分类
可以把产品活动分为产品运行、产品修改和产品转移三类。
③ 软件质量因素和3种产品活动的关系
如图13-3所示。图13-3
软件质量因素与产品活动的关系
【注意】图13-3是考点，记住每一质量因素属于哪一产品活动。
2 软件质量保证措施
（1）措施
① 基于非执行的测试（复审或评审）。
② 基于执行的测试（软件测试）。
③ 程序正确性证明。
（2）技术复审
① 优点
能较早发现软件错误，防止错误被传播到软件过程的后续阶段。② 方法
技术复审包括走查和审查等具体方法。
（3）程序正确性证明的方法
① 人工证明。
② 研究能证明程序正确性的自动系统。
六、软件配置管理
1 相关概念
（1）定义
软件配置管理是在软件的整个生命期内管理变化的一组活动。
（2）目的
① 标识变化；
② 控制变化；
③ 确保适当地实现了变化；
④ 向需要知道这类信息的人报告变化。
（3）与维护的区别
① 维护是在软件交付给用户使用后才发生的。
② 配置管理是在软件项目启动时就开始，并且一直持续到软件退役后才终止的一组跟踪和控制活动。
2 软件配置
（1）软件配置项
① 计算机程序（源代码和可执行程序）。
② 描述计算机程序的文档（供技术人员或用户使用）。
③ 数据（程序内包含的或在程序外的）。
（2）基线
① 定义
基线就是通过了正式复审的软件配置项。
② 作用
基线有助于人们在不严重妨碍合理变化的前提下来控制变化。
3 软件配置管理过程
（1）标识软件配置中的对象；
（2）版本控制；
（3）变化控制；
（4）配置审计；（5）状态报告。
七、能力成熟度模型
1 能力成熟度模型（CMM）
（1）定义
能力成熟度模型（CMM）是用于评价软件机构的软件过程能力成熟度
的模型。
（2）目的
① 为大型软件项目的招投标活动提供一种全面而客观的评审依据。
② 应用于许多软件机构内部的过程改进活动中。
（3）基本思想
由于问题是由人们管理软件过程的方法不当引起的，所以新软件技术的
运用并不会自动提高软件的生产率和质量。
（4）作用
① 有助于软件开发机构建立一个有规律的、成熟的软件过程。
② 改进后的软件过程将开发出质量更好的软件，避免时间延误和费用超
支。
（5）对能力成熟度划分的原因
① 对软件过程的改进，是在完成一个又一个小的改进步骤基础上不断进行的渐进过程。
② 这5个成熟度等级定义了一个有序的尺度，用以测量软件机构的软件
过程成熟度和评价其软件过程能力。
③ 成熟度等级帮助软件机构把应做的改进工作排出优先次序。
④ 成熟度等级是妥善定义的向成熟软件机构前进途中的平台，每个成熟
度等级都为软件过程的继续改进提供了一个台阶。
2 能力成熟度的5个等级
（1）初始级（1级）
（2）可重复级（2级）
（3）已定义级（3级）
（4）已管理级（4级）
（5）优化级（5级）13.2 课后习题&mdash;
title: 总体设计</h2><p>复习笔记</p><h2 id=一设计过程>一、设计过程<a hidden class=anchor aria-hidden=true href=#一设计过程>#</a></h2><p>1 目的
总体设计的基本目的就是回答“系统应该如何实现”这个问题。
2 主要任务
（1）划分出组成系统的物理元素——程序、文件、数据库、人工过程和
文档等。
（2）确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的
关系。
【注意】每个物理元素的具体实现是详细阶段的任务。
3 必要性
可以站在全局高度上，以较少的成本选出最佳方案和最合理的软件结构
并开发出较高质量的软件系统。4 组成阶段
（1）系统设计阶段，确定系统的具体实现方案。
（2）结构设计阶段，确定软件结构。
5 典型的总体设计过程（略）</p><h2 id=二设计原理>二、设计原理<a hidden class=anchor aria-hidden=true href=#二设计原理>#</a></h2><p>1 模块化
（1）定义
模块化就是把程序划分成独立命名且可独立访问的模块，每个模块完成
一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能
满足用户的需求。
（2）优点
① 使软件结构清晰，不仅容易设计也容易阅读和理解。
② 使软件容易测试和调试，有助于提高软件的可靠性。
③ 提高软件的可修改性。
④ 有助于软件开发工程的组织管理。
【注意】模块是构成程序的基本构件。
2 抽象
（1）定义
抽象就是抽出事物的本质特性而暂时不考虑它们的细节。
（2）优点
① 简化了软件的设计和实现；
② 提高了软件的可理解性和可测试性；
③ 使得软件更容易维护。
3 逐步求精
（1）定义
定义为：为了能集中精力解决主要问题而尽量推迟对问题细节的考虑。
（2）原理
① 逐步求精是一种自顶向下的设计策略。
② 求精实际上是细化过程。
4 信息隐藏和局部化
（1）局部化定义
指把一些关系密切的软件元素物理地放得彼此靠近。（2）信息隐藏原理
使得一个模块内包含的信息（主要是实现细节）对于不需要这些信息的
模块来说，是不能访问的。
5 模块独立
（1）定义
开发的模块具有独立功能而且和其他模块之间没有过多的相互作用的模
块，就可以做到模块独立。
（2）两个度量标准：耦合和内聚。
（3）耦合
① 定义
耦合是对一个软件结构内不同模块之间互连程度的度量。
② 分类
a．完全独立；
b．数据耦合；
c．控制耦合；
d．特征耦合；
e．公共环境耦合；f．内容耦合。
【说明】教材中给出上述六种分类，但个人所学和网上更普遍的分类是
下图中的七种。
（4）内聚
① 定义
内聚衡量一个模块内部各个元素彼此结合的紧密程度。
② 分类
【注意】考生牢记：设计的软件尽量满足“高内聚、低耦合”和“高扇入、
低扇出”原则。</p><h2 id=三启发规则>三、启发规则<a hidden class=anchor aria-hidden=true href=#三启发规则>#</a></h2><p>1 改进软件结构提高模块独立性
2 模块规模应该适中3 深度、宽度、扇出和扇入都应适当
（1）深度
深度表示软件结构中控制的层数。
（2）宽度
宽度是软件结构内同一个层次上的模块总数的最大值。宽度越大系统越
复杂。对宽度影响最大的因素是模块的扇出。
（3）扇出
扇出是一个模块直接控制的模块数目。
（4）扇入
扇入表明有多少个上级模块直接调用它。
4 模块的作用域应该在控制域之内
（1）定义
① 模块的作用域定义为受该模块内一个判定影响的所有模块的集合。
② 模块的控制域是这个模块本身以及所有直接或间接从属于它的模块的
集合。
5 力争降低模块接口的复杂程度6 设计单入口单出口的模块
7 模块功能应该可以预测</p><h2 id=四描绘软件结构的图形工具>四、描绘软件结构的图形工具<a hidden class=anchor aria-hidden=true href=#四描绘软件结构的图形工具>#</a></h2><p>1 层次图
（1）作用
层次图用来描绘软件的层次结构。
（2）符号
① 矩形框代表一个模块。
② 方框间的连线表示调用关系。
2 HIPO图
HIPO图是“层次图加输入/处理/输出图”的缩写。在层次图里除了最顶层
的方框外，每个方框都加了编号。
3 结构图
结构图的符号表示分为两类：（1）基本符号
① 方框代表一个模块，框内注明模块的名字或主要功能；
② 方框之间的箭头（或直线）表示模块的调用关系；
③ 尾部是空心圆的箭头表示传递的是数据，实心圆的箭头表示传递的是
控制信息。
（2）特殊符号
① 表示当模块M中某个判定为真时调用模块A，为假时调用模块B，如
图5-1所示；
② 表示模块M循环调用模块A、B和C，如图5-2所示。
图5-1 判定为真时调用A，为假时调用B
图5-2 模块M循环调用模块A、B、C</p><h2 id=五面向数据流的设计方法>五、面向数据流的设计方法<a hidden class=anchor aria-hidden=true href=#五面向数据流的设计方法>#</a></h2><h2 id=title-3>1 信息流的类型
（1）变换流（顺序）
变换流具有如下特征：
① 信息沿输入通路进入系统，同时由外部形式变换成内部形式；
② 进入系统的信息通过变换中心，经加工处理后沿输出通路变成外部形
式离开软件系。
（2）事务流(选择)
事务流是“以事务为中心”的数据流，即数据沿输入通路到达一个处理
T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执
行。
2 设计过程
图5-3说明了使用面向数据流方法逐步设计的过程。图5-3
面向数据流方法的设计过程
【注意】任何设计过程都不是机械的一成不变的。
3 变换分析
（1）适用性
一般说来，如果数据流不具有显著的事务特点，最好使用变换分析。
（2）设计步骤① 复查基本系统模型；
② 复查并精化数据流图；
③ 确定数据流图具有变换特性还是事务特性；
④ 确定输入流和输出流的边界，从而孤立出变换中心；
⑤ 第一级分解；
⑥ 第二级分解；
⑦ 使用设计度量和启发式规则对第一次分割得到的软件结构进一步精
化。
4 事务分析
（1）适用性
在数据流具有明显的事务特点时，即有一个明显的事务中心时，采用事
务分析方法为宜。
（2）设计
事务分析的映射方法如图5-4所示。图5-4
事务分析的映射方法
5 设计优化
（1）设计优化时应遵循的原则。
① 应该开发能够满足所有功能和性能要求，而且按照设计原理和启发式
设计规则衡量是值得接收的软件。
② 应该在设计的早期阶段尽量对软件结构进行精化。
③ 结构简单通常既表示设计风格优雅，又表明效率高。
④ 对于时间是决定性因素的应用场合，可能需要在详细设计阶段或在编写程序的过程中进行优化。
（2）可以采用以下几种方法对时间起决定性作用的软件进行优化。
① 在不考虑时间因素的前提下开发并精化软件结构。
② 在详细设计阶段选出最耗费时间的那些模块，仔细地设计它们的处理
过程（算法），以求提高效率。
③ 使用高级程序设计语言编写程序。
④ 在软件中孤立出那些大量占用处理机资源的模块。
⑤ 必要时重新设计或用依赖于机器的语言重写上述大量占用资源的模块
的代码，以求提高效率。5.2 课后习题&mdash;
title: 3</h2><h2 id=title-软件工程>复习笔记
一、概述
1 非形式化方法的缺点
（1）矛盾；
（2）二义性；
（3）含糊性；
（4）不完整性；
（5）抽象层次混乱。
【注意】用自然语言描述需求规格说明，是典型的非形式化方法。
2 形式化方法的优点
（1）能保证规格说明中尽可能没有矛盾、二义性、含糊性和不完整性。
（2）可以在不同的软件工程活动之间平滑地过渡。
（3）提供了高层确认的手段。3 形式化方法的缺点
（1）难于表示问题的时序、控制和行为等方面的需求。
（2）相比欠形式化方法，它更难学习，培训的投资过大。
【注意】如果一种方法有坚实的数学基础，那么它就是形式化的。
4 应用形式化方法的准则
（1）应该选用适当的表示方法。
（2）应该形式化，但不要过分形式化。
（3）应该估算成本。
（4）应该有形式化方法顾问随时提供咨询。
（5）不应该放弃传统的开发方法。
（6）应该建立详尽的文档。
（7）不应该放弃质量标准。
（8）不应该盲目依赖形式化方法。
（9）应该测试、测试再测试。
（10）应该重用。
二、有穷状态机1 概念
（1）定义
有穷状态机是表达规格说明的一种形式化方法。
（2）构成
一个有穷状态机包括下述5个部分：状态集J、输入集K、由当前状态和
当前输入确定下一个状态（次态）的转换函数T、初始态S和终态集F。
一个有穷状态机可以表示为一个5元组（J，K，T，S，F）。其中：J是
一个有穷的非空状态集；K是一个有穷的非空输入集；T是一个从(J-
F)×K到J的转换函数；S∈J，是一个初始状态；F⊆J，是终态集。
（3）状态转换形式
当前状态[菜单]＋事件[所选择的项]⇒下个状态
（4）谓词集P
① 谓词集P把有穷状态机扩展为一个6元组，其中每个谓词都是系统全
局状态Y的函数。
② 加入谓词集后转换规则形式为：当前状态[菜单]＋事件[所选择的项]
＋谓词⇒下个状态。
2 评价
（1）优点
① 采用易于书写、易于验证的格式来描述规格说明，能容易地把规格说明转变成设计或程序代码。
② 比数据流图技术更精确且易于理解。
（2）缺点
① 在开发一个大系统时，三元组（即状态、事件、谓词）的数量会迅速
增长。
② 形式化的有穷状态机方法没有处理定时需求。
三、Petri网
1 概念
（1）构成
① 一般构成
Petri网包含4种元素：一组位置P、一组转换T、输入函数I，以及输出函
数O。如图4-1为Petri网的实例。
图4-1
Petri网的组成a．一组位置P为{P1，P2，P3，P4}，在图中用圆圈代表位置。
b．一组转换T为{T1，T2}，在图中用短直线表示转换。
c．两个用于转换的输入函数，用由位置指向转换的箭头表示，它们
是：
I(t1)={P2，P4}
I(t2)={P2}
d．两个用于转换的输出函数，用由转换指向位置的箭头表示，它们
是：
O(t1)={P1}
O(t2)={P3，P3}
【注意】输出函数O(t1)中有两个P3，是因为有两个箭头由t2指向P3。
② 形式化的Petri网
更形式化的Petri网结构是一个四元组：
C=(P，T，I，O)
其中：
a．P={P1，…，Pn}是一个有穷位置集，n≥0。
b．T={t1，…，tm}是一个有穷转换集，m≥0，且T和P不相交。
c．I：T→P∞为输入函数，是由转换到位置无序单位组（bags）的映射。
d．O：T→P∞为输出函数，是由转换到位置无序单位组的映射。
（2）作用
用于确定系统中隐含的定时问题，可以有效地描述并发活动。
四、Z语言
1 组成部分
（1）给定的集合；
（2）状态定义；
（3）初始状态；
（4）操作。
2 优点
（1）可以比较容易地发现用Z写的规格说明的错误；
（2）使用Z写规格说明时对精确性要求高，减少了模糊性、不一致性和
遗漏；
（3）可以降低软件开发费用；
（4）用Z写规格说明，更加清楚和正确。4.2 课后习题&mdash;
title: 软件工程</h2><p>复习笔记</p><h2 id=一软件危机>一、软件危机<a hidden class=anchor aria-hidden=true href=#一软件危机>#</a></h2><h3 id=1-软件危机的介绍>1 软件危机的介绍<a hidden class=anchor aria-hidden=true href=#1-软件危机的介绍>#</a></h3><p>（1）概念
软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。
（2）典型表现
① 对软件开发<strong>成本</strong>和<strong>进度</strong>的估计不准确。
② 用户对“已完成的”软件系统不满意的现象经常发生。
③ 软件产品的质量往往靠不住。
④ 软件常常是不可维护的。
⑤ 软件通常没有适当的文档资料。
⑥ 软件成本在计算机系统总成本中所占的比例逐年上升。
⑦ 软件开发跟不上计算机应用迅速普及深入的趋势。
【注意】考试中常考查软件的概念，记住公式：软件＝程序＋数据＋文档。</p><h3 id=2-产生软件危机的原因>2 产生软件危机的原因<a hidden class=anchor aria-hidden=true href=#2-产生软件危机的原因>#</a></h3><p>（1）客观原因
① 软件是计算机系统中的逻辑部件，缺乏“可见性”，因此管理和控制软
件开发过程相当困难。
② 软件维护通常意味着改正或修改原来的设计，因此软件较难维护。
③ 软件规模庞大，而程序复杂性将随着程序规模的增加而呈指数上升。
（2）主观原因
① 存在与软件开发和维护有关的许多错误认识和做法。
② 对用户要求没有完整准确的认识就匆忙着手编写程序。
③ 开发人员只重视程序而忽视软件配置的其余成分（文档和数据等）。
④ 软件开发人员轻视维护。</p><h3 id=3-消除软件危机的途径>3 消除软件危机的途径<a hidden class=anchor aria-hidden=true href=#3-消除软件危机的途径>#</a></h3><p>（1）应该对计算机软件有一个正确的认识。
（2）应该充分认识到软件开发是一种组织良好、管理严密、各类人员协
同配合、共同完成的工程项目。
（3）应该推广使用在实践中总结出来的开发软件的成功的技术和方法，并且研究探索更好更有效的技术和方法。
（4）应该开发和使用更好的软件工具。</p><h2 id=二软件工程>二、软件工程<a hidden class=anchor aria-hidden=true href=#二软件工程>#</a></h2><h3 id=1-软件工程的介绍>1 软件工程的介绍<a hidden class=anchor aria-hidden=true href=#1-软件工程的介绍>#</a></h3><p>（1）概念
采用<strong>工程</strong>的概念、原理、技术和方法来开发与维护软件，把经过时间考
验而证明正确的<strong>管理技术</strong>和当前能够得到的最好的<strong>技术方法</strong>结合起来，
以经济地开发出高质量的软件并有效地维护它，这就是软件工程。
（2）本质特征
① 软件工程关注于大型程序的构造；
② 软件工程的中心课题是控制复杂性；
③ 软件经常变化；
④ 开发软件的效率非常重要；
⑤ 和谐地合作是开发软件的关键；
⑥ 软件必须有效地支持它的用户；
⑦ 软件工程领域由具有一种文化背景的人替具有另一种文化背景的人创
造产品。</p><h3 id=2-软件工程的基本原理>2 软件工程的基本原理<a hidden class=anchor aria-hidden=true href=#2-软件工程的基本原理>#</a></h3><p>（1）七条基本原理
① 用分阶段的生命周期计划严格管理；
② 坚持进行阶段评审；
③ 实行严格的产品控制；
④ 采用现代程序设计技术；
⑤ 结果应能清楚地审查；
⑥ 开发小组的人员应该少而精；
⑦ 承认不断改进软件工程实践的必要性。
（2）意义
这七条原理是确保软件产品质量和开发效率的原理的最小集合，它们是
互相独立的，而且是缺一不可的最小集合，然而这七条原理又是相当完
备的。</p><h3 id=3-软件工程方法学>3 软件工程方法学<a hidden class=anchor aria-hidden=true href=#3-软件工程方法学>#</a></h3><p>（1）概念
通常把软件生命周期全过程中使用的一整套技术方法的集合称为方法
学，也称为范型。目前使用得最广泛的软件工程方法学，分别是传统方法学和面向对象方法学。
（2）三要素
软件工程方法学包括3个要素：方法、工具和过程。</p><p>（3）传统方法学（生命周期方法学或结构化范型）
① 定义
采用结构化技术（结构化分析、结构化设计和结构化实现）来完成软件
开发的各项任务，并使用适当的软件工具或软件工程环境来支持结构化
技术的运用。
② 优点
a．把软件生命周期划分成若干相对独立、简单的阶段，便于不同人员
分工协作，降低开发的困难程度；
b．开发过程中采用科学的管理技术和良好的技术方法，且在每个阶段
结束之前都进行严格的审查，保证了软件的质量，提高了软件的可维护
性；
c．大大提高了软件开发的成功率和生产率。
③ 缺点
a．不适用于软件规模庞大、或者对软件的需求是模糊的或会随时间变
化而变化的情况。
b．结构化范型技术把数据和操作人为地分离成两个独立的部分，增加
了软件开发与维护的难度。</p><p>（4）面向对象方法学
① 定义
面向对象方法是一种以数据为主线，把数据和对数据的操作紧密地结合
起来的方法。
② 要点
a．把对象作为融合了数据及在数据上的操作行为的统一的软件构件；
b．把所有对象都划分成类；
c．继承性；
d．对象彼此间仅能通过发送消息互相联系（执行方法）。
③ 与传统方法学的对比
a．传统方法学强调自顶向下、逐层分解、顺序开发。
b．面向对象方法学强调主动地多次反复迭代地开发，保证了在各项开
发活动之间的平滑过渡。
④ 优点
a．降低了软件产品的复杂性；
b．提高了软件的可理解性；
c．简化了软件的开发和维护工作；
d．提高了软件的可重用性。【注意】常考面向对象方法学的基本特征：类、继承、封装、多态。结
合第9章掌握其含义和意义。</p><h2 id=三软件生命周期>三、软件生命周期<a hidden class=anchor aria-hidden=true href=#三软件生命周期>#</a></h2><p>1 组成
（1）软件定义
软件定义时期通常进一步划分成3个阶段，即问题定义、可行性研究和
需求分析。
（2）软件开发
通常由下述4个阶段组成：总体设计，详细设计，编码和单元测试，综
合测试。其中前两个阶段又称为系统设计，后两个阶段又称为系统实
现。
（3）运行和维护（软件维护）
【注意】考题中常设置选项：在详细设计阶段编写代码。这是错误的，
在编码和单元测试阶段才编写代码。
2 维护活动的分类
① 改正性维护；
② 适应性维护；
③ 完善性维护；
④ 预防性维护。</p><h2 id=四软件过程>四、软件过程<a hidden class=anchor aria-hidden=true href=#四软件过程>#</a></h2><h3 id=1-概念>1 概念<a hidden class=anchor aria-hidden=true href=#1-概念>#</a></h3><p>（1）定义
软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规
定了完成各项任务的工作步骤。
（2）表示
使用生命周期模型简洁地描述软件过程。</p><h3 id=2-典型软件过程模型>2 典型软件过程模型<a hidden class=anchor aria-hidden=true href=#2-典型软件过程模型>#</a></h3><h2 id=title-需求分析>【注意】考生要着重掌握瀑布模型、快速原型模型、螺旋模型、增量模
型、喷泉模型。
（1）瀑布模型
① 开发流程
实际的瀑布模型是带“反馈环”的，如图1-1所示（图中实线箭头表示开
发过程，虚线箭头表示维护过程）。图1-1
实际的瀑布模型
【注意】传统的瀑布模型没有图中的反馈环。
② 特点
第一，阶段间具有顺序性和依赖性；
第二，推迟实现的观点；第三，质量保证的观点。
③ 瀑布模型的优缺点
a．优点
第一，可强迫开发人员采用规范的方法；
第二，严格地规定了每个阶段必须提交的文档；
第三，要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验
证；
第四，对文档的约束，使软件维护变得容易一些，且能降低软件预算。
b．缺点
第一：瀑布模型是由文档驱动的。
第二：缺乏对于需求变更和项目变化的适应性。
（2）快速原型模型
① 开发流程
如图1-2所示（图中实线箭头表示开发过程，虚线箭头表示维护过
程）。图1-2
快速原型模型
② 优点
快速原型模型是不带反馈环的。
【注意】快速原型模型弥补了瀑布模型不适用于需求动态变更的缺点，
其本质是“快速”。
（3）增量模型
① 开发步骤增量模型也称为渐增模型，如图1-3所示。
图1-3
增量模型
② 原理
把软件产品作为多个增量构件来设计、编码、集成、测试，开发人员一
个构件接一个构件地向用户提交产品。
③ 优点
a．能在较短时间内向用户提交可完成部分工作的产品。
b．逐步增加产品功能可以使用户有较充裕的时间学习和适应新产品。
④ 技术难点
a．要求软件体系结构必须是开放的。
b．增量模型本身是自相矛盾的。c．增量模型的灵活性很容易退化为边做边改模型，从而使软件过程的
控制失去整体性。
⑤ 风险更大的增量模型
图1-4是一种风险更大的增量模型。
图1-4
风险更大的增量模型
【注意】每个增量构件的开发采用瀑布模型。
（4）螺旋模型
① 基本思想
可以把它看作在每个阶段之前都增加了风险分析过程的快速原型模型，
如图1-5所示。图1-5
② 原理
完整的螺旋模型如图1-6所示。
简化的螺旋模型图1-6
完整的螺旋模型
③ 应用
螺旋模型主要适用于内部开发的大规模软件项目。
④ 优点
a．有利于已有软件的重用，有助于把软件质量作为软件开发的一个重要目标；
b．减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的
风险；
c．在螺旋模型中维护只是模型的另一个周期，在维护和开发之间并没
有本质区别。
⑤ 缺点
螺旋模型是风险驱动的。要求软件开发人员具有丰富的风险评估经验和
这方面的专门知识。
（5）喷泉模型
① 开发流程
图1-7所示的喷泉模型，是典型的面向对象的软件过程模型之一。图1-7
喷泉模型
② 特点
a．喷泉模型是一种以用户需求为动力，以对象为驱动的模型，主要用
于描述面向对象的软件开发过程。
b．体现了面向对象软件开发过程迭代和无缝的特性。
（6）Rational统一过程（RUP）
① RUP软件开发生命周期RUP软件开发生命周期是一个二维的面向对象的生命周期模型，如图1-
8所示。图中纵轴代表核心工作流，横轴代表时间。
图1-8 RUP软件开发生命周期
② 核心工作流
如上图纵轴所示，由上至下有九个核心工作流，前六个为核心过程工作
流程，后三个为核心支持工作流程。
③ 工作阶段a．初始阶段。
b．精化阶段。
c．构建阶段。
d．移交阶段。
④ 特点
a．采用迭代和渐增的方式开发软件。
b．具有多功能性和广泛适用性。
（7）敏捷过程
敏捷过程能够较好地适应商业竞争环境下对小型项目提出的有限资源和
有限开发时间的约束。敏捷过程中最重要的是极限编程。
（8）极限编程
① 极限编程的整体开发过程
图1-9描述了极限编程的整体开发过程。图1-9 XP项目的整体开发过程
② 极限编程的迭代过程
图1-10描述了极限编程的迭代开发过程。图1-10 XP迭代开发过程
③ 特点
a．以极限编程为代表的敏捷过程，具有对变化和不确定性的更快速、
更敏捷的反应特性；
b．在快速的同时仍然能够保持可持续的开发速度。
（9）微软过程
① 微软软件生命周期
微软过程把软件生命周期划分成五个阶段，图1-11描绘了生命周期的阶
段及每个阶段的主要里程碑。
图1-11
② 微软过程模型
a．定义
微软软件生命周期阶段划分和主要里程碑图1-12描绘了微软过程的生命周期模型。
图1-12
微软过程的生命周期模型
b．特点
第一，适用于商业环境下具有有限资源和有限开发时间约束的项目；
第二，微软过程也有某些不足之处，例如，对方法、工具和产品等方面
的论述不如RUP和敏捷过程全面，人们对它的某些准则本身也有不同意
见。&mdash;
title: 需求分析</h2><p>复习笔记</p><h2 id=一需求分析的任务>一、需求分析的任务<a hidden class=anchor aria-hidden=true href=#一需求分析的任务>#</a></h2><p>1 需求分析的定义
需求分析是发现、求精、建模、规格说明和复审的过程。
2 需求分析的必要性
为了开发出真正满足用户需求的成功的软件产品，必须知道用户的需
求。
3 需求分析的任务
（1）确定对系统的综合要求；
（2）分析系统的数据要求；
（3）导出系统的逻辑模型；
（4）修正系统开发计划。4 对软件系统的综合需求
（1）功能需求
（2）性能需求
（3）可靠性和可用性需求
（4）出错处理需求
（5）接口需求
（6）约束
（7）逆向需求
（8）将来可能提出的要求
【注意】在描绘系统中的数据结构，使用层次方框图或Warnier图等图形
工具。</p><h2 id=二与用户沟通获取需求的方法>二、与用户沟通获取需求的方法<a hidden class=anchor aria-hidden=true href=#二与用户沟通获取需求的方法>#</a></h2><p>1 访谈
2 面向数据流自顶向下求精
3 简易的应用规格说明技术
4 快速建立软件原型</p><h2 id=三分析建模与规格说明>三、分析建模与规格说明<a hidden class=anchor aria-hidden=true href=#三分析建模与规格说明>#</a></h2><p>1 分析建模
（1）模型
模型由一组图形符号和组织这些符号的规则组成。
（2）建模过程
结构化分析实质上是一种创建模型的活动，应从不同的角度抽象目标系
统的特性。
2 软件需求规格说明
软件需求规格说明书是需求分析阶段得出的最主要的文档。</p><h2 id=四实体-联系图>四、实体-联系图<a hidden class=anchor aria-hidden=true href=#四实体-联系图>#</a></h2><p>1 数据模型的定义
概念性数据模型是一种面向问题的数据模型，是按照用户的观点对数据
建立的模型。
2 数据模型的构成
（1）数据对象① 定义
数据对象是对软件必须理解的复合信息的抽象。
② 特点
a．可以由一组属性来定义的实体都可以被认为是数据对象。
b．数据对象彼此间是有关联的。
c．数据对象只封装了数据而没有对施加于数据上的操作的引用。
（2）属性
属性定义了数据对象的性质。
（3）联系
数据对象彼此之间相互连接的方式称为联系，也称为关系。联系也可能
有属性。联系可分为以下3种类型。
① 一对一联系（1：1）
② 一对多联系（1：N）
③ 多对多联系（M：N）
3 实体-联系图（E-R图）
（1）基本成分E-R图中包含了实体（数据对象）、关系和属性3种基本成分，通常用矩
形框代表实体，用连接相关实体的菱形框表示关系，用椭圆形或圆角矩
形表示实体（或关系）的属性，并用直线把实体（或关系）与其属性连
接起来。
（2）优点
① E-R模型比较接近人的习惯思维方式；
② E-R模型使用简单的图形符号来描述问题，便于用户理解。</p><h2 id=五数据规范化>五、数据规范化<a hidden class=anchor aria-hidden=true href=#五数据规范化>#</a></h2><h2 id=六状态转换图>六、状态转换图<a hidden class=anchor aria-hidden=true href=#六状态转换图>#</a></h2><p>1 定义
状态转换图（状态图）通过描绘系统的状态及引起系统状态转换的事
件，来表示系统的行为。
2 状态
（1）定义
状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行
为模式。
（2）分类状态主要有：初态（初始状态）、终态（最终状态）和中间状态。
【注意】在一张状态图中只能有一个初态，而终态则可以有0至多个。
3 事件
事件是在某个特定时刻发生的事情，是引起系统做动作或（和）转换状
态的控制信息。
4 状态图的符号
（1）符号的表示方法
① 初态：用实心圆表示。
② 终态：用一对同心圆（内圆为实心圆）表示。
③ 中间状态：用圆角矩形表示。可以用两条水平横线把它分成上、中、
下3个部分。上面部分为状态的名称，这部分是必须有的；中间部分为
状态变量的名字和值，下面部分是活动表。
（2）组成部分
图3-1给出了状态图中使用的主要组成部分和符号表示。图3-1
状态图中使用的主要符号
① 活动表
活动表的语法格式为：事件名（参数表）/动作表达式
在活动表中经常使用下述3种标准事件：entry，exit和do。entry事件指定
进入该状态的动作；exit事件指定退出该状态的动作；do事件则指定在
该状态下的动作。
② 状态转换
状态图中两个状态之间带箭头的连线称为状态转换，箭头指明了转换方
向。
③ 事件表达式
事件表达式的语法为：事件说明[守卫条件]/动作表达式，其中，事件说
明的语法为：事件名（参数表）。</p><h2 id=七其他图形工具>七、其他图形工具<a hidden class=anchor aria-hidden=true href=#七其他图形工具>#</a></h2><h2 id=title-速查-1>1 层次方框图层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构。
2 Warnier图
Warnier图有以下三种基本符号：
① 花括号：用来区分数据结构的层次，在一个花括号内的所有名字都属
于同一类信息。
② 异或符号：表明一类信息或一个数据元素在一定条件下才出现。
③ 圆括号中的数字：指明了这个名字代表的信息类在这个数据结构中重
复出现的次数。
3 IPO图
（1）定义
IPO图是输入、处理、输出图的简称，能够方便地描绘输入数据、对数
据的处理和输出数据之间的关系。
（2）基本形式和用法
① 左边的框中列出有关的输入数据；
② 中间的框内列出主要的处理；
③ 右边的框内列出产生的输出数据；
④ 粗大箭头指出数据通信的情况。处理框中列出处理的次序暗示了执行的顺序。
（3）改进的IPO图
改进的IPO图（IPO表）中包含某些附加的信息。如图3-2所示，改进的
IPO图中包含的附加信息主要有系统名称、图的作者，完成的日期，本
图描述的模块的名字，模块在层次图中的编号，调用本模块的模块清
单，本模块调用的模块的清单，注释，以及本模块使用的局部数据元素
等。
图3-2
改进的IPO图的形式
【注意】考生要区分并牢记给定图形工具可用于软件生命周期的哪一阶
段，此为常考题。本节三种图形工具均可用于需求分析阶段。八、验证软件需求
1 验证软件需求的正确性
（1）验证需求正确性的目的
为了提高软件质量，确保软件开发成功，降低软件开发成本。
（2）进行验证的四个方面
① 一致性；
② 完整性；
③ 现实性；
④ 有效性。
2 验证软件需求的方法
（1）验证需求的一致性；
（2）验证需求的现实性；
（3）验证需求的完整性和有效性。
3 用于需求分析的软件工具——PSL/PSA系统
① 定义PSL是用来描述系统的形式语言，PSA是处理PSL描述的分析程序。
② 功能
a．描述任何应用领域的信息系统；
b．创建一个数据库保存对该信息系统的描述符；
c．对描述符施加增加、删除和更改等操作；
d．产生格式化的文档和关于规格说明书的各种分析报告。
③ 优点
a．改进了文档质量，能保证文档具有完整性、一致性和无二义性，从
而可以减少管理和维护的费用；
b．数据存放在数据库中，便于增加、删除和更改。3.2 课后习题&mdash;
title: 速查</h2><h2 id=基本语法>基本语法<a hidden class=anchor aria-hidden=true href=#基本语法>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 输出到控制台</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Hello, world!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 定义变量</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=mi>42</span>
</span></span><span class=line><span class=cl><span class=n>y</span> <span class=o>=</span> <span class=s2>&#34;Python&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 条件语句</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>x</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;x is positive&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>elif</span> <span class=n>x</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;x is zero&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;x is negative&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 循环</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 列表</span>
</span></span><span class=line><span class=cl><span class=n>fruits</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;apple&#34;</span><span class=p>,</span> <span class=s2>&#34;banana&#34;</span><span class=p>,</span> <span class=s2>&#34;cherry&#34;</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>fruits</span><span class=p>[</span><span class=mi>0</span><span class=p>])</span>    <span class=c1># 输出 &#34;apple&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>fruits</span><span class=p>))</span>  <span class=c1># 输出 3</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 字典</span>
</span></span><span class=line><span class=cl><span class=n>person</span> <span class=o>=</span> <span class=p>{</span><span class=s2>&#34;name&#34;</span><span class=p>:</span> <span class=s2>&#34;John&#34;</span><span class=p>,</span> <span class=s2>&#34;age&#34;</span><span class=p>:</span> <span class=mi>30</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>person</span><span class=p>[</span><span class=s2>&#34;name&#34;</span><span class=p>])</span>  <span class=c1># 输出 &#34;John&#34;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>person</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s2>&#34;gender&#34;</span><span class=p>,</span> <span class=s2>&#34;unknown&#34;</span><span class=p>))</span>  <span class=c1># 输出 &#34;unknown&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 函数</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>greet</span><span class=p>(</span><span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Hello, &#34;</span> <span class=o>+</span> <span class=n>name</span> <span class=o>+</span> <span class=s2>&#34;!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>greet</span><span class=p>(</span><span class=s2>&#34;Alice&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 类</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Dog</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>name</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>self</span><span class=o>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>bark</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Woof, woof!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>my_dog</span> <span class=o>=</span> <span class=n>Dog</span><span class=p>(</span><span class=s2>&#34;Fido&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>my_dog</span><span class=o>.</span><span class=n>name</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>my_dog</span><span class=o>.</span><span class=n>bark</span><span class=p>()</span>
</span></span></code></pre></div><h2 id=字符串>字符串<a hidden class=anchor aria-hidden=true href=#字符串>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>a</span><span class=o>=</span><span class=s1>&#39;hello,&#39;</span>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=o>=</span><span class=s1>&#39;world&#39;</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;#&#39;</span><span class=o>*</span><span class=mi>5</span><span class=p>)</span>	<span class=c1>#输出&#39;#####&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># hello,world</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;</span><span class=si>{</span><span class=n>a</span><span class=si>}</span><span class=s1>,</span><span class=si>{</span><span class=n>b</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>	
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>{}</span><span class=s1>,</span><span class=si>{}</span><span class=s1>&#39;</span><span class=o>.</span><span class=n>format</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=s1>&#39;</span><span class=si>%s</span><span class=s1>,</span><span class=si>%s</span><span class=s1>&#39;</span> <span class=o>%</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>))</span>
</span></span></code></pre></div><h2 id=列表>列表<a hidden class=anchor aria-hidden=true href=#列表>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 创建列表</span>
</span></span><span class=line><span class=cl><span class=n>li1</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=n>li2</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>li3</span> <span class=o>=</span> <span class=nb>list</span><span class=p>((</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>))</span>	<span class=c1>#元组转换为列表</span>
</span></span><span class=line><span class=cl><span class=n>li4</span> <span class=o>=</span> <span class=nb>list</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>li5</span> <span class=o>=</span> <span class=p>[</span><span class=n>x</span> <span class=k>for</span> <span class=n>x</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>4</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 更新列表元素</span>
</span></span><span class=line><span class=cl><span class=n>li</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>li</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>li</span><span class=o>.</span><span class=n>insert</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>	<span class=c1>#[1, 2, 4, 3], 下标为2插入4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 删除列表元素</span>
</span></span><span class=line><span class=cl><span class=k>del</span> <span class=n>listname</span><span class=p>[</span><span class=n>index</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=k>del</span> <span class=n>listname</span><span class=p>[</span><span class=n>start</span> <span class=p>:</span> <span class=n>end</span><span class=p>]</span>	<span class=c1>#包括start，不包括end</span>
</span></span><span class=line><span class=cl><span class=n>listname</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=n>index</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>listname</span><span class=o>.</span><span class=n>pop</span><span class=p>()</span>	<span class=c1>#删除最后一个元素</span>
</span></span><span class=line><span class=cl><span class=n>listname</span><span class=o>.</span><span class=n>remove</span><span class=p>(</span><span class=n>value</span><span class=p>)</span>	<span class=c1>#删除第一个和指定值相同的元素</span>
</span></span><span class=line><span class=cl><span class=n>listname</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>	<span class=c1>#删除所有元素</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 读取列表元素</span>
</span></span><span class=line><span class=cl><span class=n>li</span> <span class=o>=</span> <span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>li</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>li</span><span class=p>[</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>	<span class=c1>#最后一个元素</span>
</span></span><span class=line><span class=cl><span class=n>li</span><span class=p>[</span><span class=n>start</span><span class=p>:</span><span class=n>end</span><span class=p>:</span><span class=n>step</span><span class=p>]</span>	<span class=c1>#切片</span>
</span></span><span class=line><span class=cl><span class=nb>len</span><span class=p>(</span><span class=n>li</span><span class=p>)</span>	<span class=c1>#元素个数</span>
</span></span></code></pre></div><h2 id=字典>字典<a hidden class=anchor aria-hidden=true href=#字典>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 创建字典</span>
</span></span><span class=line><span class=cl><span class=n>empty_dict</span> <span class=o>=</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=n>a</span> <span class=o>=</span> <span class=p>{</span><span class=s2>&#34;one&#34;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s2>&#34;two&#34;</span><span class=p>:</span> <span class=mi>2</span><span class=p>,</span> <span class=s2>&#34;three&#34;</span><span class=p>:</span> <span class=mi>3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>b</span> <span class=o>=</span> <span class=nb>dict</span><span class=p>(</span><span class=n>one</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span> <span class=n>two</span><span class=o>=</span><span class=mi>2</span><span class=p>,</span> <span class=n>three</span><span class=o>=</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 更新字典元素</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>[</span><span class=s1>&#39;four&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 读取字典元素</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>a</span><span class=p>[</span><span class=s1>&#39;two&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>a</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=s1>&#39;two&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 删除字典元素</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=o>.</span><span class=n>pop</span><span class=p>(</span><span class=s1>&#39;four&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>del</span> <span class=n>dictname</span><span class=p>[</span><span class=n>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=n>dictname</span><span class=o>.</span><span class=n>clear</span><span class=p>()</span>	<span class=c1>#删除所有元素</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>a</span><span class=o>.</span><span class=n>keys</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>a</span><span class=o>.</span><span class=n>values</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>a</span><span class=o>.</span><span class=n>items</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=c1># dict_keys([&#39;one&#39;, &#39;two&#39;, &#39;three&#39;])</span>
</span></span><span class=line><span class=cl><span class=c1># dict_values([1, 2, 3])</span>
</span></span><span class=line><span class=cl><span class=c1># dict_items([(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 合并字典</span>
</span></span><span class=line><span class=cl><span class=n>x</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;a&#39;</span><span class=p>:</span> <span class=mi>1</span><span class=p>,</span> <span class=s1>&#39;b&#39;</span><span class=p>:</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>y</span> <span class=o>=</span> <span class=p>{</span><span class=s1>&#39;b&#39;</span><span class=p>:</span> <span class=mi>3</span><span class=p>,</span> <span class=s1>&#39;c&#39;</span><span class=p>:</span> <span class=mi>4</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>z1</span> <span class=o>=</span> <span class=p>{</span><span class=o>**</span><span class=n>x</span><span class=p>,</span> <span class=o>**</span><span class=n>y</span><span class=p>}</span>	<span class=c1># {&#39;a&#39;: 1, &#39;b&#39;: 3, &#39;c&#39;: 4}</span>
</span></span><span class=line><span class=cl><span class=n>z2</span> <span class=o>=</span> <span class=p>{</span><span class=o>**</span><span class=n>y</span><span class=p>,</span> <span class=o>**</span><span class=n>x</span><span class=p>}</span>	<span class=c1># {&#39;b&#39;: 2, &#39;c&#39;: 4, &#39;a&#39;: 1}</span>
</span></span></code></pre></div><h2 id=函数>函数<a hidden class=anchor aria-hidden=true href=#函数>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>show</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>age</span><span class=o>=</span><span class=mi>22</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;name=</span><span class=si>{</span><span class=n>name</span><span class=si>}</span><span class=s1>, age=</span><span class=si>{</span><span class=n>age</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># 位置参数，调用时参数顺序数量必须与函数定义一样</span>
</span></span><span class=line><span class=cl><span class=n>show</span><span class=p>(</span><span class=s1>&#39;jack&#39;</span><span class=p>,</span> <span class=mi>22</span><span class=p>)</span>			<span class=c1># name=jack, age=22</span>
</span></span><span class=line><span class=cl><span class=n>show</span><span class=p>(</span><span class=mi>22</span><span class=p>,</span> <span class=s1>&#39;jack&#39;</span><span class=p>)</span>			<span class=c1># name=22, age=jack</span>
</span></span><span class=line><span class=cl><span class=n>show</span><span class=p>(</span><span class=n>age</span><span class=o>=</span><span class=mi>22</span><span class=p>,</span> <span class=n>name</span><span class=o>=</span><span class=s1>&#39;jack&#39;</span><span class=p>)</span>	<span class=c1># name=jack, age=22</span>
</span></span><span class=line><span class=cl><span class=n>show</span><span class=p>(</span><span class=s1>&#39;jack&#39;</span><span class=p>)</span>				<span class=c1># name=jack, age=22</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 可变参数</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>fun</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>fun</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=n>name</span><span class=o>=</span><span class=s1>&#39;jack&#39;</span><span class=p>,</span> <span class=n>age</span><span class=o>=</span><span class=s1>&#39;22&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># (1, 2, 3)</span>
</span></span><span class=line><span class=cl><span class=c1># {&#39;name&#39;: &#39;jack&#39;, &#39;age&#39;: &#39;22&#39;}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 内置函数</span>
</span></span><span class=line><span class=cl><span class=nb>map</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=nb>len</span><span class=p>(</span><span class=n>x</span><span class=p>),</span> <span class=p>[</span><span class=s1>&#39;a&#39;</span><span class=p>,</span> <span class=s1>&#39;aa&#39;</span><span class=p>,</span> <span class=s1>&#39;aaa&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nb>filter</span><span class=p>(</span><span class=k>lambda</span> <span class=n>x</span><span class=p>:</span> <span class=n>x</span><span class=o>%</span><span class=mi>2</span><span class=o>==</span><span class=mi>0</span><span class=p>,</span> <span class=nb>range</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>z</span> <span class=o>=</span> <span class=nb>zip</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span><span class=mi>2</span><span class=p>,</span><span class=mi>3</span><span class=p>],[</span><span class=mi>3</span><span class=p>,</span><span class=mi>4</span><span class=p>,</span><span class=mi>5</span><span class=p>])</span>	<span class=c1>#拉链函数</span>
</span></span><span class=line><span class=cl><span class=nb>list</span><span class=p>(</span><span class=n>z</span><span class=p>)</span>	<span class=c1># [(1, 3), (2, 4), (3, 5)]</span>
</span></span></code></pre></div><h2 id=文件>文件<a hidden class=anchor aria-hidden=true href=#文件>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>f</span> <span class=o>=</span> <span class=nb>open</span><span class=p>(</span><span class=s1>&#39;a.txt&#39;</span><span class=p>,</span> <span class=s1>&#39;w&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=s1>&#39;hello&#39;</span><span class=p>)</span>	<span class=c1># 数据还在缓冲区，文件为空</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=o>.</span><span class=n>flush</span><span class=p>()</span>			<span class=c1># 将缓冲区中的数据立刻写入文件，同时清空缓冲区</span>
</span></span><span class=line><span class=cl><span class=n>f</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span></code></pre></div><h2 id=常用模块>常用模块<a hidden class=anchor aria-hidden=true href=#常用模块>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># 数学模块</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>math</span>
</span></span><span class=line><span class=cl><span class=n>math</span><span class=o>.</span><span class=n>sqrt</span><span class=p>(</span><span class=mi>16</span><span class=p>)</span>  <span class=c1># 返回 4.0</span>
</span></span><span class=line><span class=cl><span class=n>math</span><span class=o>.</span><span class=n>pi</span>        <span class=c1># 返回圆周率 3.141592653589793</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 日期时间模块</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>datetime</span>
</span></span><span class=line><span class=cl><span class=n>now</span> <span class=o>=</span> <span class=n>datetime</span><span class=o>.</span><span class=n>datetime</span><span class=o>.</span><span class=n>now</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>now</span><span class=p>)</span>         <span class=c1># 输出当前时间</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>now</span><span class=o>.</span><span class=n>year</span><span class=p>)</span>    <span class=c1># 输出当前年份</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>now</span><span class=o>.</span><span class=n>month</span><span class=p>)</span>   <span class=c1># 输出当前月份</span>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>now</span><span class=o>.</span><span class=n>day</span><span class=p>)</span>     <span class=c1># 输出当前日期</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 文件和目录操作模块</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>listdir</span><span class=p>(</span><span class=s2>&#34;.&#34;</span><span class=p>)</span>   <span class=c1># 返回当前目录下的所有文件和目录</span>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>exists</span><span class=p>(</span><span class=s2>&#34;file.txt&#34;</span><span class=p>)</span>  <span class=c1># 检查文件是否存在</span>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>mkdir</span><span class=p>(</span><span class=s2>&#34;mydir&#34;</span><span class=p>)</span>  <span class=c1># 创建目录</span>
</span></span><span class=line><span class=cl><span class=n>os</span><span class=o>.</span><span class=n>rename</span><span class=p>(</span><span class=s2>&#34;file.txt&#34;</span><span class=p>,</span> <span class=s2>&#34;newfile.txt&#34;</span><span class=p>)</span>  <span class=c1># 重命名文件</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 随机数</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>random</span>
</span></span><span class=line><span class=cl><span class=n>random</span><span class=o>.</span><span class=n>random</span><span class=p>()</span>	<span class=c1>#返回0到1随机浮点数</span>
</span></span><span class=line><span class=cl><span class=n>random</span><span class=o>.</span><span class=n>randint</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>	<span class=c1>#返回0或1</span>
</span></span><span class=line><span class=cl><span class=n>random</span><span class=o>.</span><span class=n>choice</span><span class=p>([</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>])</span>	<span class=c1>#返回0或1</span>
</span></span><span class=line><span class=cl><span class=n>random</span><span class=o>.</span><span class=n>sample</span><span class=p>(</span><span class=nb>range</span><span class=p>(</span><span class=mi>100</span><span class=p>),</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>random</span><span class=o>.</span><span class=n>shuffle</span><span class=p>([</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>])</span>	<span class=c1>#打乱</span>
</span></span><span class=line><span class=cl><span class=err>```</span><span class=o>---</span>
</span></span><span class=line><span class=cl><span class=n>title</span><span class=p>:</span> <span class=n>flask</span>
</span></span><span class=line><span class=cl><span class=o>---</span>
</span></span><span class=line><span class=cl><span class=c1>## 开始</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>```</span><span class=n>python</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>flask</span> <span class=kn>import</span> <span class=n>Flask</span>
</span></span><span class=line><span class=cl><span class=n>app</span> <span class=o>=</span> <span class=n>Flask</span><span class=p>(</span><span class=vm>__name__</span><span class=p>)</span>	<span class=c1>#实例化Flask类，__name__为程序名</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 注册路由,路由负责管理URL和函数之间的映射, 而这个函数则被称为视图函数 </span>
</span></span><span class=line><span class=cl><span class=nd>@app.route</span><span class=p>(</span><span class=s1>&#39;/&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>index</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s1>&#39;hello&#39;</span>
</span></span></code></pre></div><p>运行服务器：<code>flash run</code></p><h2 id=数据库>数据库<a hidden class=anchor aria-hidden=true href=#数据库>#</a></h2><h3 id=orm>ORM<a hidden class=anchor aria-hidden=true href=#orm>#</a></h3><pre tabindex=0><code>ORM 把数据库映射成对象。
数据库的表（table） 	--&gt; 类（class）
记录（record，行数据）	--&gt; 对象（object）
字段（field）			--&gt; 对象的属性（attribute）
</code></pre><h3 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>flask_sqlalchemy</span> <span class=kn>import</span> <span class=n>SQLAlchemy</span> 
</span></span><span class=line><span class=cl><span class=n>app</span> <span class=o>=</span> <span class=n>Flask</span><span class=p>(</span><span class=vm>__name__</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>db</span> <span class=o>=</span> <span class=n>SQLAlchemy</span><span class=p>(</span><span class=n>app</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=模型类>模型类<a hidden class=anchor aria-hidden=true href=#模型类>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>User</span><span class=p>(</span><span class=n>db</span><span class=o>.</span><span class=n>Model</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nb>id</span> <span class=o>=</span> <span class=n>db</span><span class=o>.</span><span class=n>Column</span><span class=p>(</span><span class=n>db</span><span class=o>.</span><span class=n>Integer</span><span class=p>,</span> <span class=n>primary_key</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>name</span> <span class=o>=</span> <span class=n>db</span><span class=o>.</span><span class=n>Column</span><span class=p>(</span><span class=n>db</span><span class=o>.</span><span class=n>String</span><span class=p>(</span><span class=mi>20</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=n>age</span> <span class=o>=</span> <span class=n>db</span><span class=o>.</span><span class=n>Column</span><span class=p>(</span><span class=n>db</span><span class=o>.</span><span class=n>Integer</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=crud>CRUD<a hidden class=anchor aria-hidden=true href=#crud>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1>############创建############</span>
</span></span><span class=line><span class=cl><span class=n>record</span> <span class=o>=</span> <span class=n>User</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;Jack&#39;</span><span class=p>,</span> <span class=n>age</span><span class=o>=</span><span class=mi>33</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>db</span><span class=o>.</span><span class=n>session</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>record</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>db</span><span class=o>.</span><span class=n>session</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>############查找############</span>
</span></span><span class=line><span class=cl><span class=n>record</span> <span class=o>=</span> <span class=n>User</span><span class=o>.</span><span class=n>query</span><span class=o>.</span><span class=n>filter_by</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s1>&#39;Jack&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>############读取############</span>
</span></span><span class=line><span class=cl><span class=n>age</span> <span class=o>=</span> <span class=n>record</span><span class=o>.</span><span class=n>age</span>
</span></span><span class=line><span class=cl><span class=c1>############更新############</span>
</span></span><span class=line><span class=cl><span class=n>record</span><span class=o>.</span><span class=n>age</span> <span class=o>=</span> <span class=mi>22</span>
</span></span><span class=line><span class=cl><span class=n>db</span><span class=o>.</span><span class=n>session</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>############删除############</span>
</span></span><span class=line><span class=cl><span class=n>db</span><span class=o>.</span><span class=n>session</span><span class=o>.</span><span class=n>delete</span><span class=p>(</span><span class=n>record</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>db</span><span class=o>.</span><span class=n>session</span><span class=o>.</span><span class=n>commit</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=err>```</span><span class=o>---</span>
</span></span><span class=line><span class=cl><span class=n>title</span><span class=p>:</span> <span class=n>核心纲要读书笔记</span>
</span></span><span class=line><span class=cl><span class=o>---</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=n>mo</span> <span class=n>x本文由</span> <span class=p>[</span><span class=n>简悦</span> <span class=n>SimpRead</span><span class=p>](</span><span class=n>http</span><span class=p>:</span><span class=o>//</span><span class=n>ksria</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>simpread</span><span class=o>/</span><span class=p>)</span> <span class=n>转码</span><span class=err>，</span> <span class=n>原文地址</span> <span class=p>[</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/%</span><span class=n>E3</span><span class=o>%</span><span class=mi>80</span><span class=o>%</span><span class=mi>8</span><span class=n>A</span><span class=o>%</span><span class=n>E8</span><span class=o>%</span><span class=n>BD</span><span class=o>%</span><span class=n>AF</span><span class=o>%</span><span class=n>E4</span><span class=o>%</span><span class=n>BB</span><span class=o>%</span><span class=n>B6</span><span class=o>%</span><span class=n>E5</span><span class=o>%</span><span class=n>B7</span><span class=o>%</span><span class=n>A5</span><span class=o>%</span><span class=n>E7</span><span class=o>%</span><span class=n>A8</span><span class=o>%</span><span class=mi>8</span><span class=n>B</span><span class=o>%</span><span class=n>E5</span><span class=o>%</span><span class=n>AF</span><span class=o>%</span><span class=n>BC</span><span class=o>%</span><span class=n>E8</span><span class=o>%</span><span class=n>AE</span><span class=o>%</span><span class=n>BA</span><span class=o>%</span><span class=n>E3</span><span class=o>%</span><span class=mi>80</span><span class=o>%</span><span class=mi>8</span><span class=n>B</span><span class=o>%</span><span class=n>E5</span><span class=o>%</span><span class=n>BC</span><span class=o>%</span><span class=n>A0</span><span class=o>%</span><span class=n>E6</span><span class=o>%</span><span class=n>B5</span><span class=o>%</span><span class=n>B7</span><span class=o>%</span><span class=n>E6</span><span class=o>%</span><span class=n>BD</span><span class=o>%</span><span class=mi>98</span><span class=o>%</span><span class=n>E7</span><span class=o>%</span><span class=mi>89</span><span class=o>%</span><span class=mi>88</span><span class=o>%</span><span class=n>E6</span><span class=o>%</span><span class=n>A0</span><span class=o>%</span><span class=n>B8</span><span class=o>%</span><span class=n>E5</span><span class=o>%</span><span class=n>BF</span><span class=o>%</span><span class=mi>83</span><span class=o>%</span><span class=n>E7</span><span class=o>%</span><span class=n>BA</span><span class=o>%</span><span class=n>B2</span><span class=o>%</span><span class=n>E8</span><span class=o>%</span><span class=n>A6</span><span class=o>%</span><span class=mi>81</span><span class=o>%</span><span class=n>E8</span><span class=o>%</span><span class=n>AF</span><span class=o>%</span><span class=n>BB</span><span class=o>%</span><span class=n>E4</span><span class=o>%</span><span class=n>B9</span><span class=o>%</span><span class=n>A6</span><span class=o>%</span><span class=n>E7</span><span class=o>%</span><span class=n>AC</span><span class=o>%</span><span class=mi>94</span><span class=o>%</span><span class=n>E8</span><span class=o>%</span><span class=n>AE</span><span class=o>%</span><span class=n>B0</span><span class=o>/</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=n>Mo</span><span class=s1>&#39;s Blog at GitHub</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=n>参考</span><span class=err>：</span>  
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=mi>1</span><span class=err>、</span> <span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版</span>  
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=mi>2</span><span class=err>、</span> <span class=p>[</span><span class=n>软件工程</span><span class=err>——</span><span class=n>思维导图</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>blog</span><span class=o>.</span><span class=n>csdn</span><span class=o>.</span><span class=n>net</span><span class=o>/</span><span class=n>a11112244444</span><span class=o>/</span><span class=n>article</span><span class=o>/</span><span class=n>details</span><span class=o>/</span><span class=mi>52461786</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=mi>3</span><span class=err>、</span> <span class=p>[</span><span class=n>软件工程导论张海潘</span> <span class=p>(</span><span class=n>第六版</span><span class=p>)</span> <span class=n>第</span> <span class=mi>1</span><span class=o>-</span><span class=mi>13</span> <span class=n>章总结</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>wenku</span><span class=o>.</span><span class=n>baidu</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>view</span><span class=o>/</span><span class=n>efda689d51e2524de518964bcf84b9d529ea2c5d</span><span class=o>.</span><span class=n>html</span><span class=err>?</span><span class=n>rec_flag</span><span class=o>=</span><span class=n>default</span><span class=o>&amp;</span><span class=n>sxts</span><span class=o>=</span><span class=mi>1549958866931</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=mi>4</span><span class=err>、</span> <span class=p>[</span><span class=n>软件工程的基本概念</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>wenku</span><span class=o>.</span><span class=n>baidu</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>view</span><span class=o>/</span><span class=mi>57</span><span class=n>db6f7331b765ce050814d1</span><span class=o>.</span><span class=n>html</span><span class=err>?</span><span class=n>from</span><span class=o>=</span><span class=n>search</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=mi>5</span><span class=err>、</span> <span class=p>[</span><span class=n>软件工程期末考试重点</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>wenku</span><span class=o>.</span><span class=n>baidu</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>view</span><span class=o>/</span><span class=mi>917</span><span class=n>f8f78cf84b9d528ea7a9f</span><span class=o>.</span><span class=n>html</span><span class=err>?</span><span class=n>rec_flag</span><span class=o>=</span><span class=n>default</span><span class=o>&amp;</span><span class=n>sxts</span><span class=o>=</span><span class=mi>1549958765459</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=mi>6</span><span class=err>、</span> <span class=p>[</span><span class=n>软件工程考试重点内容</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>wenku</span><span class=o>.</span><span class=n>baidu</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>view</span><span class=o>/</span><span class=n>d7de31cf763231126edb11d2</span><span class=o>.</span><span class=n>html</span><span class=err>?</span><span class=n>from</span><span class=o>=</span><span class=n>search</span><span class=p>)</span>  
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=mi>7</span><span class=err>、</span> <span class=p>[</span><span class=n>软件工程期末考试复习题及答案</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>wenku</span><span class=o>.</span><span class=n>baidu</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>view</span><span class=o>/</span><span class=n>edd9e61e10a6f524ccbf853f</span><span class=o>.</span><span class=n>html</span><span class=err>?</span><span class=n>from</span><span class=o>=</span><span class=n>search</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#软件工程 &#34;软件工程&#34;)软件工程</span>
</span></span><span class=line><span class=cl><span class=o>====================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=n>来源见水印</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图0</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#1-工具 &#34;1 工具&#34;)1 工具</span>
</span></span><span class=line><span class=cl><span class=o>--------------------</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=n>参考博文</span> <span class=err>《</span><span class=n>DevOps</span> <span class=n>与</span> <span class=n>CI</span><span class=o>/</span><span class=n>CD</span> <span class=n>的概念</span><span class=err>》。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=n>项目管理</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>任务跟踪</span><span class=err>：</span><span class=n>禅道</span><span class=err>、</span><span class=n>Trello</span><span class=err>、</span><span class=n>Teambition</span> <span class=n>等</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>项目计划</span><span class=err>：</span><span class=n>禅道</span><span class=err>、</span><span class=n>Trello</span><span class=err>、</span><span class=n>Teambition</span> <span class=n>等</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>团队沟通</span><span class=err>：</span><span class=n>Slack</span><span class=err>、</span><span class=n>Teambition</span> <span class=n>等</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=n>需求分析</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>需求跟踪</span><span class=err>：</span><span class=n>禅道</span><span class=err>、</span><span class=n>Teambition</span><span class=err>、</span><span class=n>Trello</span> <span class=n>等</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>原型制作</span><span class=err>：</span><span class=n>Adobe</span> <span class=n>XD</span> <span class=n>CC</span><span class=err>、</span><span class=n>Axure</span><span class=err>、</span><span class=n>Sketch</span> <span class=n>等</span><span class=err>，</span><span class=p>[</span><span class=n>参考</span><span class=err>：</span><span class=mi>16</span> <span class=n>种原型制作工具及使用介绍</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>www</span><span class=o>.</span><span class=n>jianshu</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>p</span><span class=o>/</span><span class=mi>4</span><span class=n>ead159e23df</span><span class=p>)</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>3.</span>  <span class=n>设计</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>UML</span> <span class=n>建模</span><span class=err>：</span><span class=n>Violet</span> <span class=n>UM</span><span class=err>、</span><span class=n>ProcessOn</span><span class=err>、</span><span class=n>StarUML</span><span class=err>、</span><span class=n>Visio</span> <span class=n>等</span><span class=err>。（</span><span class=n>类图</span><span class=err>、</span><span class=n>对象图</span><span class=err>；</span><span class=n>用例图</span><span class=err>、</span><span class=n>状态图</span><span class=err>、</span><span class=n>活动图</span><span class=err>、</span><span class=n>序列图</span><span class=err>。</span><span class=p>[</span><span class=n>参考</span><span class=err>：</span><span class=n>UML</span> <span class=n>各种图总结精华</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>zhuanlan</span><span class=o>.</span><span class=n>zhihu</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>p</span><span class=o>/</span><span class=mi>44518805</span><span class=p>)</span><span class=err>、</span><span class=p>[</span><span class=n>各种图含义作用</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>www</span><span class=o>.</span><span class=n>cnblogs</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>bluestorm</span><span class=o>/</span><span class=n>archive</span><span class=o>/</span><span class=mi>2012</span><span class=o>/</span><span class=mi>05</span><span class=o>/</span><span class=mi>03</span><span class=o>/</span><span class=mf>2480556.</span><span class=n>html</span><span class=p>)</span> <span class=err>）</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>图表制作</span><span class=err>：</span><span class=n>Excel</span><span class=err>、</span><span class=n>亿图等</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>4.</span>  <span class=n>开发</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>源代码管理</span><span class=err>：</span><span class=n>GitHub</span><span class=err>、</span><span class=n>GitLab</span><span class=err>、</span><span class=n>SubVersion</span> <span class=n>等</span><span class=err>（</span><span class=n>Git</span><span class=err>、</span><span class=n>SVN</span><span class=err>）。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>持续集成</span><span class=err>：</span><span class=n>Jenkins</span><span class=err>、</span><span class=n>CireleCI</span><span class=err>、</span><span class=n>AppCenter</span><span class=err>、</span><span class=n>Travis</span> <span class=n>CI</span><span class=err>、</span><span class=n>flow</span><span class=o>.</span><span class=n>ci</span> <span class=n>等</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>5.</span>  <span class=n>测试</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>Bug</span> <span class=n>跟踪</span><span class=err>：</span><span class=n>禅道</span><span class=err>、</span><span class=n>Teambition</span><span class=err>、</span><span class=n>Trello</span><span class=err>、</span><span class=n>The</span> <span class=n>Bug</span> <span class=n>Genie</span> <span class=n>等</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>测试管理平台</span><span class=err>：</span><span class=n>TestLink</span><span class=err>、</span><span class=n>Redmine</span><span class=err>、</span><span class=n>禅道</span><span class=err>、</span><span class=n>TestCenter</span> <span class=n>等</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>自动化测试</span><span class=err>：</span><span class=n>常用的</span><span class=err>：</span><span class=n>QPT</span><span class=err>、</span><span class=n>LR</span><span class=err>。</span><span class=o>/</span> <span class=n>开源功能自动化测试工具</span><span class=err>：</span><span class=n>Watir</span><span class=err>、</span><span class=n>Selenium</span><span class=err>、</span><span class=n>MaxQ</span><span class=err>、</span><span class=n>WebInject</span><span class=err>。</span><span class=o>/</span> <span class=n>开源性能自动化测试工具</span><span class=err>：</span><span class=n>Jmeter</span><span class=err>、</span><span class=n>OpenSTA</span><span class=err>、</span><span class=n>DBMonster</span><span class=err>、</span><span class=n>TPTEST</span><span class=err>、</span><span class=n>Web</span> <span class=n>Application</span> <span class=n>Load</span> <span class=n>Simulator</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>补充</span><span class=err>，</span><span class=n>自动化构建和测试</span><span class=p>:</span> <span class=n>Apache</span> <span class=n>Ant</span><span class=err>、</span><span class=n>Maven</span> <span class=err>、</span><span class=n>Selenium</span><span class=err>、</span><span class=n>PyUnit</span><span class=err>、</span><span class=n>QUnit</span><span class=err>、</span><span class=n>JMeter</span><span class=err>、</span><span class=n>Gradle</span><span class=err>、</span><span class=n>PHPUnit</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>6.</span>  <span class=n>运行维护</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>自动化部署</span><span class=err>：</span><span class=n>Jenkins</span><span class=err>、</span><span class=n>ElectricFlow</span><span class=err>、</span><span class=n>DeployBot</span><span class=err>、</span><span class=n>CireleCI</span><span class=err>、</span><span class=n>AppCenter</span><span class=err>、</span><span class=n>Travis</span> <span class=n>CI</span> <span class=n>等</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>日志分析</span><span class=err>：</span><span class=n>Logstash</span><span class=err>、</span><span class=n>CollectD</span><span class=err>、</span><span class=n>StatsD</span> <span class=n>等</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>线上监控</span><span class=err>：</span><span class=n>Nagios</span><span class=err>、</span><span class=n>Ganglia</span><span class=err>、</span><span class=n>Sensu</span><span class=err>、</span><span class=n>zabbix</span><span class=err>、</span><span class=n>ICINGA</span><span class=err>、</span><span class=n>Graphite</span><span class=err>、</span><span class=n>Kibana</span> <span class=n>等</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#2-软件工程文档 &#34;2 软件工程文档&#34;)2 软件工程文档</span>
</span></span><span class=line><span class=cl><span class=o>--------------------------------</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=n>需要文档的几个方面</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>立项文档</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>需求分析文档</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>概要设计和架构设计</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>详细设计</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>源代码</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>配置文档</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>单元测试文档</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>集成测试文档</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>验收文档</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>维护文档</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>用户操作手册</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>项目管理文档</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=n>具体文档</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>项目管理文档</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>《</span><span class=n>软件项目计划</span><span class=err>》、《</span><span class=n>项目进度报告</span><span class=err>》、《</span><span class=n>项目开发总结报告</span><span class=err>》</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>管理控制文档</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>《</span><span class=n>配置文档</span><span class=err>》、《</span><span class=n>维护文档</span><span class=err>》</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>软件开发文档</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>《</span><span class=n>需求规格说明</span><span class=err>》、《</span><span class=n>概要设计说明</span><span class=err>》、《</span><span class=n>详细设计说明</span><span class=err>》、《</span><span class=n>软件源码文档</span><span class=err>》、《</span><span class=n>测试计划</span><span class=err>》、《</span><span class=n>软件测试分析报告</span><span class=err>》</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>产品文档</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>《</span><span class=n>用户操作手册</span><span class=err>》、《</span><span class=n>演示文件</span><span class=err>》</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#一-软件工程学概述 &#34;一 软件工程学概述&#34;)一 软件工程学概述</span>
</span></span><span class=line><span class=cl><span class=o>===================================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=n>软件工程方法学</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>软件工程包括</span><span class=err>：</span><span class=n>技术</span><span class=err>、</span><span class=n>管理</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>软件工程方法学三要素</span><span class=err>：</span><span class=n>过程</span><span class=err>（</span><span class=n>步骤</span><span class=err>）、</span><span class=n>方法</span><span class=err>（</span><span class=n>如何做</span><span class=err>）、</span><span class=n>工具</span><span class=err>（</span><span class=n>支持环境</span><span class=err>）。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>传统方法学</span><span class=err>：</span><span class=n>强调自顶向下</span><span class=err>。</span><span class=n>面向对象方法学</span><span class=err>：</span><span class=n>强调主动多次反复迭代</span><span class=err>。（</span><span class=n>四个要点</span><span class=err>：</span><span class=n>对象</span><span class=err>、</span><span class=n>类</span><span class=err>、</span><span class=n>继承</span><span class=err>、</span><span class=n>消息</span><span class=err>。）</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=n>软件周期</span><span class=err>（</span><span class=n>三个时期</span><span class=err>，</span><span class=n>八个阶段</span><span class=err>）：</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图1</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>3.</span>  <span class=n>软件过程</span><span class=err>：</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>瀑布模型</span><span class=err>：</span><span class=n>规范</span><span class=err>、</span><span class=n>文档驱动</span><span class=err>；</span><span class=n>最终产品可能不是用户真正需求</span><span class=err>；</span><span class=n>难以按模型进行</span><span class=err>，</span><span class=n>开发过程逆转代价大</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>快速原型模型</span><span class=err>：</span><span class=n>快速构建可在计算机上运行的原型系统</span><span class=err>，</span><span class=n>让用户反馈</span><span class=err>，</span><span class=n>开发周期短</span><span class=err>；</span><span class=n>客户与开发者对原型的理解不同</span><span class=err>，</span><span class=n>准确的设计原型困难</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>螺旋模型</span><span class=err>：</span><span class=n>可看作增加了风险分析过程的快速原型模型</span><span class=err>；</span><span class=n>风险驱动</span><span class=err>，</span><span class=n>适用内部大型项目的开发</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>增量模型</span><span class=err>：</span><span class=n>短期提交可完成部分</span><span class=err>，</span><span class=n>逐步增加功能</span><span class=err>；</span><span class=n>软件需具备开放性会导致失去整体结构</span><span class=err>，</span><span class=n>也可能有无法集成的问题</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>喷泉模型</span><span class=err>：</span><span class=n>体现了面向对象软件开发过程无缝迭代特性</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>补充</span><span class=err>，</span><span class=n>敏捷开发</span><span class=err>：</span><span class=n>是一套价值观和原则</span><span class=err>，</span><span class=n>大项目由各个可独立运行的小项目组成</span><span class=err>，</span><span class=n>此期间软件一直处于可使用状态</span><span class=err>。</span><span class=n>迭代式开发与增量交付</span><span class=err>。</span><span class=p>[</span><span class=n>敏捷开发视频课程</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>www</span><span class=o>.</span><span class=n>bilibili</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>video</span><span class=o>/</span><span class=n>av16212736</span><span class=p>)</span><span class=err>，</span><span class=p>[</span><span class=n>敏捷开发之</span> <span class=n>Scrum</span> <span class=n>视频课程</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>www</span><span class=o>.</span><span class=n>bilibili</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>video</span><span class=o>/</span><span class=n>av21945150</span><span class=p>)</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>敏捷开发之</span> <span class=n>Scrum</span><span class=err>：</span><span class=n>计划</span><span class=err>、</span><span class=n>构建</span><span class=err>、</span><span class=n>测试</span><span class=err>、</span><span class=n>回顾</span><span class=err>。</span><span class=n>不断重复这四步来做增量式发布</span><span class=err>，</span><span class=n>最后形成一个可发布的版本</span><span class=err>。</span><span class=o>/</span> <span class=n>三个角色</span><span class=err>：</span><span class=n>产品经理</span><span class=err>、</span><span class=n>Scrum</span> <span class=n>负责人</span><span class=err>、</span><span class=n>Scrum</span> <span class=n>团队</span><span class=err>（</span><span class=n>开发</span><span class=err>、</span><span class=n>测试</span><span class=err>、</span><span class=n>文案等人员</span><span class=err>）。</span><span class=o>/</span> <span class=n>产品经理需求</span><span class=err>、</span><span class=n>用户视角需求</span><span class=err>。</span><span class=o>/</span> <span class=n>三个会议</span><span class=err>：</span><span class=n>计划会议</span><span class=err>（</span><span class=n>产品经理与负责人</span><span class=err>）、</span><span class=n>每日例会</span><span class=err>（</span><span class=n>团队工作进度</span><span class=err>）、</span><span class=n>回顾会议</span><span class=err>（</span><span class=n>展示和改进</span><span class=err>）。</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图1</span><span class=o>-</span><span class=mf>0.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>敏捷开发之极限编程</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>一种近螺旋式的开发方法</span><span class=err>，</span><span class=n>它将复杂的开发过程分解为一个个相对比较简单的小周期</span><span class=err>；</span><span class=n>通过积极的交流</span><span class=err>、</span><span class=n>反馈以及其它一系列的方法</span><span class=err>，</span><span class=n>开发人员和客户可以非常清楚开发进度</span><span class=err>、</span><span class=n>变化</span><span class=err>、</span><span class=n>待解决的问题和潜在的困难等</span><span class=err>，</span><span class=n>并根据实际情况及时地调整开发过程</span><span class=err>。</span><span class=o>/</span>  
</span></span><span class=line><span class=cl>    <span class=n>计划在极限编程中被视为临时工件</span><span class=err>；</span><span class=n>高质量的代码在极限编程项目中是必不可少的</span><span class=err>；</span><span class=n>良好的单元测试和验收测试是极限编程项目的标志</span><span class=err>。</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图1</span><span class=o>-</span><span class=mi>0</span><span class=o>-</span><span class=mf>1.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>小结</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图1</span><span class=o>-</span><span class=mf>1.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>4.</span>  <span class=n>各阶段具体任务</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图1</span><span class=o>-</span><span class=mf>2.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#二-可行性研究 &#34;二 可行性研究&#34;)二 可行性研究</span>
</span></span><span class=line><span class=cl><span class=o>=============================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=n>目的</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>确定问题是否值得去解决</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=n>实质</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>在较高层次去用抽象的方法进行系统分析</span><span class=err>、</span><span class=n>设计的过程</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>3.</span>  <span class=n>内容</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>进一步分析定义问题</span><span class=err>，</span><span class=n>导出逻辑模型</span><span class=err>，</span><span class=n>探索若干种可供选择的解决方法</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>4.</span>  <span class=n>从几个方面研究可行性</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>技术</span><span class=err>、</span><span class=n>经济</span><span class=err>、</span><span class=n>操作可行性</span><span class=err>、</span><span class=n>运行可行性</span><span class=err>、</span><span class=n>法律等</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>5.</span>  <span class=n>可行性研究的步骤</span><span class=err>：</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>具体步骤</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>复查系统规模和目标</span> <span class=o>-&gt;</span> <span class=n>研究目前正在使用的系统</span> <span class=o>-&gt;</span> <span class=n>导出新系统的高层逻辑模型</span> <span class=o>-&gt;</span> <span class=n>进一步定义问题</span> <span class=o>-&gt;</span> <span class=n>导出和评价供选择的解法</span> <span class=o>-&gt;</span> <span class=n>推荐行动方针</span> <span class=o>-&gt;</span> <span class=n>草拟开发计划</span> <span class=o>-&gt;</span> <span class=n>书写文档提交审查</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>小结</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>对问题正确定义的基础上</span><span class=err>，</span><span class=n>分析问题</span><span class=err>，</span><span class=n>导出试探性的解</span><span class=err>，（</span><span class=n>复查修正定义</span><span class=err>，</span><span class=n>再次分析问题</span><span class=err>，</span><span class=n>改进解</span><span class=err>）</span><span class=n>最终提出逻辑模型</span><span class=err>，</span><span class=n>根据逻辑模型设想可能的系统模型</span><span class=err>，</span><span class=n>并从多角度研究可行性</span><span class=err>，</span><span class=n>提交用户客户组织负责人审查批准</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>6.</span>  <span class=n>系统流程图</span><span class=err>（</span><span class=n>物理</span><span class=err>）：</span>  
</span></span><span class=line><span class=cl>    <span class=n>概括描述物理系统的传统工具</span><span class=err>。</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图1</span><span class=o>-</span><span class=mf>3.</span><span class=n>PNG</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图1</span><span class=o>-</span><span class=mf>4.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>7.</span>  <span class=n>数据流图</span><span class=err>（</span><span class=n>逻辑</span><span class=err>）：</span>  
</span></span><span class=line><span class=cl>    <span class=n>只描述数据在软件中流动和被处理的逻辑过程</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>8.</span>  <span class=n>数据字典</span><span class=err>（</span><span class=n>逻辑</span><span class=err>）：</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>概念</span><span class=err>：</span><span class=n>关于数据的信息集合</span><span class=err>（</span><span class=n>作为分析阶段工具</span><span class=err>，</span><span class=n>开发数据库的第一步</span><span class=err>）。</span><span class=n>数据字典和数据流图共同构成逻辑模型</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>数据字典的实现</span><span class=err>，</span><span class=n>例</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图2</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>符号</span><span class=err>：`</span><span class=o>=</span> <span class=n>定义为</span><span class=err>`，`</span><span class=o>+</span> <span class=n>连接两个分量</span><span class=err>`，`</span><span class=p>[</span> <span class=p>]</span> <span class=n>其中有若干个</span><span class=err>，</span><span class=n>分量用</span> <span class=o>|</span> <span class=n>表示</span><span class=err>`，`</span><span class=p>{</span> <span class=p>}</span> <span class=n>重复</span><span class=err>，</span><span class=n>左边写下限</span><span class=err>，</span><span class=n>右边写上限</span><span class=err>`，`</span><span class=p>(</span> <span class=p>)</span> <span class=n>可选</span><span class=err>，</span><span class=n>其中的分量可有可无</span><span class=err>`。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>举例</span><span class=err>：`</span><span class=n>标识符</span> <span class=o>=</span> <span class=n>字母字符</span> <span class=o>+</span> <span class=n>字母数字串</span><span class=err>`，`</span><span class=n>字母数字串</span> <span class=o>=</span> <span class=mi>0</span><span class=p>{</span><span class=n>字母或数字</span><span class=p>}</span><span class=mi>7</span><span class=err>`，`</span><span class=n>字母或数字</span> <span class=o>=</span> <span class=p>[</span><span class=n>字母字符</span> <span class=o>|</span> <span class=n>数字字符</span><span class=p>]</span><span class=err>`。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>9.</span>  <span class=n>成本效益分析</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>货币时间价值</span><span class=err>：</span><span class=n>P</span> <span class=n>为现在价值</span><span class=err>、</span><span class=n>F</span> <span class=n>为未来价值</span><span class=err>、</span><span class=n>i</span> <span class=n>为年利率</span><span class=err>、</span><span class=n>n</span> <span class=n>为年数</span><span class=err>，</span><span class=n>F</span><span class=o>=</span><span class=n>P</span><span class=p>(</span><span class=mi>1</span><span class=o>+</span><span class=n>i</span><span class=p>)</span><span class=o>^</span><span class=n>n</span><span class=err>，</span><span class=n>同理</span> <span class=n>P</span><span class=o>=</span><span class=n>F</span><span class=o>/</span><span class=p>((</span><span class=mi>1</span><span class=o>+</span><span class=n>i</span><span class=p>)</span><span class=o>^</span><span class=n>n</span><span class=p>)</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>投资回报率</span><span class=err>：</span><span class=n>P</span> <span class=n>为现在投资额</span><span class=err>、</span><span class=n>Fi</span> <span class=n>为第</span> <span class=n>i</span> <span class=n>年底的效益</span><span class=err>（</span><span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=err>、</span><span class=mi>2</span><span class=err>、…）、</span><span class=n>n</span> <span class=n>为系统使用寿命</span><span class=err>、</span><span class=n>j</span> <span class=n>为投资回报率</span><span class=err>。</span><span class=n>P</span><span class=o>=</span><span class=n>Fi</span><span class=o>/</span><span class=p>((</span><span class=mi>1</span><span class=o>+</span><span class=n>j</span><span class=p>)</span><span class=o>^</span><span class=n>n</span><span class=p>)</span> <span class=err>，</span><span class=n>i</span> <span class=n>从</span> <span class=mi>1</span> <span class=n>到</span> <span class=n>n</span><span class=err>，</span><span class=n>累加</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#补充 &#34;补充&#34;)补充</span>
</span></span><span class=line><span class=cl><span class=o>--------------</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=n>项目计划</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>它是软件开发工作的第一步</span><span class=err>。</span> <span class=n>项目计划的目标是为项目负责人提供一个框架</span><span class=err>，</span><span class=n>使之能合理地估算软件项目开发所需的资源</span> <span class=err>、</span><span class=n>经费和开发进度</span><span class=err>，</span><span class=n>并控制软件项目开发过程按此计划进行</span><span class=err>。</span> <span class=n>在做计划时</span><span class=err>，</span><span class=n>必须就需要的人力</span><span class=err>、</span><span class=n>项目持续时间及成本作出估算</span><span class=err>。</span><span class=n>这种估算大多是参考</span> <span class=n>以前的花费作出的</span><span class=err>。</span><span class=n>软件项目计划包括二个任务</span><span class=err>：</span><span class=n>研究和估算</span><span class=err>。</span><span class=n>即通过研究确定该软件</span> <span class=n>项目的主要功能</span><span class=err>、</span><span class=n>性能和系统界面</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>范围</span><span class=err>：</span><span class=n>项目目标</span><span class=err>、</span><span class=n>主要功能</span><span class=err>、</span><span class=n>性能限制</span><span class=err>、</span><span class=n>系统接口</span><span class=err>、</span><span class=n>特殊要求</span><span class=err>、</span><span class=n>开发概述</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>资源</span><span class=err>：</span><span class=n>人员资源</span><span class=err>、</span><span class=n>硬件资源</span><span class=err>、</span><span class=n>软件资源</span><span class=err>、</span><span class=n>其他</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>进度安排</span><span class=err>：</span><span class=n>工程网络图</span><span class=err>、</span><span class=n>Gantt</span> <span class=n>图</span><span class=err>、</span><span class=n>任务资源表</span><span class=err>、</span><span class=n>成本估算</span><span class=err>、</span><span class=n>培训计划</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=n>流程规范</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>软件工程方法</span><span class=err>（</span><span class=n>怎样做</span><span class=err>）。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>3.</span>  <span class=n>风险管理</span><span class=err>：</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>风险识别</span><span class=err>：</span><span class=n>头脑风暴法</span><span class=err>、</span><span class=n>面谈</span><span class=err>、</span><span class=n>Delphi</span> <span class=n>法</span><span class=err>、</span><span class=n>核对表</span><span class=err>、</span><span class=n>SWOT</span> <span class=n>技术</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>风险量化</span><span class=err>：</span><span class=n>风险因子计算</span><span class=err>、</span><span class=n>PERT</span> <span class=n>估计</span><span class=err>、</span><span class=n>决策树分析</span><span class=err>、</span><span class=n>风险模拟</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>风险应对计划制定</span><span class=err>：</span><span class=n>回避</span><span class=err>、</span><span class=n>转移</span><span class=err>、</span><span class=n>缓和</span><span class=err>、</span><span class=n>接受</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>风险监控</span><span class=err>：</span><span class=n>核对表</span><span class=err>、</span><span class=n>定期项目评估</span><span class=err>、</span><span class=n>挣值分析</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>4.</span>  <span class=n>配置管理</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>软件配置管理</span><span class=err>，</span><span class=n>贯穿于整个软件生命周期</span><span class=err>，</span><span class=n>它为软件研发提供了一套管理办法和活动原则</span><span class=err>。</span><span class=n>软件配置管理无论是对于软件企业管理人员还是研发人员都有着重要的意义</span><span class=err>。</span><span class=o>/</span> <span class=n>关键活动包括</span><span class=err>：</span><span class=n>配置项</span><span class=err>、</span><span class=n>工作空间管理</span><span class=err>、</span><span class=n>版本控制</span><span class=err>、</span><span class=n>变更控制</span><span class=err>、</span><span class=n>状态报告</span><span class=err>、</span><span class=n>配置审计等</span><span class=err>。</span><span class=o>/</span> <span class=n>软件配置管理可以提炼为三个方面的内容</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>VersionControl</span> <span class=n>版本控制</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>ChangeControl</span> <span class=n>变更控制</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>ProcessSupport</span> <span class=n>过程支持</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>5.</span>  <span class=n>配置管理的目的</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>配置识别</span><span class=err>：</span><span class=n>识别配置</span><span class=err>、</span><span class=n>配置项目和基准</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>配置控管</span><span class=err>：</span><span class=n>导入变更控管流程</span><span class=err>。</span><span class=n>该流程通常由变更控制委员会来运行</span><span class=err>，</span><span class=n>其主要的职责是核准或拒绝有悖任何基准的所有变更请求</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>配置状态报告</span><span class=err>：</span><span class=n>记录和呈报与开发过程状态相关的所有必要信息</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>配置审核</span><span class=err>：</span><span class=n>确保这些配置包含所有预期内容</span><span class=err>，</span><span class=n>且备有完整的规定文件</span><span class=err>（</span><span class=n>包括要求</span><span class=err>、</span><span class=n>结构规范和用户手册</span><span class=err>）。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>建构管理</span><span class=err>：</span><span class=n>管理用于建构的流程和工具</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>流程管理</span><span class=err>：</span><span class=n>确保遵循企业组织的开发流程</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>环境管理</span><span class=err>：</span><span class=n>管理承载系统的软硬件</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>团队合作</span><span class=err>：</span><span class=n>促进流程中团队彼此间的交互</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>缺陷追踪</span><span class=err>：</span><span class=n>确保可溯及每个缺陷的源头</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#三-需求分析 &#34;三 需求分析&#34;)三 需求分析</span>
</span></span><span class=line><span class=cl><span class=o>==========================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=n>概念</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>定义</span><span class=err>：</span><span class=n>确定系统必须完成哪些工作</span><span class=err>。</span><span class=n>写出软件需求规格说明书</span><span class=err>，</span><span class=n>以书面形式准确描述软件需求</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>需求内容</span><span class=err>：</span><span class=n>功能需求</span><span class=err>、</span><span class=n>性能需求</span><span class=err>、</span><span class=n>可靠性需求</span><span class=err>、</span><span class=n>出错需求</span><span class=err>、</span><span class=n>接口需求</span><span class=err>、</span><span class=n>逆向需求</span><span class=err>、</span><span class=n>将来可能提出的需求</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=n>系统分析的数据要求</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>建立数据模型</span><span class=err>（</span><span class=n>E</span><span class=o>-</span><span class=n>R</span> <span class=n>图</span><span class=err>）</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>描绘数据结构</span><span class=err>（</span><span class=n>层次方框图</span><span class=err>、</span><span class=n>Warnier</span> <span class=n>图</span><span class=err>）</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>数据结构规范化</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>3.</span>  <span class=n>需求分析中的三种模型</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>数据模型</span><span class=err>（</span><span class=n>E</span><span class=o>-</span><span class=n>R</span> <span class=n>图</span><span class=err>）。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>功能模型</span><span class=err>（</span><span class=n>数据流图</span><span class=err>）。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>行为模型</span><span class=err>（</span><span class=n>状态转换图</span><span class=err>）。</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图2</span><span class=o>-</span><span class=mf>1.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>4.</span>  <span class=n>三种模型对应的三种图</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>E</span><span class=o>-</span><span class=n>R</span> <span class=n>图</span><span class=err>：</span><span class=n>由数据对象</span><span class=err>（</span><span class=n>矩形</span><span class=err>）、</span><span class=n>属性</span><span class=err>（</span><span class=n>圆角矩形</span><span class=err>）、</span><span class=n>关系</span><span class=err>（</span><span class=n>菱形</span><span class=err>）</span><span class=n>组成</span><span class=err>。</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图3</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>数据流图</span><span class=err>：</span><span class=n>由起点</span> <span class=o>/</span> <span class=n>终点</span><span class=err>（</span><span class=n>矩形</span><span class=err>）、</span><span class=n>数据处理</span><span class=err>（</span><span class=n>标号圆角矩形</span><span class=err>）、</span><span class=n>数据存储</span><span class=err>（</span><span class=n>标号不封闭矩形</span><span class=err>）、</span><span class=n>数据流</span><span class=err>（</span><span class=n>箭头</span><span class=err>）</span><span class=n>组成</span><span class=err>。</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图4</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>状态转换图</span><span class=err>：</span><span class=n>由状态</span><span class=err>、</span><span class=n>事件组成</span><span class=err>。</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图5</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>5.</span>  <span class=n>补充</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>结构化分析方法</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>传统软件方法学使用结构化分析技术</span><span class=err>。</span><span class=n>实质上是一种建模活动</span><span class=err>，</span><span class=n>在需求分析阶段通常建立数据模型</span><span class=err>（</span><span class=n>E</span><span class=o>-</span><span class=n>R</span> <span class=n>图</span><span class=err>）、</span><span class=n>功能模型</span><span class=err>（</span><span class=n>数据流图</span><span class=err>）、</span><span class=n>行为模型</span><span class=err>（</span><span class=n>状态转换图</span><span class=err>）。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>书写需求分析文档</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>通常从需求的一致性</span><span class=err>、</span><span class=n>完整性</span><span class=err>、</span><span class=n>现实性</span><span class=err>、</span><span class=n>有效性</span> <span class=mi>4</span> <span class=n>个方面复审软件需求规格说明书</span><span class=err>。</span><span class=n>通过严格评审和用户确认后</span><span class=err>，</span><span class=n>作为此阶段的最终成果</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>需求分析与可行性研究间的关系</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>软件需求分析就是把软件计划期间建立的软件可行性分析求精和细化</span><span class=err>，</span><span class=n>分析各种可能的解法</span><span class=err>，</span><span class=n>并且分配给各个软件元素</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>数据字典的作用</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>数据字典描述在数据模型</span><span class=err>、</span><span class=n>功能模型</span><span class=err>、</span><span class=n>行为模型中出现的数据对象</span><span class=err>、</span><span class=n>控制信息的特性</span><span class=err>，</span><span class=n>给出它们的准确定义</span><span class=err>。</span><span class=n>数据字典成为把</span> <span class=mi>3</span> <span class=n>种分析模型粘合在一起的</span> <span class=err>“</span><span class=n>粘合剂</span><span class=err>”。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#补充-1 &#34;补充&#34;)补充</span>
</span></span><span class=line><span class=cl><span class=o>----------------</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=n>需求分析</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>见上</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=n>变更管理</span><span class=err>：</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>&gt;</span> <span class=n>参考</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=o>&gt;</span> <span class=mi>1</span><span class=err>、</span> <span class=p>[</span><span class=n>百度经验</span><span class=err>：</span><span class=n>如何理解变更管理</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>jingyan</span><span class=o>.</span><span class=n>baidu</span><span class=o>.</span><span class=n>com</span><span class=o>/</span><span class=n>article</span><span class=o>/</span><span class=n>fd8044fa1c6a015031137ae2</span><span class=o>.</span><span class=n>html</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>需要确保变更在可控的方式下被记录</span><span class=err>、</span><span class=n>评估</span><span class=err>、</span><span class=n>授权</span><span class=err>、</span><span class=n>确定优先级</span><span class=err>、</span><span class=n>计划</span><span class=err>、</span><span class=n>测试</span><span class=err>、</span><span class=n>实施</span><span class=err>、</span><span class=n>备案以及回顾</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#四-形式化说明技术（略） &#34;四 形式化说明技术（略）&#34;)四 形式化说明技术（略）</span>
</span></span><span class=line><span class=cl><span class=o>============================================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图5</span><span class=o>-</span><span class=mf>0.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#五-总体设计（系统设计） &#34;五 总体设计（系统设计）&#34;)五 总体设计（系统设计）</span>
</span></span><span class=line><span class=cl><span class=o>============================================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=n>设计原理</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>模块化</span><span class=err>、</span><span class=n>模块独立</span><span class=err>、</span><span class=n>抽象</span><span class=err>、</span><span class=n>逐步求精</span><span class=err>、</span><span class=n>信息隐藏</span><span class=err>、</span><span class=n>局部化</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=n>设计任务与过程</span><span class=err>：</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>总体设计任务</span><span class=err>：</span><span class=n>用抽象概括的方式确定系统如何完成预定的任务</span><span class=err>，</span><span class=n>并确定组成系统的每个程序的结构</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>总体设计过程</span><span class=err>：</span><span class=n>系统设计</span><span class=err>（</span><span class=n>全局</span><span class=err>。</span><span class=n>数据流图触发确定系统的具体实现物理方案</span><span class=err>）；</span><span class=n>结构设计</span><span class=err>（</span><span class=n>局部</span><span class=err>。</span><span class=n>确定软件结构</span><span class=err>。</span><span class=n>软件由哪些模块组成</span><span class=err>，</span><span class=n>及其动态调用过程</span><span class=err>。</span><span class=o>/</span> <span class=n>功能分解</span><span class=err>、</span><span class=n>设计软件结构</span><span class=err>、</span><span class=n>设计数据库</span><span class=err>、</span><span class=n>制定测试文档</span><span class=err>）。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>3.</span>  <span class=n>模块化</span><span class=err>、</span><span class=n>模块独立概念</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>模块化</span><span class=err>：</span><span class=n>把程序划分为独立命名且可独立访问的模块</span><span class=err>，</span><span class=n>每个模块完成一个子功能</span><span class=err>，</span><span class=n>把这些模块集成起来构成一个整体</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>模块独立</span><span class=err>：</span><span class=n>是抽象</span><span class=err>、</span><span class=n>模块化</span><span class=err>（</span><span class=n>低耦合</span><span class=err>）、</span><span class=n>信息隐藏</span><span class=err>、</span><span class=n>局部化</span><span class=err>（</span><span class=n>高内聚</span><span class=err>）</span><span class=n>概念的直接结果</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>4.</span>  <span class=n>模块独立程度的定性度量标准</span><span class=err>（</span><span class=n>低耦合与高内聚</span><span class=err>）：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>概念</span><span class=err>：</span><span class=n>耦合</span><span class=err>：</span><span class=n>模块间互连程度</span><span class=err>。</span><span class=o>/</span> <span class=n>内聚</span><span class=err>：</span><span class=n>一个模块内各个元素彼此结合的紧密程度</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>六种耦合</span><span class=err>：</span><span class=n>无直接耦合</span><span class=err>、</span><span class=n>数据耦合</span><span class=err>、</span><span class=n>标记耦合</span><span class=err>、</span><span class=n>控制耦合</span><span class=err>、</span><span class=n>公共环境耦合</span><span class=err>、</span><span class=n>内容耦合</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>六种内聚</span><span class=err>：</span><span class=n>功能内聚</span><span class=err>、</span><span class=n>顺序内聚</span><span class=err>，</span><span class=n>通信内聚</span><span class=err>、</span><span class=n>过程内聚</span><span class=err>，</span><span class=n>时间内聚</span><span class=err>、</span><span class=n>逻辑内聚</span><span class=err>、</span><span class=n>偶然内聚</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>5.</span>  <span class=n>描述软件结构的图形工具</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图5</span><span class=o>-</span><span class=mf>1.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>层次方框图</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>层次方框图用树形结构的一系列多层次的矩形框描绘数据的层次结构</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>)</span> <span class=n>层次图</span><span class=err>、</span><span class=n>HIPO</span> <span class=n>图</span><span class=err>：（</span><span class=n>层次图无</span> <span class=n>HIPO</span> <span class=n>图中的标号</span><span class=err>）。</span>  
</span></span><span class=line><span class=cl><span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图6</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>b</span><span class=p>)</span> <span class=n>结构图</span><span class=err>：</span>  
</span></span><span class=line><span class=cl><span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图7</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>Warnier</span> <span class=n>图</span><span class=p>:</span>  
</span></span><span class=line><span class=cl>    <span class=n>和层次方框图类似</span><span class=err>，</span><span class=n>Warnier</span> <span class=n>图也用树形结构描绘信息</span><span class=err>，</span><span class=n>但是这种图形工具比层次方框图提供了更丰富的描绘手段</span><span class=err>。</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图7</span><span class=o>-</span><span class=mf>1.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>IPO</span> <span class=n>图</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>IPO</span> <span class=n>图是输入</span><span class=err>、</span><span class=n>处理</span><span class=err>、</span><span class=n>输出图的简称</span><span class=err>，</span><span class=n>能够方便地描绘输入数据</span><span class=err>、</span><span class=n>对数据的处理和输出数据之间的关系</span><span class=err>。</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图7</span><span class=o>-</span><span class=mf>2.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>6.</span>  <span class=n>数据字典</span><span class=err>、</span><span class=n>数据流图</span><span class=err>、</span><span class=n>数据库间的关系</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>数据字典是关于数据的信息的集合</span><span class=err>，</span><span class=n>也就是对数据流图中包含的所有元素的定义的集合</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>数据字典</span><span class=err>、</span><span class=n>数据流图共同构成逻辑模型</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>从数据字典</span><span class=err>、</span><span class=n>数据流图出发</span><span class=err>，</span><span class=n>首先得到的是数据库的概念结构</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>小结</span><span class=err>：（</span><span class=n>数据字典</span> <span class=o>-&gt;</span> <span class=n>数据流图</span><span class=err>）</span><span class=n>可行性研究的逻辑模型</span> <span class=o>-&gt;</span> <span class=n>数据库的概念模型</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>7.</span>  <span class=n>启发式规则</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图7</span><span class=o>-</span><span class=mf>3.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>8.</span>  <span class=n>面向数据流的设计方法</span><span class=err>（</span><span class=n>结构化设计方法</span><span class=err>）：</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>概念</span><span class=err>：</span><span class=n>把数据流图变成软件结构</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>方法</span><span class=err>（</span><span class=n>变换分析设计</span><span class=err>）：</span><span class=n>数据流图求精</span> <span class=o>-&gt;</span> <span class=n>独立出变化中心</span> <span class=o>-&gt;</span> <span class=n>各个控制模块</span> <span class=o>-&gt;</span> <span class=n>映射成软件中适当的模块</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图7</span><span class=o>-</span><span class=mf>4.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>9.</span>  <span class=n>变换流与事物流</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>数据流图</span><span class=err>（</span><span class=n>DFD</span><span class=err>）</span><span class=n>一般可分为</span> <span class=err>“</span><span class=n>变换流</span><span class=err>”，“</span><span class=n>事物流</span><span class=err>”</span> <span class=n>两种</span><span class=err>。</span><span class=n>这是信息流的两种类型</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=err>“</span><span class=n>变换流</span><span class=err>”：</span><span class=n>由输入</span><span class=err>、</span><span class=n>处理</span><span class=err>、</span><span class=n>输出三部分组成</span><span class=err>，</span><span class=n>是一顺序结构</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=err>“</span><span class=n>事物流</span><span class=err>”：</span><span class=n>它的某个加工</span><span class=err>，</span><span class=n>分离成许多分散的数据流</span><span class=err>，</span><span class=n>形成许多加工路径</span><span class=err>，</span><span class=n>并且根据输入值选择其中一个路径来执行</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>10.</span>  <span class=n>从数据流导出软件的层次结构</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>数据流图反应的是数据的系统逻辑模型</span><span class=err>，</span><span class=n>是信息流在系统中的流动反应</span><span class=err>，</span><span class=n>结构图是系统的物理模型</span><span class=err>，</span><span class=n>他反应的是系统的层次结构和功能关系</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>在系统设计阶段</span><span class=err>，</span><span class=n>可以根据</span> <span class=n>DFD</span> <span class=n>图</span><span class=err>，</span><span class=n>分别通过变换分析和事务分析方法</span><span class=err>，</span><span class=n>先设计结构图的顶端主模块</span><span class=err>，</span><span class=n>然后自顶向下逐步细化</span><span class=err>，</span><span class=n>从</span> <span class=n>DFD</span> <span class=n>图导出满足数据流图要求的</span><span class=err>、</span><span class=n>标准形式的系统结构图</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>11.</span>  <span class=n>总体设计与需求分析间的关系</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>总体设计需求分析的结果</span><span class=err>，</span><span class=n>需求分析是系统设计的依据</span><span class=err>。</span><span class=o>/</span> <span class=n>补充</span><span class=err>：</span><span class=n>将逻辑模型</span><span class=err>（</span><span class=n>分析模型</span><span class=err>）</span><span class=n>转换为物理模型</span><span class=err>（</span><span class=n>设计模型</span><span class=err>）。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#补充-2 &#34;补充&#34;)补充</span>
</span></span><span class=line><span class=cl><span class=o>----------------</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=n>架构设计</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>它是一个软件系统从整体到部分的最高层次的划分</span><span class=err>。</span><span class=o>/</span> <span class=n>一个系统通常是由元件组成的</span><span class=err>，</span><span class=n>而这些元件如何形成</span><span class=err>、</span><span class=n>相互之间如何发生作用</span><span class=err>，</span><span class=n>则是关于这个系统本身结构的重要信息</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>架构设计详细地说</span><span class=err>，</span><span class=n>就是要包括架构元件</span><span class=err>（</span><span class=n>Architecture</span> <span class=n>Component</span><span class=err>）、</span><span class=n>联结器</span><span class=err>（</span><span class=n>Connector</span><span class=err>）、</span><span class=n>任务流</span><span class=err>（</span><span class=n>TASk</span><span class=o>-</span><span class=n>flow</span><span class=err>）。</span><span class=n>所谓架构元素</span><span class=err>，</span><span class=n>也就是组成系统的核心</span><span class=err>”</span> <span class=n>砖瓦</span><span class=err>”，</span><span class=n>而联结器则描述这些元件之间通讯的路径</span><span class=err>、</span><span class=n>通讯的机制</span><span class=err>、</span><span class=n>通讯的预期结果</span><span class=err>，</span><span class=n>任务流则描述系统如何使用这些元件和联结器完成某一项需求</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>三个方面</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>逻辑架构</span><span class=err>、</span><span class=n>物理架构</span><span class=err>、</span><span class=n>系统架构</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=n>技术选型</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>参考</span><span class=err>：</span><span class=p>[</span><span class=n>架构设计和技术选型的思路总结</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>blog</span><span class=o>.</span><span class=n>csdn</span><span class=o>.</span><span class=n>net</span><span class=o>/</span><span class=n>andrewniu</span><span class=o>/</span><span class=n>article</span><span class=o>/</span><span class=n>details</span><span class=o>/</span><span class=mi>78688371</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>3.</span>  <span class=n>重构</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>概念</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>重构</span><span class=err>（</span><span class=n>Refactoring</span><span class=err>）</span><span class=n>就是通过调整程序代码改善软件的质量</span><span class=err>、</span><span class=n>性能</span><span class=err>，</span><span class=n>使其程序的设计模式和架构更趋合理</span><span class=err>，</span><span class=n>提高软件的扩展性和维护性</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>重构的时机</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>在添加新功能时进行重构</span><span class=err>、</span><span class=n>在修改</span> <span class=n>bug</span> <span class=n>时进行重构</span><span class=err>、</span><span class=n>在代码复审时进行重构</span><span class=err>、</span><span class=n>到了最后的交付期限不进行重构</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>重构难题</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>（</span><span class=n>a</span> <span class=n>关系数据库与面向对象编程的问题</span><span class=err>——</span><span class=n>在对象模型和数据库模型之间插入一个分隔层</span><span class=err>，</span><span class=n>这就可以隔离两个模型各自的变化</span><span class=err>，</span><span class=n>升级某一模型时只需同时升级上述的分隔层即可</span><span class=err>，</span><span class=n>这样的分隔层会增加系统复杂度</span><span class=err>，</span><span class=n>但是能增加灵活度</span><span class=err>。</span><span class=o>/</span> <span class=err>（</span><span class=n>b</span>  
</span></span><span class=line><span class=cl>    <span class=n>修改接口的问题</span><span class=err>——</span><span class=n>修改已发布的接口</span><span class=err>，</span><span class=n>因为已发布的接口会供外部人员</span><span class=err>（</span><span class=n>其它公司</span><span class=err>）</span><span class=n>使用</span><span class=err>，</span><span class=n>因此修改接口会导致引用接口的其它程序不修改程序就无法运行</span><span class=err>。</span><span class=n>修改接口的最好的办法是增加一个新的接口</span><span class=err>，</span><span class=n>让旧接口调用新接口</span><span class=err>，</span><span class=n>这样原来的程序就不用修改了</span><span class=err>。</span><span class=n>对于接口的另一个建议是尽量不要发布接口</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#六-详细设计（模块设计） &#34;六 详细设计（模块设计）&#34;)六 详细设计（模块设计）</span>
</span></span><span class=line><span class=cl><span class=o>============================================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=n>结构程序设计概念</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>是进行以模块功能和处理过程设计为主的详细设计的基本原则</span><span class=err>。</span><span class=n>结构化程序设计是过程式程序设计的一个子集</span><span class=err>，</span><span class=n>它对写入的程序使用逻辑结构</span><span class=err>，</span><span class=n>使得理解和修改更有效更容易</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>经典的结构程序设计</span><span class=err>：</span><span class=n>三种基本控制结构</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>扩展的结构程序设计</span><span class=err>：</span><span class=n>允许使用</span> <span class=n>do</span><span class=o>-</span><span class=n>case</span><span class=err>、</span><span class=n>do</span><span class=o>-</span><span class=n>until</span> <span class=n>循环结构</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>修正的结构程序设计</span><span class=err>：</span><span class=n>允许加上</span> <span class=k>break</span> <span class=n>结构</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=n>过程设计工具</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>用图形</span><span class=err>、</span><span class=n>表格</span><span class=err>、</span><span class=n>语言</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>程序流程图</span><span class=err>：</span><span class=n>不易表示数据结构</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>盒图</span><span class=err>（</span><span class=n>N</span><span class=o>-</span><span class=n>S</span> <span class=n>图</span><span class=err>）：</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图8</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>PAD</span> <span class=n>图</span><span class=err>（</span><span class=n>问题分析图</span><span class=err>）：</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图9</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>判定树</span><span class=err>。</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图10</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>判定表</span><span class=err>。</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图11</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>过程设计语言</span><span class=err>（</span><span class=n>PDL</span> <span class=n>伪码</span><span class=err>）。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>3.</span>  <span class=n>Jackson</span> <span class=n>程序设计方法</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图12</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=n>从目标系统的输入</span><span class=err>、</span><span class=n>输出数据结构入手</span><span class=err>，</span><span class=n>导出程序框架结构</span><span class=err>，</span><span class=n>再补充其它细节</span><span class=err>，</span><span class=n>就可得到完整的程序结构图</span><span class=err>。</span><span class=n>这一方法对输入</span><span class=err>、</span><span class=n>输出数据结构明确的中小型系统特别有效</span><span class=err>，</span><span class=n>如商业应用中的文件表格处理</span><span class=err>。</span><span class=n>该方法也可与其它方法结合</span><span class=err>，</span><span class=n>用于模块的详细设计</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>4.</span>  <span class=n>Warnier</span> <span class=n>程序设计方法</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>Warnier</span> <span class=n>提出的软件开发方法与</span> <span class=n>Jackson</span> <span class=n>方法类似</span><span class=err>。</span><span class=n>差别有三点</span><span class=err>：</span><span class=n>一是它们使用的图形工具不同</span><span class=err>，</span><span class=n>分别使用</span> <span class=n>Warnier</span> <span class=n>图和</span> <span class=n>Jackson</span> <span class=n>图</span><span class=err>；</span><span class=n>另一个差别是使用的伪码不同</span><span class=err>；</span><span class=n>最主要的差别是在构造程序框架时</span><span class=err>，</span><span class=n>Warnier</span> <span class=n>方法仅考虑输入数据结构</span><span class=err>，</span><span class=n>而</span> <span class=n>Jackson</span> <span class=n>方法不仅考虑输入数据结构</span><span class=err>，</span><span class=n>而且还考虑输出数据结构</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>5.</span>  <span class=n>程序复杂结构的定量度量</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图13</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图14</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#七-实现（编码、单元测试、综合测试） &#34;七 实现（编码、单元测试、综合测试）&#34;)七 实现（编码、单元测试、综合测试）</span>
</span></span><span class=line><span class=cl><span class=o>==============================================================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=n>编码</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>选择程序设计语言</span><span class=err>、</span><span class=n>编码风格</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=n>测试等见最后的总结</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>3.</span>  <span class=n>黑盒测试之等价划分方法</span><span class=err>：</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>有</span> <span class=o>/</span> <span class=n>无效等价类</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>测试用例</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图15</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>4.</span>  <span class=n>黑盒测试之边界值分析方法</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图16</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>5.</span>  <span class=n>白盒测试之逻辑覆盖</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>参考</span><span class=err>：</span><span class=n>白盒测试</span><span class=err>：</span><span class=n>语句覆盖</span><span class=err>、</span><span class=n>条件覆盖</span><span class=err>、</span><span class=n>判定覆盖</span><span class=err>、</span><span class=n>条件</span> <span class=o>-</span> <span class=n>判定覆盖</span><span class=err>、</span><span class=n>组合覆盖</span><span class=err>、</span><span class=n>路径覆盖</span><span class=p>](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>blog</span><span class=o>.</span><span class=n>csdn</span><span class=o>.</span><span class=n>net</span><span class=o>/</span><span class=n>cyjs1988</span><span class=o>/</span><span class=n>article</span><span class=o>/</span><span class=n>details</span><span class=o>/</span><span class=mi>80341415</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图17</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图18</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#八-维护 &#34;八 维护&#34;)八 维护</span>
</span></span><span class=line><span class=cl><span class=o>====================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=n>四项活动</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>改正性维护</span><span class=err>、</span><span class=n>适应性维护</span><span class=err>、</span><span class=n>完善性维护</span><span class=err>、</span><span class=n>预防性维护</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=n>决定软件可维护性因素</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>可理解性</span><span class=err>、</span><span class=n>可测试性</span><span class=err>、</span><span class=n>可修改性</span><span class=err>、</span><span class=n>可靠性</span><span class=err>、</span><span class=n>可移植性</span><span class=err>、</span><span class=n>可使用性</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#九、十-面向对象方法学引论与面向对象分析 &#34;九、十 面向对象方法学引论与面向对象分析&#34;)九、十 面向对象方法学引论与面向对象分析</span>
</span></span><span class=line><span class=cl><span class=o>====================================================================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=n>面向对象开发方法</span><span class=err>：</span>
</span></span><span class=line><span class=cl><span class=mf>3.</span>  <span class=n>概念</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图19</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图20</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>4.</span>  <span class=n>面向对象三大特性</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>封装</span><span class=err>、</span><span class=n>继承</span><span class=err>、</span><span class=n>多态</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>5.</span>  <span class=n>面向对象建模</span><span class=err>：</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>定义类</span><span class=err>：</span><span class=n>类名</span><span class=err>、</span><span class=n>属性</span><span class=err>、</span><span class=n>服务</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>5.</span>  <span class=n>面向对象分析之建模的三个模型</span><span class=err>：</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>对象模型</span><span class=err>：</span><span class=n>静态结构</span><span class=err>。</span><span class=n>定义了做事情的实体</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>功能模型</span><span class=err>：</span><span class=n>功能</span><span class=err>。</span><span class=n>系统应该做什么</span><span class=err>。</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=n>动态模型</span><span class=err>：</span><span class=n>交互次序</span><span class=err>。</span><span class=n>规定了什么时候做</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>6.</span>  <span class=n>面向对象分析之五个层次</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>主题层</span><span class=err>、</span><span class=n>类与对象</span><span class=err>、</span><span class=n>结构层</span><span class=err>、</span><span class=n>属性层</span><span class=err>、</span><span class=n>服务层</span><span class=err>。</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=mf>7.</span>  <span class=n>UML</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图21</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#十一-面向对象设计 &#34;十一 面向对象设计&#34;)十一 面向对象设计</span>
</span></span><span class=line><span class=cl><span class=o>===================================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=n>概念</span><span class=err>：</span>  
</span></span><span class=line><span class=cl>    <span class=n>模块化</span><span class=err>、</span><span class=n>低耦合高内聚</span><span class=err>、</span><span class=n>抽象</span><span class=err>、</span><span class=n>信息隐藏</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#十二（第十二章略） &#34;十二（第十二章略）&#34;)十二（第十二章略）</span>
</span></span><span class=line><span class=cl><span class=o>===================================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#十三-软件项目管理 &#34;十三 软件项目管理&#34;)十三 软件项目管理</span>
</span></span><span class=line><span class=cl><span class=o>===================================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图x</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[](</span><span class=c1>#十四-总结（知识框架） &#34;十四 总结（知识框架）&#34;)十四 总结（知识框架）</span>
</span></span><span class=line><span class=cl><span class=o>=========================================</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;</span> <span class=n>仅针对本书</span><span class=err>。</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>!</span><span class=p>[](</span><span class=n>https</span><span class=p>:</span><span class=o>//</span><span class=n>marlous</span><span class=o>.</span><span class=n>github</span><span class=o>.</span><span class=n>io</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>04</span><span class=o>/</span><span class=err>《</span><span class=n>软件工程导论</span><span class=err>》</span><span class=n>张海潘版核心纲要读书笔记</span><span class=o>/</span><span class=n>图22</span><span class=o>.</span><span class=n>PNG</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span> <span class=o>*</span> <span class=o>*</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=p>[</span><span class=err>←</span> <span class=n>Previous</span> <span class=n>Post</span><span class=p>](</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>06</span><span class=o>/</span><span class=n>UX</span><span class=o>-</span><span class=n>UI</span><span class=o>-</span><span class=n>一站式设计平台</span><span class=err>：</span><span class=n>Adobe</span><span class=o>-</span><span class=n>XD</span><span class=o>-</span><span class=n>使用笔记</span><span class=o>/</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=o>*</span>   <span class=p>[</span><span class=n>Next</span> <span class=n>Post</span> <span class=err>→</span><span class=p>](</span><span class=o>/</span><span class=mi>2018</span><span class=o>/</span><span class=mi>11</span><span class=o>/</span><span class=mi>02</span><span class=o>/</span><span class=n>源代码静态分析工具</span><span class=o>-</span><span class=n>Source</span><span class=o>-</span><span class=n>Insight</span><span class=o>-</span><span class=n>使用</span><span class=err>（</span><span class=n>以</span><span class=o>-</span><span class=n>Nginx</span><span class=o>-</span><span class=n>源码为例</span><span class=err>）</span><span class=o>/</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=mf>1.</span>  <span class=p>[</span><span class=n>软件工程</span><span class=p>](</span><span class=c1>#软件工程)</span>
</span></span><span class=line><span class=cl>    <span class=mf>1.</span>  <span class=p>[</span><span class=mi>1</span> <span class=n>工具</span><span class=p>](</span><span class=c1>#1-工具)</span>
</span></span><span class=line><span class=cl>    <span class=mf>2.</span>  <span class=p>[</span><span class=mi>2</span> <span class=n>软件工程文档</span><span class=p>](</span><span class=c1>#2-软件工程文档)</span>
</span></span><span class=line><span class=cl><span class=mf>2.</span>  <span class=p>[</span><span class=n>一</span> <span class=n>软件工程学概述</span><span class=p>](</span><span class=c1>#一-软件工程学概述)</span>
</span></span><span class=line><span class=cl><span class=mf>3.</span>  <span class=p>[</span><span class=n>二</span> <span class=n>可行性研究</span><span class=p>](</span><span class=c1>#二-可行性研究)</span>
</span></span><span class=line><span class=cl>    <span class=mf>1.</span>  <span class=p>[</span><span class=n>补充</span><span class=p>](</span><span class=c1>#补充)</span>
</span></span><span class=line><span class=cl><span class=mf>4.</span>  <span class=p>[</span><span class=n>三</span> <span class=n>需求分析</span><span class=p>](</span><span class=c1>#三-需求分析)</span>
</span></span><span class=line><span class=cl>    <span class=mf>1.</span>  <span class=p>[</span><span class=n>补充</span><span class=p>](</span><span class=c1>#补充-1)</span>
</span></span><span class=line><span class=cl><span class=mf>5.</span>  <span class=p>[</span><span class=n>四</span> <span class=n>形式化说明技术</span><span class=err>（</span><span class=n>略</span><span class=err>）</span><span class=p>](</span><span class=c1>#四-形式化说明技术（略）)</span>
</span></span><span class=line><span class=cl><span class=mf>6.</span>  <span class=p>[</span><span class=n>五</span> <span class=n>总体设计</span><span class=err>（</span><span class=n>系统设计</span><span class=err>）</span><span class=p>](</span><span class=c1>#五-总体设计（系统设计）)</span>
</span></span><span class=line><span class=cl>    <span class=mf>1.</span>  <span class=p>[</span><span class=n>补充</span><span class=p>](</span><span class=c1>#补充-2)</span>
</span></span><span class=line><span class=cl><span class=mf>7.</span>  <span class=p>[</span><span class=n>六</span> <span class=n>详细设计</span><span class=err>（</span><span class=n>模块设计</span><span class=err>）</span><span class=p>](</span><span class=c1>#六-详细设计（模块设计）)</span>
</span></span><span class=line><span class=cl><span class=mf>8.</span>  <span class=p>[</span><span class=n>七</span> <span class=n>实现</span><span class=err>（</span><span class=n>编码</span><span class=err>、</span><span class=n>单元测试</span><span class=err>、</span><span class=n>综合测试</span><span class=err>）</span><span class=p>](</span><span class=c1>#七-实现（编码、单元测试、综合测试）)</span>
</span></span><span class=line><span class=cl><span class=mf>9.</span>  <span class=p>[</span><span class=n>八</span> <span class=n>维护</span><span class=p>](</span><span class=c1>#八-维护)</span>
</span></span><span class=line><span class=cl><span class=mf>10.</span>  <span class=p>[</span><span class=n>九</span><span class=err>、</span><span class=n>十</span> <span class=n>面向对象方法学引论与面向对象分析</span><span class=p>](</span><span class=c1>#九、十-面向对象方法学引论与面向对象分析)</span>
</span></span><span class=line><span class=cl><span class=mf>11.</span>  <span class=p>[</span><span class=n>十一</span> <span class=n>面向对象设计</span><span class=p>](</span><span class=c1>#十一-面向对象设计)</span>
</span></span><span class=line><span class=cl><span class=mf>12.</span>  <span class=p>[</span><span class=n>十二</span><span class=err>（</span><span class=n>第十二章略</span><span class=err>）</span><span class=p>](</span><span class=c1>#十二（第十二章略）)</span>
</span></span><span class=line><span class=cl><span class=mf>13.</span>  <span class=p>[</span><span class=n>十三</span> <span class=n>软件项目管理</span><span class=p>](</span><span class=c1>#十三-软件项目管理)</span>
</span></span><span class=line><span class=cl><span class=mf>14.</span>  <span class=p>[</span><span class=n>十四</span> <span class=n>总结</span><span class=err>（</span><span class=n>知识框架</span><span class=err>）</span><span class=p>](</span><span class=c1>#十四-总结（知识框架）)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>##### [FEATURED TAGS](/tags/)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>学习笔记</span><span class=p>](</span><span class=o>/</span><span class=n>tags</span><span class=o>/</span><span class=c1>#学习笔记 &#34;学习笔记&#34;)</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://zcy2875634712.github.io/posts/note/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/><span class=title>« Prev</span><br><span>数据结构</span></a>
<a class=next href=https://zcy2875634712.github.io/posts/note/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/><span class=title>Next »</span><br><span>深度学习</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 核心纲要读书笔记 on twitter" href="https://twitter.com/intent/tweet/?text=%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BA%25B2%25E8%25A6%2581%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 核心纲要读书笔记 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BA%25B2%25E8%25A6%2581%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f&amp;title=%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0&amp;summary=%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0&amp;source=https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BA%25B2%25E8%25A6%2581%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 核心纲要读书笔记 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BA%25B2%25E8%25A6%2581%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f&title=%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 核心纲要读书笔记 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BA%25B2%25E8%25A6%2581%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 核心纲要读书笔记 on whatsapp" href="https://api.whatsapp.com/send?text=%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0%20-%20https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BA%25B2%25E8%25A6%2581%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 核心纲要读书笔记 on telegram" href="https://telegram.me/share/url?text=%e6%a0%b8%e5%bf%83%e7%ba%b2%e8%a6%81%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0&amp;url=https%3a%2f%2fzcy2875634712.github.io%2fposts%2fnote%2f%25E6%25A0%25B8%25E5%25BF%2583%25E7%25BA%25B2%25E8%25A6%2581%25E8%25AF%25BB%25E4%25B9%25A6%25E7%25AC%2594%25E8%25AE%25B0%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://zcy2875634712.github.io/>ybyb</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>